{
  "project": "FoundryData",
  "version": "0.1.0-mvp",
  "approach": "Hybrid (Task Master structure + granular subtasks)",
  "coverage-aware-v1": {
    "tasks": [
      {
        "id": 9300,
        "title": "Define coverage core types and ID semantics",
        "description": "Introduce CoverageTarget, CoverageGraph and related types with deterministic, stable IDs for coverage-aware runs.",
        "priority": "high",
        "estimatedHours": 10,
        "dependencies": [],
        "status": "done",
        "complexityScore": 3,
        "details": "[Context]\nDefine the core coverage model for FoundryData, including CoverageTarget, CoverageTargetReport and CoverageGraph nodes and dimensions. Align with the coverage-aware spec §3 (Coverage model) and §3.2 (CoverageTargets), and ensure IDs are stable across runs and independent of dimensionsEnabled.\n\n[Key requirements]\n- Design CoverageTarget, CoverageTargetReport and CoverageGraph types that can represent structure, branches, enum values, boundaries and operation-linked nodes.\n- Introduce a canonical CoverageDimension union used consistently in core and shared packages: type CoverageDimension = 'structure' | 'branches' | 'enum' | 'boundaries' | 'operations'; and reuse it for CoverageTarget.dimension, run.dimensionsEnabled and metrics.byDimension keys.\n- Define a deterministic, canonical ID scheme for CoverageTarget.id that only depends on canonical schema, optional OpenAPI mapping, FoundryData major version and coverage-report format major; IDs MUST NOT depend on dimensionsEnabled or runtime coverage options.\n- Represent dimensions (structure, branches, enum, boundaries, operations) and statuses ('active', 'unreachable' and 'deprecated'), plus inert fields weight and polarity.\n- Support diagnostic-only target kinds such as SCHEMA_REUSED_COVERED by always emitting them with status:'deprecated' so they remain visible in targets[] and diagnostics but never contribute to metrics.overall, metrics.byDimension, metrics.byOperation or minCoverage enforcement.\n- Ensure the CoverageGraph can be derived from Normalize/Compose canonical artifacts without reparsing the raw schema or re-implementing JSON Schema semantics.\n- Provide basic helpers for mapping canonical JSON Pointers and operation keys (operationId or <METHOD> <path>) to coverage nodes, without forcing OpenAPI operation-level logic into the core analyzer before task 9310.\n\n[Deliverables]\n- Core coverage model types under packages/core/src/coverage/model.ts.\n- Utility functions for CoverageGraph construction hooks under packages/core/src/coverage/graph.ts.\n- Shared type exports in packages/shared/src/types/coverage.ts for CLI and reporter consumers.\n\n[Definition of Done]\n- CoverageTarget, CoverageTargetReport, CoverageGraph and CoverageDimension types are defined and exported from core and shared packages.\n- The ID generation scheme is documented and deterministic in unit tests: the same canonical schema and OpenAPI mapping produce the same IDs, and changing dimensionsEnabled does not change IDs for any target that exists under both projections.\n- The model supports all dimensions defined in the spec, including future boundaries and operation-linked kinds, and can represent diagnostic-only targets such as SCHEMA_REUSED_COVERED while keeping their status:'deprecated' semantics aligned with metrics exclusions.\n- No new model type requires reparsing user schemas; everything is expressed in terms of canonical schema pointers and Compose artifacts.\n- Basic unit tests for the ID generator and CoverageGraph helpers are green and integrated in CI.",
        "testStrategy": "Unit tests for ID determinism and stability across runs with fixed canonical schemas; property-based tests that hash canonical views and check CoverageTarget.id stability when dimensionsEnabled is toggled; type-level tests to ensure dimensions, statuses and diagnostic kinds like SCHEMA_REUSED_COVERED match the spec; review of public exports to avoid breaking shared consumers; property-based tests that build Analyzer output twice for the same canonical schema with different dimensionsEnabled projections (e.g. ['structure','branches'] vs ['structure','branches','enum']) and assert that IDs and shapes of non-enum targets remain identical after sorting by id.",
        "subtasks": [
          {
            "id": 9300001,
            "title": "Design CoverageTarget and CoverageGraph types",
            "description": "Sketch and implement CoverageTarget, CoverageTargetReport and CoverageGraph interfaces, including dimensions, status, weight, polarity and meta fields. Define branch target kinds ONEOF_BRANCH, ANYOF_BRANCH and CONDITIONAL_PATH (for if/then/else and dependentSchemas paths) and a params shape that records pathKind and branchKey without depending on dimensionsEnabled.",
            "status": "done",
            "estimatedHours": 3,
            "file": "packages/core/src/coverage/model.ts",
            "parentId": "9300",
            "updatedAt": "2025-11-29T00:39:51.203Z"
          },
          {
            "id": 9300002,
            "title": "Implement deterministic CoverageTarget ID generator",
            "description": "Implement a stable ID generator for coverage targets based on canonical paths, kind, dimension and optional operationKey and params, independent of dimensionsEnabled. IDs MUST NOT depend on status, hit, weight, polarity, meta, dimensionsEnabled, excludeUnreachable, planner caps, hints or any runtime coverage results.",
            "status": "done",
            "estimatedHours": 3,
            "file": "packages/core/src/coverage/id-generator.ts",
            "parentId": "9300",
            "updatedAt": "2025-11-29T00:39:57.522Z"
          },
          {
            "id": 9300003,
            "title": "Expose coverage types in shared package",
            "description": "Re-export coverage types in the shared package for consumption by CLI and reporter.",
            "status": "done",
            "estimatedHours": 2,
            "file": "packages/shared/src/types/coverage.ts",
            "parentId": "9300",
            "updatedAt": "2025-11-29T00:40:03.128Z"
          },
          {
            "id": 9300004,
            "title": "Add unit tests for ID stability and dimensions",
            "description": "Add tests that assert IDs are stable when dimensionsEnabled, excludeUnreachable or planner/cap options change, including a projection test where the same canonical schema is analyzed with different dimensionsEnabled sets (e.g. ['structure','branches'] vs ['structure','branches','enum']) and non-enum CoverageTarget.id values remain identical.",
            "status": "done",
            "estimatedHours": 2,
            "file": "packages/core/src/coverage/__tests__/model.spec.ts",
            "parentId": "9300",
            "updatedAt": "2025-11-29T00:40:09.261Z"
          }
        ],
        "updatedAt": "2025-11-29T00:40:09.261Z"
      },
      {
        "id": 9301,
        "title": "Implement CoverageAnalyzer from canonical Compose artifacts",
        "description": "Build CoverageAnalyzer to derive the CoverageGraph and full CoverageTarget set from Normalize/Compose artifacts.",
        "priority": "high",
        "estimatedHours": 14,
        "dependencies": [
          "9300"
        ],
        "status": "done",
        "complexityScore": 4,
        "details": "[Context]\nImplement CoverageAnalyzer as a new stage between Compose and generation, per coverage-aware spec §4.1 (CoverageAnalyzer) and §3.1 (CoverageGraph). The analyzer consumes canonical schemas, ptrMap, CoverageIndex, planDiag and optional OpenAPI context and produces a deterministic CoverageGraph plus the exhaustive CoverageTarget set for the enabled dimensions (structure, branches, enum) in M0/M1.\n\n[Key requirements]\n- Consume only canonical view and Compose artifacts (canonSchema, ptrMap, CoverageIndex, planDiag) and optional OpenAPI context; never reparse the raw schema, and do not construct OperationNodes or OP_* targets in this task.\n- Materialize CoverageGraph nodes and edges for schemas, properties, branches (oneOf/anyOf/conditionals), enums (including potentially large enums) and simple structural constraints, as preparation for the boundaries dimension introduced in task 9309, without yet materializing *_HIT targets for boundaries, with structural, logical and reference edges.\n- Generate CoverageTargets for all enabled dimensions (structure, branches, enum in M0/M1) with stable IDs using the model defined in task 9300. In standard modes, do not materialize targets for dimensions that are not in dimensionsEnabled; any future debug/introspection mode must be explicitly opt-in.\n- For large enums, Analyzer MAY deterministically subsample enum values into CoverageTargets, recording this in target meta (for example meta.enumSubsampled:true and/or skipped indices) so behavior is reproducible and visible to tooling.\n- Under AP:false, PROPERTY_PRESENT targets for undeclared property names must be backed exclusively by CoverageIndex.has / CoverageIndex.enumerate; CoverageAnalyzer must not introduce a separate automaton for AP:false property names, must only create PROPERTY_PRESENT targets for names exposed by CoverageIndex and must not diverge from CoverageIndex semantics.\n- Derive status:'unreachable' targets conservatively from existing diagnostics (e.g. UNSAT_* codes, CoverageIndex emptiness) and branch pruning heuristics, without introducing a separate proof engine; when in doubt, prefer leaving targets active and uncovered.\n- Ensure analyzer output is deterministic for fixed inputs and options, with no RNG or time-dependent behavior, and treat dimensionsEnabled as a projection over a stable target universe (toggling dimensionsEnabled does not change IDs of targets present in both configurations).\n- Ensure CoverageAnalyzer is only invoked when coverageMode is 'measure' or 'guided'; pipeline runs with coverage=off must skip CoverageAnalyzer entirely to keep overhead close to the current engine.\n\n[Deliverables]\n- CoverageAnalyzer implementation under packages/core/src/coverage/coverage-analyzer.ts.\n- Integration glue in the pipeline orchestrator to run CoverageAnalyzer after Compose and before planner/generator when coverageMode != 'off'.\n- Unit tests and fixtures for schemas with oneOf/anyOf, AP:false objects and enums to validate CoverageGraph topology and targets.\n\n[Definition of Done]\n- CoverageAnalyzer can be invoked from the pipeline with canonical Compose outputs and returns a deterministic CoverageGraph and CoverageTarget[] for the enabled dimensions.\n- Analyzer never reparses the raw schema or re-implements JSON Schema semantics; all logic is driven by canonical views and existing diagnostics.\n- Unreachable targets are marked only when supported by strong signals (UNSAT diagnostics or CoverageIndex emptiness), and tests cover false-positive avoidance.\n- When an OpenAPI document is present, schema-level targets and IDs remain stable; operation-level targets and OperationNodes are added later by task 9310, and enabling/disabling OpenAPI context does not change schema-level CoverageTarget.id values.\n- Pipeline integration tests verify that CoverageAnalyzer is not called when coverageMode is 'off'.\n- All new diagnostics and status markings are covered by unit tests and pass CI.",
        "testStrategy": "Unit tests using small JSON Schema fixtures (including AP:false objects) to snapshot CoverageGraph topology and targets; property-based tests that show adding or removing dimensionsEnabled does not change existing target IDs; targeted tests around AP:false to ensure PROPERTY_PRESENT for undeclared names aligns exactly with CoverageIndex.enumerate; integration tests in the pipeline to assert CoverageAnalyzer is invoked only for coverage=measure/guided and output is deterministic across repeated runs.",
        "subtasks": [
          {
            "id": 9301001,
            "title": "Wire CoverageAnalyzer inputs from Compose",
            "description": "Connect canonSchema, ptrMap, CoverageIndex and planDiag into a CoverageAnalyzer entry point, gated so it is only called when coverageMode is 'measure' or 'guided'.",
            "status": "done",
            "estimatedHours": 3,
            "file": "packages/core/src/coverage/coverage-analyzer.ts",
            "parentId": "9301",
            "updatedAt": "2025-11-27T23:03:38.786Z"
          },
          {
            "id": 9301002,
            "title": "Implement graph construction for schema, property and branch nodes",
            "description": "Build CoverageGraph nodes and edges for schemas, properties and oneOf/anyOf/conditional branches using canonical pointers.",
            "status": "done",
            "estimatedHours": 4,
            "file": "packages/core/src/coverage/coverage-analyzer.ts",
            "parentId": "9301",
            "updatedAt": "2025-11-27T23:13:14.654Z"
          },
          {
            "id": 9301003,
            "title": "Generate CoverageTargets for structure, branches and enum dimensions",
            "description": "Materialize SCHEMA_NODE, PROPERTY_PRESENT, ONEOF_BRANCH, ANYOF_BRANCH, CONDITIONAL_PATH and ENUM_VALUE_HIT targets for enabled dimensions, with IDs independent of dimensionsEnabled.",
            "status": "done",
            "estimatedHours": 3,
            "file": "packages/core/src/coverage/coverage-analyzer.ts",
            "parentId": "9301",
            "updatedAt": "2025-11-29T14:43:30.917Z"
          },
          {
            "id": 9301004,
            "title": "Derive unreachable targets from existing diagnostics",
            "description": "Integrate UNSAT_* and AP:false diagnostics and CoverageIndex signals to mark a conservative subset of targets as status:'unreachable'.",
            "status": "done",
            "estimatedHours": 2,
            "file": "packages/core/src/coverage/coverage-analyzer-unreachable.ts",
            "parentId": "9301",
            "updatedAt": "2025-11-27T23:30:00.195Z"
          },
          {
            "id": 9301005,
            "title": "Add unit tests for CoverageAnalyzer determinism and topology",
            "description": "Create fixtures and tests verifying target sets, IDs and statuses stay stable across runs and for different dimensionsEnabled and coverageMode configurations, including schemas with if/then/else or dependentSchemas so CONDITIONAL_PATH targets are materialized and tracked, and large enums where subsampled enum targets and their meta remain deterministic.",
            "status": "done",
            "estimatedHours": 2,
            "file": "packages/core/src/coverage/__tests__/coverage-analyzer.spec.ts",
            "parentId": "9301",
            "updatedAt": "2025-11-27T23:34:31.947Z"
          }
        ],
        "updatedAt": "2025-11-29T14:43:30.917Z"
      },
      {
        "id": 9302,
        "title": "Add passive coverage instrumentation for measurement mode (M0)",
        "description": "Instrument generator and repair stages to emit coverage events for structure, branches and enums in coverage=measure mode without changing generated instances.",
        "priority": "high",
        "estimatedHours": 16,
        "dependencies": [
          "9300",
          "9301"
        ],
        "status": "done",
        "complexityScore": 4,
        "details": "[Context]\nImplement M0 coverage measurement for the existing pipeline, per coverage-aware spec §2.1 (Phase M0) and §4.3 (Generator instrumentation). coverage=measure must compute coverage from final instances (after Repair + Validate) for SCHEMA_NODE, PROPERTY_PRESENT, ONEOF_BRANCH, ANYOF_BRANCH, CONDITIONAL_PATH and ENUM_VALUE_HIT targets, while leaving generator behavior identical to coverage=off for a given (schema, seed, options).\n\n[Key requirements]\n- Extend Generate and Repair to emit coverage events for schema nodes, optional property presence, oneOf/anyOf/conditional branches and enum values, using canonical pointers from the CoverageGraph.\n- Under AP:false, property presence coverage for undeclared property names MUST be derived solely from CoverageIndex.has / CoverageIndex.enumerate; instrumentation must not infer additional property names from patternProperties or propertyNames beyond what CoverageIndex exposes.\n- Ensure events are only committed as hits once instances have passed Validate; invalid instances must not mark targets as hit.\n- For coverage=measure, guarantee that the sequence of emitted instances is byte-for-byte identical to coverage=off for the same inputs; instrumentation must be purely observational and must not affect generation decisions.\n- Implement a first coverage accumulator that can support temporary post-pass computation for M0, while anticipating streaming updates required in M1.\n- Add toggles so coverage instrumentation is fully disabled when coverage=off, keeping overhead negligible and ensuring that in that mode neither CoverageAnalyzer nor coverage accumulators are invoked.\n\n[Deliverables]\n- Coverage event models and accumulator implementation under packages/core/src/coverage/coverage-events.ts.\n- Instrumentation hooks in generator and repair code paths to record branches, property presence and enum usage.\n- Configuration plumbing from CLI and Node API to select coverage=off or coverage=measure and to pass dimensionsEnabled down to instrumentation.\n\n[Definition of Done]\n- With coverage=measure and coverage=off, the generated data streams are identical for the same schemas and seeds, confirmed by golden tests.\n- Coverage accumulators correctly mark hits only after Validate, and targets remain unhit when instances are invalid or filtered out.\n- Property presence and branch hits (including ANYOF_BRANCH and CONDITIONAL_PATH) are derived from canonical view and CoverageGraph, not raw schema re-parsing, and AP:false property coverage matches CoverageIndex semantics for undeclared names.\n- Overhead of coverage=measure is measured and documented via existing metrics, and instrumentation cost is included in per-phase timings.\n- New instrumentation paths are guarded by feature flags so coverage=off behavior and performance remain within existing SLOs.",
        "testStrategy": "Golden snapshot tests comparing coverage=off vs coverage=measure output for the same schema and seed; unit tests for coverage event aggregation and per-target hit semantics (including ANYOF_BRANCH and CONDITIONAL_PATH); integration tests that run the full pipeline and assert that coverage metrics match expected hits on small schemas with oneOf, anyOf, conditional branches, optional properties and enums; tests for AP:false fixtures where CoverageIndex is empty and PROPERTY_PRESENT for undeclared names never appears, and where non-empty CoverageIndex ensures PROPERTY_PRESENT only for names it exposes; benchmark runs to confirm overhead stays within acceptable bounds.",
        "subtasks": [
          {
            "id": 9302001,
            "title": "Define coverage event model and accumulator",
            "description": "Create event types for schema, property, branch and enum hits and an accumulator that maps them to CoverageTargets.",
            "status": "done",
            "estimatedHours": 3,
            "file": "packages/core/src/coverage/coverage-events.ts",
            "parentId": "9302",
            "updatedAt": "2025-11-27T23:43:50.250Z"
          },
          {
            "id": 9302002,
            "title": "Instrument generator for branches and enums",
            "description": "Add hooks in the generator to emit coverage events when oneOf/anyOf/conditional branches are chosen and enum values are produced, keyed by canonical paths and branch identifiers.",
            "status": "done",
            "estimatedHours": 4,
            "file": "packages/core/src/generator/foundry-generator.ts",
            "parentId": "9302",
            "updatedAt": "2025-11-28T18:06:32.425Z"
          },
          {
            "id": 9302003,
            "title": "Instrument repair and property presence",
            "description": "Emit coverage events when properties are added or removed in Repair and when optional properties are present in final instances, including AP:false objects where property names come from CoverageIndex.",
            "status": "done",
            "estimatedHours": 3,
            "file": "packages/core/src/repair/repair-engine.ts",
            "parentId": "9302",
            "updatedAt": "2025-11-28T18:24:32.286Z"
          },
          {
            "id": 9302004,
            "title": "Integrate coverage accumulators into pipeline orchestrator",
            "description": "Wire coverage accumulators into the pipeline so coverage=measure collects events during Generate and Repair and finalizes after Validate, with all coverage code completely disabled when coverage=off.",
            "status": "done",
            "estimatedHours": 3,
            "file": "packages/core/src/pipeline/orchestrator.ts",
            "parentId": "9302",
            "updatedAt": "2025-11-28T18:40:56.119Z"
          },
          {
            "id": 9302005,
            "title": "Add regression tests for coverage=off vs coverage=measure equivalence",
            "description": "Create tests that run generate with and without coverage measurement and assert identical outputs while coverage metrics differ, including schemas with conditional branches (if/then/else or dependentSchemas) to verify CONDITIONAL_PATH events are emitted without changing generated instances.",
            "status": "done",
            "estimatedHours": 3,
            "file": "packages/core/test/e2e/coverage-measurement.spec.ts",
            "parentId": "9302",
            "updatedAt": "2025-11-28T18:49:48.162Z"
          }
        ],
        "updatedAt": "2025-11-28T18:49:48.162Z"
      },
      {
        "id": 9303,
        "title": "Implement coverage report format and CoverageEvaluator",
        "description": "Aggregate coverage results into the versioned JSON coverage-report/v1 format and expose coverage metrics and uncovered targets.",
        "priority": "high",
        "estimatedHours": 14,
        "dependencies": [
          "9300",
          "9301",
          "9302"
        ],
        "status": "done",
        "complexityScore": 4,
        "details": "[Context]\nImplement CoverageEvaluator and the JSON coverage report format per coverage-aware spec §4.4 (CoverageEvaluator) and §7.1 (JSON coverage report). This includes computing metrics.overall, metrics.byDimension, metrics.byOperation, targetsByStatus and thresholds, and emitting targets and uncoveredTargets arrays according to reportMode semantics.\n\n[Key requirements]\n- Implement CoverageEvaluator that consumes CoverageTargets, hit information, coverage options (dimensionsEnabled, excludeUnreachable) and planner diagnostics and produces metrics and report arrays.\n- Compute metrics.overall, metrics.byDimension and metrics.byOperation exactly as defined in the spec, including correct handling of status:'unreachable' and dimensionsEnabled filtering; metrics.byOperation MUST be computed as a projection over all reachable targets per operation whose dimension is enabled.\n- Ensure targets with status:'deprecated' (including diagnostic-only targets such as SCHEMA_REUSED_COVERED) never contribute to metrics.overall, metrics.byDimension, metrics.byOperation or minCoverage enforcement, while still being visible in targets, uncoveredTargets and diagnostics.\n- Represent unreachable targets solely via their status:'unreachable' in targets (and uncoveredTargets when hit:false); there is no dedicated unreachableTargets array in the report, and any unreachable-only view MUST be obtained by filtering on status.\n- Implement report header fields (version, reportMode, engine, run, metrics, thresholds, diagnostics) with deterministic values for a given run and options.\n- Support both full and summary report modes, with clear semantics: full materializes the complete targets[] set for all enabled dimensions, summary may truncate targets[] and uncoveredTargets[] while still computing metrics over the full target universe built by the Analyzer.\n- Expose uncoveredTargets sorted by priority (dimension, weight, type, path) and include unsatisfiedHints and plannerCapsHit diagnostics for guided runs; in reportMode:'full', uncoveredTargets MUST contain all targets with hit:false whose status is either 'active' or 'unreachable'; in reportMode:'summary', uncoveredTargets MAY be truncated while all metrics are still computed over the full target universe built by the Analyzer.\n\n[Deliverables]\n- CoverageEvaluator implementation under packages/core/src/coverage/coverage-evaluator.ts.\n- CoverageReport type definition under packages/shared/src/types/coverage-report.ts.\n- Integration in the pipeline result and Node API to return a CoverageReport Promise alongside the data stream.\n\n[Definition of Done]\n- CoverageEvaluator computes metrics that match hand-calculated expectations on small fixtures for all dimensions, including operations when available once task 9310 is implemented.\n- coverage-report/v1 JSON structure matches the spec, including reportMode semantics, dimensionsEnabled and excludeUnreachable behavior (denominators only, IDs and statuses unchanged), thresholds wiring for overall coverage only, and unreachable targets discoverable solely via status:'unreachable' in targets/uncoveredTargets.\n- Diagnostic-only targets such as SCHEMA_REUSED_COVERED are present in targets[] and diagnostics but are excluded from all coverage metrics and thresholds via status:'deprecated'.\n- Coverage reports are deterministic across repeated runs for the same (schema, options, seed, AJV major, registryFingerprint).\n- Uncovered targets list and targetsByStatus counters are consistent and validated in tests.\n- Node API and CLI can emit a valid coverage-report/v1 JSON file for coverage=measure and coverage=guided runs.",
        "testStrategy": "Unit tests for CoverageEvaluator that feed synthetic CoverageTargets and hit bitmaps and assert metrics and report arrays; tests that exercise excludeUnreachable true/false and confirm denominators change while targetsByStatus stays consistent and unreachable targets are discoverable by filtering status:'unreachable' from targets/uncoveredTargets; tests toggling dimensionsEnabled to ensure IDs for common targets remain stable and metrics are computed only over enabled dimensions; tests that include SCHEMA_REUSED_COVERED targets with status:'deprecated' and verify they never affect metrics.overall, metrics.byDimension or metrics.byOperation; golden JSON fixtures for coverage-report/v1 to catch regressions; integration tests that run the pipeline end-to-end on small schemas and OpenAPI specs (once 9310 is present) and compare the resulting coverage report with expected metrics and unreachable views derived from status; include a pre-9310 scenario where metrics.byOperation is empty while other metrics are still computed correctly, to document intermediate behavior before operation-level coverage is available.",
        "subtasks": [
          {
            "id": 9303001,
            "title": "Define CoverageReport types and thresholds structure",
            "description": "Create TypeScript definitions for CoverageReport, PlannerCapHit and UnsatisfiedHintReasonCode matching the spec.",
            "status": "done",
            "estimatedHours": 3,
            "file": "packages/shared/src/types/coverage-report.ts",
            "parentId": "9303",
            "updatedAt": "2025-11-28T19:16:38.971Z"
          },
          {
            "id": 9303002,
            "title": "Implement CoverageEvaluator metrics aggregation",
            "description": "Compute metrics.overall, metrics.byDimension, metrics.byOperation, targetsByStatus, thresholds and uncoveredTargets from CoverageTargets and hit data, respecting dimensionsEnabled, excludeUnreachable (denominators-only) and diagnostic-only targets; uncoveredTargets must include all targets with hit:false whose status is either 'active' or 'unreachable', and unreachable targets must be represented via status:'unreachable' in targets (and uncoveredTargets when hit:false) rather than a dedicated unreachableTargets array, so unreachable-only views are obtained by filtering on status.",
            "status": "done",
            "estimatedHours": 4,
            "file": "packages/core/src/coverage/coverage-evaluator.ts",
            "parentId": "9303",
            "updatedAt": "2025-11-28T19:35:32.090Z"
          },
          {
            "id": 9303003,
            "title": "Implement reportMode full vs summary behavior",
            "description": "Add logic to include or truncate targets and uncoveredTargets arrays depending on reportMode while keeping metrics exact over the full target universe.",
            "status": "done",
            "estimatedHours": 2,
            "file": "packages/core/src/coverage/coverage-evaluator.ts",
            "parentId": "9303",
            "updatedAt": "2025-11-29T15:08:47.393Z"
          },
          {
            "id": 9303004,
            "title": "Wire CoverageEvaluator into pipeline result and Node API",
            "description": "Attach coverage report computation to the pipeline orchestrator and expose it as a Promise alongside the data stream.",
            "status": "done",
            "estimatedHours": 3,
            "file": "packages/core/src/pipeline/orchestrator.ts",
            "parentId": "9303",
            "updatedAt": "2025-11-28T20:07:26.512Z"
          },
          {
            "id": 9303005,
            "title": "Add snapshot tests for coverage-report/v1 JSON",
            "description": "Create snapshot tests that generate coverage reports on sample schemas and assert stable JSON shape and values, including dimensionsEnabled and targetsByStatus.",
            "status": "done",
            "estimatedHours": 2,
            "file": "packages/core/test/e2e/coverage-report.spec.ts",
            "parentId": "9303",
            "updatedAt": "2025-11-28T20:15:31.394Z"
          }
        ],
        "updatedAt": "2025-11-29T15:08:47.393Z"
      },
      {
        "id": 9304,
        "title": "Add CLI coverage modes, options and CI-friendly summary",
        "description": "Expose coverage=off|measure|guided, dimensions, thresholds and report path via CLI flags and print a human-readable coverage summary for CI logs.",
        "priority": "high",
        "estimatedHours": 12,
        "dependencies": [
          "9301",
          "9302",
          "9303"
        ],
        "status": "done",
        "complexityScore": 3,
        "details": "[Context]\nExtend the CLI to configure coverage-aware behavior and surface summary metrics, per coverage-aware spec §6 (Execution modes & UX) and §7.2 (CLI summary). The CLI must support coverage modes, dimensions, thresholds, report path, excludeUnreachable and profiles, and output a clear summary for CI that emphasizes per-dimension and per-operation coverage before the global overall figure.\n\n[Key requirements]\n- Implement CLI flags: --coverage=off|measure|guided, --coverage-dimensions, --coverage-min, --coverage-report, --coverage-profile and --coverage-exclude-unreachable; map them to internal options and CoverageReport.run fields.\n- Ensure --n (or --count) is reused as maxInstances for coverage=guided and is passed to the planner and evaluator.\n- Implement CI-friendly summary output that prints metrics.byDimension, metrics.byOperation, metrics.overall, targetsByStatus and a short summary of planner caps and unsatisfied hints, in that order of importance.\n- Ensure coverage=off behaves exactly as today with minimal overhead, and coverage=measure does not change outputs relative to coverage=off for fixed seeds; pipeline wiring must not invoke CoverageAnalyzer or coverage instrumentation when coverage=off.\n- Implement coverage profiles as presets over maxInstances, dimensionsEnabled and planner caps:\n  - quick: dimensionsEnabled = ['structure','branches'], small maxInstances (order of 50–100) and aggressive caps per dimension/schema/operation.\n  - balanced (default): dimensionsEnabled = ['structure','branches','enum'], moderate maxInstances (order of 200–500) and moderate caps favoring branches and enums.\n  - thorough: dimensionsEnabled = ['structure','branches','enum','boundaries'] once the boundaries dimension is available, maxInstances >= 1000 and planner caps disabled except for hard global constraints (e.g. global memory/time limits).\n- Ensure any future debug/introspection CLI option that materializes additional targets beyond dimensionsEnabled is explicit opt-in and does not change metric or threshold semantics: coverage.overall, coverage.byDimension, coverage.byOperation and minCoverage MUST always be computed solely from dimensions listed in dimensionsEnabled.\n- Document coverage options and profiles in CLI help text and examples to match the spec’s suggested usage and default behavior.\n\n[Deliverables]\n- Extended CLI option parsing in packages/cli/src/commands/generate.ts and openapi.ts.\n- Summary printer in packages/cli/src/coverage/coverage-summary.ts.\n- Updated --help output and docs snippets for coverage usage.\n\n[Definition of Done]\n- CLI accepts coverage flags and forwards them to the core pipeline and coverage evaluator consistently for JSON Schema and OpenAPI entrypoints.\n- coverage=off, coverage=measure and coverage=guided modes can be invoked via CLI and map to the engine’s coverageMode field in the report and to whether CoverageAnalyzer/instrumentation are invoked.\n- Profiles quick, balanced and thorough map to well-defined presets for maxInstances, dimensionsEnabled and planner caps, and tests verify that selecting a profile results in the expected internal configuration.\n- Summary output for a representative run includes per-dimension and per-operation coverage, overall coverage, targetsByStatus and concise planner/hints summaries, with per-dimension and per-operation displayed before the overall figure.\n- CLI examples in README or dedicated docs show typical coverage usage patterns and are kept in sync with the implemented flags and profiles.",
        "testStrategy": "CLI integration tests that run foundrydata generate and foundrydata openapi with different coverage flags and assert exit codes, coverage summary output and generated coverage-report JSON; tests that verify coverage=off does not trigger CoverageAnalyzer or coverage instrumentation; snapshot tests for the summary formatter to ensure ordering (byDimension, byOperation, overall) remains stable; tests that run the CLI with --coverage-profile=quick|balanced|thorough and assert that the resulting dimensionsEnabled, maxInstances and caps match the documented presets.",
        "subtasks": [
          {
            "id": 9304001,
            "title": "Add coverage flags to generate and openapi commands",
            "description": "Extend CLI argument parsing to accept coverage mode, dimensions, minCoverage, report path, profile and excludeUnreachable options.",
            "status": "done",
            "estimatedHours": 3,
            "file": "packages/cli/src/commands/generate.ts",
            "parentId": "9304",
            "updatedAt": "2025-11-28T21:04:06.170Z"
          },
          {
            "id": 9304002,
            "title": "Map CLI coverage options to core pipeline configuration",
            "description": "Translate CLI flags into the coverage configuration passed to the pipeline orchestrator and coverage evaluator, ensuring coverage=off fully skips CoverageAnalyzer and coverage instrumentation, that coverage-report and minCoverage-related options are ignored (with a clear warning or note) when coverage=off, and that unknown or not-yet-implemented dimensions in --coverage-dimensions are handled deterministically (either rejected with a clear error or dropped with a diagnostic note).",
            "status": "done",
            "estimatedHours": 3,
            "file": "packages/cli/src/config/coverage-options.ts",
            "parentId": "9304",
            "updatedAt": "2025-11-28T21:04:14.482Z"
          },
          {
            "id": 9304003,
            "title": "Implement coverage summary printer for CI logs",
            "description": "Format metrics.byDimension, metrics.byOperation, metrics.overall, targetsByStatus and diagnostics into a concise CLI summary, with per-dimension and per-operation metrics emphasized before overall.",
            "status": "done",
            "estimatedHours": 3,
            "file": "packages/cli/src/coverage/coverage-summary.ts",
            "parentId": "9304",
            "updatedAt": "2025-11-28T21:09:13.627Z"
          },
          {
            "id": 9304004,
            "title": "Add CLI tests for coverage modes and thresholds",
            "description": "Create tests that run the CLI with different coverage modes, profiles and minCoverage values and assert exit codes and summaries, including edge cases such as coverage=off combined with coverage-report/minCoverage flags and unknown dimensions in --coverage-dimensions.",
            "status": "done",
            "estimatedHours": 3,
            "file": "packages/cli/test/coverage-cli.spec.ts",
            "parentId": "9304",
            "updatedAt": "2025-11-28T21:18:32.651Z"
          },
          {
            "id": 9304005,
            "title": "Write coverage-report JSON file to disk",
            "description": "Persist coverage-report/v1 JSON to the path specified by --coverage-report for coverage=measure|guided runs.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 9304,
            "updatedAt": "2025-11-28T21:28:04.610Z",
            "parentId": "undefined"
          },
          {
            "id": 9304006,
            "title": "Enforce coverage profile presets",
            "description": "Extend coverage profile handling so quick/balanced/thorough set dimensionsEnabled, recommended maxInstances and planner caps as per cov://§6#budget-profiles, and document the presets in the CLI help.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 9304,
            "updatedAt": "2025-11-29T15:20:46.542Z",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-11-29T15:20:46.542Z"
      },
      {
        "id": 9305,
        "title": "Implement static CoveragePlanner for guided coverage (M1)",
        "description": "Create a greedy, deterministic CoveragePlanner that proposes TestUnits with hints and respects maxInstances and planner caps.",
        "priority": "high",
        "estimatedHours": 16,
        "dependencies": [
          "9301",
          "9302",
          "9303",
          "9307"
        ],
        "status": "done",
        "complexityScore": 5,
        "details": "[Context]\nImplement the CoveragePlanner stage for coverage=guided, as specified in §4.2 (CoveragePlanner) and §6.2 (Budget & profiles). The planner consumes CoverageGraph and targets and produces a deterministic sequence of TestUnits with derived seeds, planned instance counts and per-unit hints, under an overall maxInstances budget and optional caps.\n\n[Key requirements]\n- Implement a static, greedy planner that builds all TestUnits up front from the initial CoverageTarget set, without adaptive feedback during the run.\n- Prioritize targets by scope (operations first when present), dimension (branches → enum → structure → boundaries) and then by weight and canonical path, with stable sorting rules.\n- Respect maxInstances as an upper bound, allowing early stop when all active targets are covered or when only unreachable or capped targets remain.\n- Implement deterministic caps per dimension/schema/operation and surface them via diagnostics.plannerCapsHit and meta.planned:false on unplanned targets.\n- Generate TestUnit seeds deterministically from a masterSeed and stable derivation rules so that runs are reproducible across executions.\n\n[Deliverables]\n- CoveragePlanner implementation under packages/core/src/coverage/coverage-planner.ts.\n- Planner diagnostics and meta fields wiring into CoverageTargets and CoverageReport.diagnostics.plannerCapsHit.\n- Integration in the pipeline orchestrator for coverage=guided mode, including mapping CLI --n and profiles to maxInstances and caps.\n\n[Commands]\n- npm run build\n- npm run test -- --runInBand\n- npm run test packages/core/src/coverage/__tests__/coverage-planner.spec.ts\n\n[Definition of Done]\n- For small schemas, planner produces TestUnits that exercise all active branch and enum targets within the budget, matching acceptance scenarios for oneOf and enums.\n- Planner respects maxInstances as a hard upper bound and may stop earlier once coverage objectives are satisfied.\n- Planner caps behavior (when large target sets are present) is deterministic and fully surfaced in plannerCapsHit and meta.planned:false on unplanned targets.\n- Seeds and TestUnit ordering are stable across runs for the same inputs and options.\n- Integration tests show that coverage=guided improves coverage.byDimension for branches and enums compared to coverage=measure under the same maxInstances.",
        "testStrategy": "Unit tests for planner prioritization and caps, using synthetic CoverageTargets to verify TestUnit sequences and meta.planned flags; property-based tests for seed derivation and determinism; integration tests that run coverage=guided on sample schemas and assert that branch and enum coverage reach 100% when budget permits, matching acceptance criteria; tests that compare planned vs unplanned targets when caps are hit.",
        "subtasks": [
          {
            "id": 9305001,
            "title": "Design TestUnit structure and planner inputs",
            "description": "Define TestUnit type and planner configuration (maxInstances, dimensions, priorities, caps) and integrate with CoverageGraph and CoverageTargets.",
            "status": "done",
            "estimatedHours": 3,
            "file": "packages/core/src/coverage/coverage-planner.ts",
            "parentId": "9305",
            "updatedAt": "2025-11-28T23:40:00.002Z"
          },
          {
            "id": 9305002,
            "title": "Implement greedy prioritization and budget handling",
            "description": "Implement the greedy selection algorithm over targets, enforcing prioritization rules and maxInstances constraints.",
            "status": "done",
            "estimatedHours": 4,
            "file": "packages/core/src/coverage/coverage-planner.ts",
            "parentId": "9305",
            "updatedAt": "2025-11-28T23:46:27.776Z"
          },
          {
            "id": 9305003,
            "title": "Implement planner caps and diagnostics",
            "description": "Add deterministic caps per dimension/schema/operation and report them via diagnostics.plannerCapsHit and meta.planned:false.",
            "status": "done",
            "estimatedHours": 3,
            "file": "packages/core/src/coverage/coverage-planner-caps.ts",
            "parentId": "9305",
            "updatedAt": "2025-11-28T23:53:13.809Z"
          },
          {
            "id": 9305004,
            "title": "Derive deterministic seeds for TestUnits",
            "description": "Implement masterSeed derivation into per-TestUnit seeds and add tests for reproducibility across runs.",
            "status": "done",
            "estimatedHours": 3,
            "file": "packages/core/src/coverage/seed-planner.ts",
            "parentId": "9305",
            "updatedAt": "2025-11-28T23:57:18.596Z"
          },
          {
            "id": 9305005,
            "title": "Add integration tests for coverage=guided planning behavior",
            "description": "Run the full pipeline on acceptance schemas to confirm planner helps hit all oneOf branches and enum values with sufficient budget.",
            "status": "done",
            "estimatedHours": 3,
            "file": "packages/core/test/e2e/coverage-guided-planner.spec.ts",
            "parentId": "9305",
            "updatedAt": "2025-11-29T00:05:04.858Z"
          }
        ],
        "updatedAt": "2025-11-29T00:05:04.858Z"
      },
      {
        "id": 9306,
        "title": "Wire coverage hints into generator with conflict resolution and unsatisfied hints",
        "description": "Implement preferBranch, ensurePropertyPresence and coverEnumValue hints in the generator and record unsatisfied hints and reasons.",
        "priority": "high",
        "estimatedHours": 14,
        "dependencies": [
          "9302",
          "9305",
          "9307"
        ],
        "status": "done",
        "complexityScore": 4,
        "details": "[Context]\nImplement coverage hints and their interaction with the generator and Repair, as described in §5 (Hints & interaction with Repair). coverage=guided uses hints attached to TestUnits to steer branch choices, property presence and enum values while preserving AJV validity and determinism, and records unsatisfied hints when constraints prevent their satisfaction.\n\n[Key requirements]\n- Implement hint types preferBranch(schemaPath, branchIndex), ensurePropertyPresence(schemaPath, property, present) and coverEnumValue(schemaPath, valueIndex) and attach them to TestUnits from the planner.\n- Extend the generator to consume hints in coverage=guided mode only, with AJV validity taking precedence and default heuristics used when hints are absent, inapplicable or unsatisfiable.\n- Implement deterministic conflict resolution with a global priority order (coverEnumValue > preferBranch > ensurePropertyPresence) and stable ordering within each kind (first in hints[] wins).\n- Detect unsatisfied hints when Repair modifies values or when constraints make the hinted target unreachable, and record them as unsatisfiedHints with reasonCode and reasonDetail in the coverage report.\n- Ensure hints have no effect in coverage=off and coverage=measure modes and do not alter external driver behavior.\n\n[Deliverables]\n- Hint definitions and helper utilities in packages/core/src/coverage/hints.ts.\n- Generator integration for hint consumption in packages/core/src/generator/foundry-generator.ts.\n- UnsatisfiedHints collection and wiring into CoverageEvaluator and CoverageReport.unsatisfiedHints.\n\n[Commands]\n- npm run build\n- npm run test -- --runInBand\n- npm run test packages/core/src/generator/__tests__/coverage-hints.spec.ts\n\n[Definition of Done]\n- Generator respects hints in coverage=guided mode while still emitting only AJV-valid instances; invalid instances caused by hints are rejected and hints are marked unsatisfied.\n- Conflict resolution across multiple hints for the same node is deterministic and covered by unit tests.\n- Unsatisfied hints are reported with appropriate reasonCode values such as UNREACHABLE_BRANCH, REPAIR_MODIFIED_VALUE or PLANNER_CAP, and are visible in coverage reports without affecting coverageStatus in V1.\n- Runs with coverage=off or coverage=measure show no behavioral difference compared to pre-hints behavior.\n- Acceptance scenarios for oneOf branches and enum coverage are supported by guided runs that use hints to reach full coverage under sufficient budget.",
        "testStrategy": "Focused unit tests that drive the generator with individual hints and conflicting hints and assert chosen branches, properties and enum values; tests that exercise Repair interactions to produce unsatisfied hints; integration tests in coverage=guided mode verifying that hints improve coverage and that unsatisfiedHints are recorded when constraints make hints impossible to satisfy.",
        "subtasks": [
          {
            "id": 9306001,
            "title": "Define hint types and priority rules",
            "description": "Implement Hint interfaces and establish global priority and conflict resolution rules for different hint kinds.",
            "status": "done",
            "estimatedHours": 3,
            "file": "packages/core/src/coverage/hints.ts",
            "parentId": "9306",
            "updatedAt": "2025-11-29T00:38:34.487Z"
          },
          {
            "id": 9306002,
            "title": "Integrate hints into generator decision points",
            "description": "Consume hints in the generator when selecting branches, deciding property presence and picking enum values in coverage=guided mode, without changing AP:false name semantics or CoverageIndex behavior (property-name coverage still comes solely from CoverageIndex).",
            "status": "done",
            "estimatedHours": 4,
            "file": "packages/core/src/generator/foundry-generator.ts",
            "parentId": "9306",
            "updatedAt": "2025-11-29T00:51:17.747Z"
          },
          {
            "id": 9306003,
            "title": "Record unsatisfied hints from generator and repair",
            "description": "Detect when hints cannot be satisfied or are undone by Repair and record UnsatisfiedHint entries with reason codes.",
            "status": "done",
            "estimatedHours": 3,
            "file": "packages/core/src/coverage/unsatisfied-hints.ts",
            "parentId": "9306",
            "updatedAt": "2025-11-29T00:59:52.070Z"
          },
          {
            "id": 9306004,
            "title": "Add tests for hint precedence and determinism",
            "description": "Write tests confirming hint precedence order and stable behavior across runs for the same hints.",
            "status": "done",
            "estimatedHours": 2,
            "file": "packages/core/src/generator/__tests__/coverage-hints.spec.ts",
            "parentId": "9306",
            "updatedAt": "2025-11-29T01:03:30.144Z"
          },
          {
            "id": 9306005,
            "title": "Add end-to-end tests for guided hints on schemas with oneOf and enums",
            "description": "Create e2e tests that show full branch and enum coverage under coverage=guided with sufficient budget and visible unsatisfied hints when impossible.",
            "status": "done",
            "estimatedHours": 2,
            "file": "packages/core/test/e2e/coverage-guided-hints.spec.ts",
            "parentId": "9306",
            "updatedAt": "2025-11-29T11:44:40.542Z"
          },
          {
            "id": 9306006,
            "title": "Wire planner hints into pipeline orchestrator and add guided hints e2e tests",
            "description": "Wire CoveragePlanner TestUnit.hints through the pipeline orchestrator into the generator in coverage=guided mode, then add end-to-end tests (via executePipeline) on oneOf+enum schemas to demonstrate that planner-produced hints are actually consumed, improve branches/enum coverage vs coverage=measure under the same budget, and remain deterministic for fixed (schema, options, seed).",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 9306,
            "updatedAt": "2025-11-29T11:39:50.269Z",
            "parentId": "undefined"
          },
          {
            "id": 9306007,
            "title": "Attach ensurePropertyPresence hints for PROPERTY_PRESENT targets in CoveragePlanner",
            "description": "Implement ensurePropertyPresence(schemaPath, property, present:true) hints in the CoveragePlanner based on PROPERTY_PRESENT targets from the Analyzer. Map each PROPERTY_PRESENT target to a hint on the owning object schema node, keeping IDs and ordering of CoverageTargets unchanged and respecting AP:false / CoverageIndex invariants. Add planner-level tests to verify that TestUnits receive ensurePropertyPresence hints consistent with active PROPERTY_PRESENT targets.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 9306,
            "updatedAt": "2025-11-29T11:16:07.088Z",
            "parentId": "undefined"
          },
          {
            "id": 9306008,
            "title": "Collect unsatisfied hints in pipeline and expose coverageReport.unsatisfiedHints",
            "description": "Extend the pipeline orchestrator to collect unsatisfiedHints emitted by the generator (and Repair when applicable), aggregate them at run level, and expose them in artifacts.coverageReport.unsatisfiedHints in accordance with the coverage-aware SPEC (§5.3, §7.1). Ensure unsatisfied hints remain diagnostic-only (no impact on coverageStatus, minCoverage enforcement or CLI exit codes), conform to the UnsatisfiedHint schema (kind, canonPath, params, reasonCode, reasonDetail?), and leave coverage=off and coverage=measure behavior unchanged. Add executePipeline tests that validate the presence of unsatisfiedHints in the coverage report for scenarios where hints cannot be honored, while keeping AJV validity and coverage metrics intact.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 9306,
            "parentId": "undefined",
            "updatedAt": "2025-11-29T11:34:47.437Z"
          },
          {
            "id": 9306009,
            "title": "Implement hint trace and Repair-side unsatisfied hints",
            "description": "Maintain a per-instance hint trace shared between Generate and Repair and emit UnsatisfiedHint entries from Repair with appropriate reasonCode (REPAIR_MODIFIED_VALUE, CONFLICTING_CONSTRAINTS, UNREACHABLE_BRANCH, PLANNER_CAP) when hints are applied, modified or impossible, as per §4.3, §5.3 and §7.1 of the coverage-aware SPEC.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 9306,
            "updatedAt": "2025-11-29T12:34:10.135Z",
            "parentId": "undefined"
          },
          {
            "id": 9306010,
            "title": "Fix ensurePropertyPresence hint trace for reused definitions",
            "description": "Track per-instance paths so ensurePropertyPresence hints coming from reused definitions or merged subschemas record their true container before Repair evaluates the hint.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 9306,
            "updatedAt": "2025-11-29T13:40:15.968Z",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-11-29T13:40:15.968Z"
      },
      {
        "id": 9307,
        "title": "Implement streaming coverage instrumentation with per-instance commit",
        "description": "Upgrade coverage instrumentation to a streaming model that updates coverage as instances flow through Generate, Repair and Validate without a second JSON parse.",
        "priority": "medium",
        "estimatedHours": 12,
        "dependencies": [
          "9302",
          "9303"
        ],
        "status": "done",
        "complexityScore": 4,
        "details": "[Context]\nMove from any temporary post-pass coverage computation to the streaming model required for steady-state V1, per §4.3 (Generator instrumentation) and §8 (Technical constraints & invariants). Coverage must be updated as instances pass through Generate and Repair, with hits committed only after Validate, and total overhead must remain O(#instances + #targets).\n\n[Key requirements]\n- Replace any full post-pass re-parse of generated output with in-memory, streaming coverage instrumentation across Generate, Repair and Validate.\n- Maintain per-instance coverage state that accumulates events, then commit hits to global target bitmaps once Validate accepts the instance.\n- Ensure coverage=guided mode uses the same streaming infrastructure as coverage=measure, with additional hints but no extra parse.\n- Integrate coverage instrumentation metrics into existing per-phase metrics (e.g. generateMs, repairMs, validateMs) to make overhead measurable.\n- Preserve determinism: coverage bitmaps and reports must be identical across runs for fixed inputs and options.\n\n[Deliverables]\n- Streaming coverage accumulator implementation in packages/core/src/coverage/coverage-state.ts.\n- Orchestrator wiring to attach per-instance coverage state and commit hits after validation.\n- Updated metrics plumbing to capture coverage-related overhead.\n\n[Commands]\n- npm run build\n- npm run test -- --runInBand\n- npm run bench\n\n[Definition of Done]\n- No phase performs a second JSON parse of the emitted output solely for coverage; coverage computation is fully streaming.\n- Coverage metrics and reports remain unchanged relative to the M0 implementation on existing tests and fixtures.\n- Overhead is measured via bench scripts and remains within acceptable SLOs given the additional instrumentation.\n- Determinism tests confirm that repeated runs produce identical coverage bitmaps and reports.",
        "testStrategy": "Unit tests for streaming coverage state that simulate per-instance event flows and validate final hit sets; integration tests that run the full pipeline and compare coverage reports before and after the streaming refactor; benchmark runs to assess performance overhead and confirm O(#instances + #targets) behavior; determinism tests that run multiple times and compare coverage reports bit-for-bit.",
        "subtasks": [
          {
            "id": 9307001,
            "title": "Implement per-instance coverage state and bitmap representation",
            "description": "Create structures to capture per-instance events and global bitmaps for CoverageTargets in a streaming fashion.",
            "status": "done",
            "estimatedHours": 3,
            "file": "packages/core/src/coverage/coverage-state.ts",
            "parentId": "9307",
            "updatedAt": "2025-11-28T22:57:47.902Z"
          },
          {
            "id": 9307002,
            "title": "Wire streaming coverage into pipeline phases",
            "description": "Attach coverage state across Generate, Repair and Validate so hits are committed only after successful validation.",
            "status": "done",
            "estimatedHours": 4,
            "file": "packages/core/src/pipeline/orchestrator.ts",
            "parentId": "9307",
            "updatedAt": "2025-11-28T23:08:14.344Z"
          },
          {
            "id": 9307003,
            "title": "Remove any post-pass coverage computation",
            "description": "Eliminate or guard any remaining full post-pass coverage code paths and ensure tests rely only on streaming instrumentation.",
            "status": "done",
            "estimatedHours": 2,
            "file": "packages/core/src/coverage/coverage-postpass-legacy.ts",
            "parentId": "9307",
            "updatedAt": "2025-11-28T23:19:31.525Z"
          },
          {
            "id": 9307004,
            "title": "Benchmark streaming coverage overhead",
            "description": "Use existing bench harnesses to measure the impact of streaming coverage and adjust implementation if needed.",
            "status": "done",
            "estimatedHours": 3,
            "file": "packages/reporter/test/bench.runner.test.ts",
            "parentId": "9307",
            "updatedAt": "2025-11-28T23:24:13.148Z"
          }
        ],
        "updatedAt": "2025-11-28T23:24:13.148Z"
      },
      {
        "id": 9308,
        "title": "Enforce global minCoverage threshold and map to exit codes",
        "description": "Wire metrics.overall to a configurable minCoverage threshold and ensure CLI and Node API expose structured coverageStatus results.",
        "priority": "medium",
        "estimatedHours": 8,
        "dependencies": [
          "9303",
          "9304"
        ],
        "status": "done",
        "complexityScore": 3,
        "details": "[Context]\nImplement enforcement of minCoverage on metrics.overall and connect it to CLI exit codes and Node API status, per §7.3 (Thresholds) and the acceptance criterion on coverage threshold. In V1, only the overall threshold is honored; per-dimension and per-operation thresholds are reserved for future use.\n\n[Key requirements]\n- Add minCoverage configuration to coverage options and propagate it to CoverageEvaluator.\n- Compute metrics.thresholds.overall and metrics.coverageStatus:'ok'|'minCoverageNotMet' based on metrics.overall and minCoverage.\n- Map coverageStatus to a dedicated non-zero CLI exit code when minCoverage is not met, distinct from other error conditions.\n- Ensure Node API returns coverageStatus alongside the CoverageReport so callers can react programmatically.\n- Keep thresholds.byDimension and thresholds.byOperation descriptive only in V1, without affecting behavior.\n\n[Deliverables]\n- Thresholds handling in CoverageEvaluator and coverage-report/v1 metrics.\n- CLI exit code mapping and documentation for coverage failures.\n- Node API shape that exposes coverageStatus and thresholds to callers.\n\n[Commands]\n- npm run build\n- npm run test -- --runInBand\n- npm run test packages/cli/test/coverage-cli.spec.ts -- --runTestsByPath\n\n[Definition of Done]\n- Runs with metrics.overall below minCoverage produce metrics.coverageStatus:'minCoverageNotMet' and the CLI exits with the configured coverage failure code.\n- Acceptance scenario where minCoverage=0.8 and metrics.overall=0.6 is covered by tests that assert exit code and summary content.\n- Node API returns a structured result that includes coverageStatus and thresholds.overall.\n- Adding or omitting per-dimension and per-operation thresholds in metrics does not affect behavior in V1.",
        "testStrategy": "Unit tests in CoverageEvaluator for threshold handling; CLI tests that run with minCoverage set above expected coverage and assert non-zero exit codes and clear summary output; Node API tests that inspect coverageStatus and thresholds in the returned CoverageReport; regression tests to ensure behavior remains unchanged when thresholds.byDimension or thresholds.byOperation are present but not enforced.",
        "subtasks": [
          {
            "id": 9308001,
            "title": "Propagate minCoverage config to CoverageEvaluator",
            "description": "Extend coverage options to include minCoverage and apply it when computing thresholds.overall and coverageStatus.",
            "status": "done",
            "estimatedHours": 3,
            "file": "packages/core/src/coverage/coverage-evaluator.ts",
            "parentId": "9308",
            "updatedAt": "2025-11-29T14:08:45.721Z"
          },
          {
            "id": 9308002,
            "title": "Map coverageStatus to CLI exit codes",
            "description": "Add a dedicated coverage failure exit code in the CLI and wire it to metrics.coverageStatus.",
            "status": "done",
            "estimatedHours": 3,
            "file": "packages/cli/src/coverage/coverage-exit-codes.ts",
            "parentId": "9308",
            "updatedAt": "2025-11-29T14:21:22.115Z"
          },
          {
            "id": 9308003,
            "title": "Test coverage threshold enforcement end-to-end",
            "description": "Create an end-to-end test that runs with minCoverage above achievable coverage and asserts exit code and summary diagnostics.",
            "status": "done",
            "estimatedHours": 2,
            "file": "packages/core/test/e2e/coverage-threshold.spec.ts",
            "parentId": "9308",
            "updatedAt": "2025-11-29T14:29:46.134Z"
          }
        ],
        "updatedAt": "2025-11-29T14:29:46.134Z"
      },
      {
        "id": 9309,
        "title": "Add boundaries coverage dimension and instrumentation (M2)",
        "description": "Extend coverage model, analyzer and instrumentation to track hits for numeric, string and array boundary constraints.",
        "priority": "medium",
        "estimatedHours": 14,
        "dependencies": [
          "9300",
          "9301",
          "9302",
          "9307"
        ],
        "status": "done",
        "complexityScore": 4,
        "details": "[Context]\nImplement the boundaries dimension for M2, covering numeric, string and array bounds as described in §3.3 (Boundaries) and §9 (M2 – Boundaries, OpenAPI & diff). This includes NUMERIC_MIN_HIT, NUMERIC_MAX_HIT, STRING_MIN_LENGTH_HIT, STRING_MAX_LENGTH_HIT, ARRAY_MIN_ITEMS_HIT and ARRAY_MAX_ITEMS_HIT targets and their hit semantics.\n\n[Key requirements]\n- Extend CoverageTarget model and CoverageAnalyzer to identify constraint nodes for numeric, string and array boundaries in the canonical view, and materialize corresponding boundary coverage targets when the dimension is enabled.\n- Implement hit semantics for inclusive and exclusive numeric bounds, including representative values based on existing numeric planning and multipleOf handling; avoid introducing separate numeric optimality logic in the coverage layer.\n- Handle degenerate cases where min==max (or similar for lengths and items) deterministically, either as a single logical boundary or as two co-hit targets.\n- Use existing UNSAT diagnostics and numeric feasibility checks to avoid marking unreachable boundary values as active; unreachable boundaries should be either omitted or flagged status:'unreachable'.\n- Instrument generator and repair to emit boundary coverage events in streaming mode without adding new passes over the data.\n\n[Deliverables]\n- Boundaries dimension extensions in coverage model and analyzer under packages/core/src/coverage/model.ts and coverage-analyzer.ts.\n- Boundary-specific instrumentation in generator and repair to record hits when boundary representatives are emitted.\n- Tests and fixtures for numeric bounds with multipleOf, string length and array length constraints, including unreachable cases.\n\n[Commands]\n- npm run build\n- npm run test -- --runInBand\n- npm run test packages/core/src/coverage/__tests__/boundaries.spec.ts\n\n[Definition of Done]\n- When boundaries dimension is enabled, reports contain boundary targets and coverage.byDimension['boundaries'] metrics consistent with hand-calculated expectations on fixtures.\n- Boundary targets respect reachability rules and do not stay active for values proven to be outside the admissible domain.\n- generator and repair instrumentation uses existing numeric planning rules to choose representative values and does not require special-case numeric logic in the coverage layer.\n- Performance remains acceptable when boundaries are enabled; tests measure the added overhead and ensure it remains bounded.",
        "testStrategy": "Unit tests for boundary target discovery in CoverageAnalyzer; generator-focused tests that emit values exactly at or around bounds and assert boundary hit flags; tests that combine boundaries with multipleOf and verify unreachable cases are marked correctly; integration tests with coverage=guided where boundaries dimension is enabled and coverage.byDimension['boundaries'] behaves as expected.",
        "subtasks": [
          {
            "id": 9309001,
            "title": "Extend coverage model and analyzer for boundaries dimension",
            "description": "Add boundaries dimension kinds and discover boundary constraints in canonical schemas to create coverage targets.",
            "status": "done",
            "estimatedHours": 4,
            "file": "packages/core/src/coverage/coverage-analyzer.ts",
            "parentId": "9309",
            "updatedAt": "2025-11-29T18:21:06.887Z"
          },
          {
            "id": 9309002,
            "title": "Instrument generator for numeric and length boundary hits",
            "description": "Emit coverage events when numeric values, string lengths and array lengths hit boundary representatives.",
            "status": "done",
            "estimatedHours": 4,
            "file": "packages/core/src/generator/foundry-generator.ts",
            "parentId": "9309",
            "updatedAt": "2025-11-29T18:37:13.813Z"
          },
          {
            "id": 9309003,
            "title": "Handle unreachable or degenerate boundary targets",
            "description": "Use existing UNSAT diagnostics and numeric feasibility checks to mark unreachable boundaries appropriately.",
            "status": "done",
            "estimatedHours": 3,
            "file": "packages/core/src/coverage/coverage-analyzer-unreachable.ts",
            "parentId": "9309",
            "updatedAt": "2025-11-29T18:42:04.281Z"
          },
          {
            "id": 9309004,
            "title": "Add tests for boundary coverage semantics",
            "description": "Create fixtures and tests that validate inclusive vs exclusive, min==max and multipleOf interactions for boundary coverage, including cases where a boundary-hitting value that passes AJV remains unchanged by Repair unless another constraint requires a different value so boundary hits are not lost unnecessarily.",
            "status": "done",
            "estimatedHours": 3,
            "file": "packages/core/src/coverage/__tests__/boundaries.spec.ts",
            "parentId": "9309",
            "updatedAt": "2025-11-29T18:47:46.271Z"
          }
        ],
        "updatedAt": "2025-11-29T18:47:46.271Z"
      },
      {
        "id": 9310,
        "title": "Implement OpenAPI per-operation coverage and byOperation metrics (M2)",
        "description": "Track coverage per OpenAPI operation, including OP_REQUEST_COVERED, OP_RESPONSE_COVERED, SCHEMA_REUSED_COVERED and coverage.byOperation ratios.",
        "priority": "medium",
        "estimatedHours": 16,
        "dependencies": [
          "9301",
          "9302",
          "9303",
          "9305"
        ],
        "status": "done",
        "complexityScore": 4,
        "details": "[Context]\nExtend coverage-aware behavior to OpenAPI operations for M2, per §3.3 (Inter-schema / API coverage), §3.5 (Metrics & semantics) and §9 (M2 – Boundaries, OpenAPI & diff). The system must compute per-operation coverage metrics and define OP_REQUEST_COVERED, OP_RESPONSE_COVERED and SCHEMA_REUSED_COVERED targets based on deterministic schema selection rules.\n\n[Key requirements]\n- Extend CoverageAnalyzer with an OpenAPI-aware layer to build OperationNode entries and attach schema nodes for request and response payloads, with operationKey defined as operationId or <METHOD> <path> when operationId is absent. This layer builds on the schema-level CoverageGraph produced by task 9301 without changing existing target IDs.\n- Treat operation-level targets (OP_REQUEST_COVERED, OP_RESPONSE_COVERED, SCHEMA_REUSED_COVERED) as belonging to the 'operations' coverage dimension and only materialize them when 'operations' is present in run.dimensionsEnabled; when 'operations' is absent, the analyzer may still build internal operation mappings but MUST NOT emit operation-level CoverageTargets in targets[] for standard modes.\n- Implement OP_REQUEST_COVERED and OP_RESPONSE_COVERED targets per operationKey in the 'operations' coverage dimension and map schema-level targets (structure, branches, enum, boundaries) reachable from each operation to that operation for coverage.byOperation computation.\n- Implement SCHEMA_REUSED_COVERED as a diagnostic-only target kind for canonical schemas reused across multiple operations; these targets must be emitted and visible in targets/uncoveredTargets and diagnostics with status:'deprecated' but excluded from metrics.overall, metrics.byDimension, metrics.byOperation and minCoverage.\n- Implement deterministic request/response schema selection for JSON media types in line with the spec (lexicographic media type order, preference for 200 and 2xx JSON responses).\n- Populate run.operationsScope and run.selectedOperations in the coverage report when only a subset of operations is targeted, and ensure only in-scope operations contribute to coverage.byOperation and activeTargetsTotal; metrics.byOperation and selectedOperations must always be interpreted within the declared operationsScope.\n- Integrate coverage.byOperation into CLI summary output (task 9304), highlighting least-covered operations in a deterministic order.\n\n[Deliverables]\n- Operation-aware target generation in CoverageAnalyzer under packages/core/src/coverage/coverage-analyzer-openapi.ts.\n- Mapping logic from schema targets to operations for coverage.byOperation metrics in CoverageEvaluator.\n- CLI support for operation selection flags (if not already present) that set operationsScope and selectedOperations in the report.\n\n[Definition of Done]\n- For an OpenAPI fixture with multiple operations (with and without operationId), coverage reports include coverage.byOperation[operationKey] entries with expected ratios.\n- OP_REQUEST_COVERED and OP_RESPONSE_COVERED targets behave as specified, and schema-level targets reachable from each operation are correctly attributed without changing schema-level IDs defined by 9301.\n- SCHEMA_REUSED_COVERED targets are emitted for schemas used in more than one operation, are hit when those schemas are instantiated at least once, and are clearly diagnostic-only so that metrics and thresholds are unaffected via status:'deprecated' in the 'operations' dimension.\n- operationsScope and selectedOperations fields behave as specified when running against a subset of operations, and toggling operationsScope or selectedOperations never changes schema-level CoverageTarget.id values.\n- CLI summary shows per-operation coverage and highlights the least-covered operations in a deterministic order.",
        "testStrategy": "Unit tests for operation selection and target construction using small OpenAPI specs with multiple operations and content types; evaluator tests for coverage.byOperation mapping and ratios honoring dimensionsEnabled; tests confirming SCHEMA_REUSED_COVERED targets are emitted with status:'deprecated', remain visible in targets/uncoveredTargets and do not affect metrics.overall, metrics.byDimension or metrics.byOperation; tests that run coverage on an OpenAPI fixture with 'operations' present and absent in dimensionsEnabled and assert that schema-level CoverageTarget.id values remain unchanged while OP_* targets are only present and counted when 'operations' is enabled; CLI integration tests that generate coverage for selected operations and assert operationsScope, selectedOperations and byOperation metrics in the JSON report and summary output.",
        "subtasks": [
          {
            "id": 9310001,
            "title": "Build OperationNode mapping and operationKey derivation",
            "description": "Extend CoverageAnalyzer with OpenAPI-specific logic to create OperationNodes and derive operationKey from operationId or HTTP method and path.",
            "status": "done",
            "estimatedHours": 4,
            "file": "packages/core/src/coverage/coverage-analyzer-openapi.ts",
            "parentId": "9310",
            "updatedAt": "2025-11-30T01:04:11.633Z"
          },
          {
            "id": 9310002,
            "title": "Implement OP_REQUEST_COVERED, OP_RESPONSE_COVERED and SCHEMA_REUSED_COVERED targets",
            "description": "Create operation-level coverage targets for request and response schemas and diagnostic-only SCHEMA_REUSED_COVERED targets for schemas reused across operations, and mark hits when at least one payload is generated.",
            "status": "done",
            "estimatedHours": 4,
            "file": "packages/core/src/coverage/coverage-analyzer-openapi.ts",
            "parentId": "9310",
            "updatedAt": "2025-11-30T01:14:05.155Z"
          },
          {
            "id": 9310003,
            "title": "Map schema targets to operations for coverage.byOperation",
            "description": "Implement deterministic mapping from schema-level targets to operation keys and compute coverage.byOperation ratios, without changing schema-level CoverageTarget.id values.",
            "status": "done",
            "estimatedHours": 4,
            "file": "packages/core/src/coverage/coverage-evaluator.ts",
            "parentId": "9310",
            "updatedAt": "2025-11-30T01:24:05.474Z"
          },
          {
            "id": 9310004,
            "title": "Add tests and fixtures for OpenAPI coverage behavior",
            "description": "Write tests on OpenAPI fixtures that validate per-operation metrics, operationKey shapes, operationsScope semantics and SCHEMA_REUSED_COVERED diagnostics.",
            "status": "done",
            "estimatedHours": 4,
            "file": "packages/core/src/coverage/__tests__/openapi-coverage.spec.ts",
            "parentId": "9310",
            "updatedAt": "2025-11-30T01:33:01.178Z"
          }
        ],
        "updatedAt": "2025-11-30T01:33:01.178Z"
      },
      {
        "id": 9311,
        "title": "Add coverage diff tool for multi-run comparison (M2)",
        "description": "Provide a coverage diff command that compares two coverage-report/v1 files and highlights regressions, added and removed targets.",
        "priority": "medium",
        "estimatedHours": 10,
        "dependencies": [
          "9303"
        ],
        "status": "done",
        "complexityScore": 3,
        "details": "[Context]\nImplement a coverage diff tool as described in §7.4 (Multi-run diff). The tool compares two coverage-report/v1 JSON files produced by compatible engine majors and report versions and surfaces changes in metrics and target statuses, suitable for CI regression checks.\n\n[Key requirements]\n- Implement a diff algorithm that classifies targets into unchanged, added, removed and statusChanged, based on id and identifying shape (dimension, kind, canonPath).\n- Compute and present deltas for metrics.overall and metrics.byOperation between the two reports, highlighting regressions; metric deltas must be computed over the common universe of targets and dimensions (targets present in both reports and dimensions enabled on both sides), while targets from newly enabled dimensions are treated as added and reported explicitly.\n- Identify newly uncovered targets (present in the newer report and uncovered, or that transitioned from hit:true to hit:false) and present them explicitly rather than folding into aggregate regressions.\n- Ensure diff is only considered valid when both reports share the same coverage-report version and compatible FoundryData major (and, for byOperation deltas, a compatible operationsScope); otherwise surface a clear error.\n- Provide a CLI entrypoint (e.g. foundrydata coverage diff A.json B.json) that prints a textual summary and can return a non-zero exit code on regressions if desired.\n\n[Deliverables]\n- Diff implementation in packages/reporter/src/coverage/coverage-diff.ts.\n- CLI command wiring in packages/cli/src/commands/coverage-diff.ts.\n- Tests and JSON fixtures for typical diff scenarios, including added/removed targets and status changes.\n\n[Commands]\n- npm run build\n- npm run test -- --runInBand\n- npm run test packages/reporter/src/coverage/__tests__/coverage-diff.spec.ts\n\n[Definition of Done]\n- coverage diff command correctly identifies target categories and metric deltas on synthetic and real coverage reports.\n- Incompatible versions, engine majors or irreconcilable operationsScope differences are rejected with clear diagnostics, and diff does not attempt to compare incompatible reports.\n- CLI output includes a concise summary of metrics.overall delta, per-operation regressions and lists of newly uncovered targets.\n- Tests cover edge cases such as empty reports, operations added or removed, dimensions newly enabled or disabled and targets changing status to or from unreachable.",
        "testStrategy": "Unit tests for coverage diff classification using small synthetic reports; integration tests that run coverage twice on modified schemas and then call the diff command to validate reported deltas; tests for error handling when versions or engine majors are incompatible; snapshot tests for the CLI diff summary output.",
        "subtasks": [
          {
            "id": 9311001,
            "title": "Implement CoverageReport diff classification logic",
            "description": "Compare two CoverageReports and classify targets as unchanged, added, removed or statusChanged, including hit changes.",
            "status": "done",
            "estimatedHours": 4,
            "file": "packages/reporter/src/coverage/coverage-diff.ts",
            "parentId": "9311",
            "updatedAt": "2025-11-28T21:49:38.216Z"
          },
          {
            "id": 9311002,
            "title": "Compute metric deltas and regressions",
            "description": "Compute changes in metrics.overall and metrics.byOperation over targets present in both reports (unchanged + statusChanged) and expose them in a diff summary structure, reporting newly added uncovered targets separately as new gaps.",
            "status": "done",
            "estimatedHours": 2,
            "file": "packages/reporter/src/coverage/coverage-diff.ts",
            "parentId": "9311",
            "updatedAt": "2025-11-28T22:10:00.135Z"
          },
          {
            "id": 9311003,
            "title": "Add CLI command for foundrydata coverage diff",
            "description": "Add a CLI command that reads two JSON coverage reports, runs the diff and prints a human-readable summary.",
            "status": "done",
            "estimatedHours": 2,
            "file": "packages/cli/src/commands/coverage-diff.ts",
            "parentId": "9311",
            "updatedAt": "2025-11-28T22:33:04.216Z"
          },
          {
            "id": 9311004,
            "title": "Add fixtures and tests for coverage diff behavior",
            "description": "Create JSON fixtures and tests for typical diff scenarios, including regressions and added/removed targets.",
            "status": "done",
            "estimatedHours": 2,
            "file": "packages/reporter/src/coverage/__tests__/coverage-diff.spec.ts",
            "parentId": "9311",
            "updatedAt": "2025-11-28T22:39:39.668Z"
          }
        ],
        "updatedAt": "2025-11-28T22:39:39.668Z"
      },
      {
        "id": 9312,
        "title": "Validate coverage invariants, determinism and acceptance scenarios",
        "description": "Add cross-cutting tests and documentation that ensure coverage-aware behavior respects core invariants and satisfies all acceptance criteria.",
        "priority": "medium",
        "estimatedHours": 12,
        "dependencies": [
          "9302",
          "9303",
          "9304",
          "9305",
          "9306",
          "9307",
          "9308",
          "9309",
          "9310"
        ],
        "status": "done",
        "complexityScore": 4,
        "details": "[Context]\nConsolidate cross-cutting coverage tests and docs to ensure the coverage layer respects the core pipeline invariants and satisfies the acceptance criteria listed in §10 (Acceptance criteria) and constraints in §8 (Technical constraints & invariants). This includes determinism, AJV-as-oracle behavior, no network I/O in coverage stages and compatibility with CoverageIndex under AP:false.\n\n[Key requirements]\n- Add end-to-end tests for each acceptance scenario: oneOf branches, optional properties, enums, coverage threshold, OpenAPI coverage and reproducibility of coverage reports for identical inputs.\n- Verify that coverage-aware pipeline runs preserve AJV-as-oracle behavior: final validation still uses the original schema and coverage logic never re-parses or re-interprets JSON Schema semantics independently.\n- Confirm deterministic behavior: for fixed (canonical schema, OpenAPI spec, coverage options, seed, AJV major, registryFingerprint), CoverageGraph, TestUnits, generated instances and coverage reports are identical across runs.\n- Ensure coverage stages do not introduce network I/O and remain compatible with existing external $ref resolver behavior and CoverageIndex invariants under AP:false.\n- Document coverage invariants and known limitations in docs to align with existing architecture and known-limits documents.\n\n[Deliverables]\n- Acceptance-focused e2e test suite in packages/core/test/e2e/coverage-acceptance.spec.ts.\n- Determinism tests and tooling to compare coverage reports across multiple runs.\n- Documentation updates in docs/spec-coverage-aware-v1.x and high-level README/Architecture notes.\n\n[Commands]\n- npm run build\n- npm run test -- --runInBand\n- npm run test packages/core/test/e2e/coverage-acceptance.spec.ts\n\n[Definition of Done]\n- All acceptance scenarios from the spec are covered by automated tests that assert expected coverage metrics, exit codes and report content.\n- Reproducibility tests confirm that repeated runs produce byte-identical coverage reports except for allowed timestamp fields.\n- Additional tests confirm there is no network I/O in coverage stages and that CoverageIndex semantics under AP:false are preserved.\n- Documentation for coverage invariants, determinism and limitations is merged and aligned with existing architecture and invariants docs.",
        "testStrategy": "End-to-end Vitest suites exercising coverage-aware runs over small JSON Schema and OpenAPI fixtures, asserting each acceptance criterion; determinism tests that run the same configuration multiple times and compare normalized coverage reports; tests that instrument or mock network layers to ensure coverage stages remain I/O-free; manual and code-reviewed documentation updates that describe coverage invariants and how they relate to the existing core pipeline contracts, including status:'deprecated' semantics for diagnostic-only targets such as SCHEMA_REUSED_COVERED and the use of status:'unreachable' (rather than a dedicated unreachableTargets array) to represent unreachable targets in coverage-report/v1.",
        "subtasks": [
          {
            "id": 9312001,
            "title": "Implement acceptance tests for oneOf, optional properties and enums",
            "description": "Add e2e tests that validate oneOf branch coverage, PROPERTY_PRESENT behavior and enum coverage under measure and guided modes.",
            "status": "done",
            "estimatedHours": 4,
            "file": "packages/core/test/e2e/coverage-acceptance.spec.ts",
            "parentId": "9312",
            "updatedAt": "2025-11-30T02:44:13.323Z"
          },
          {
            "id": 9312002,
            "title": "Add tests for minCoverage and coverage threshold behavior",
            "description": "Create tests that assert coverageStatus, CLI exit codes and summary output when minCoverage is not met.",
            "status": "done",
            "estimatedHours": 2,
            "file": "packages/core/test/e2e/coverage-acceptance.spec.ts",
            "parentId": "9312",
            "updatedAt": "2025-11-30T02:44:21.341Z"
          },
          {
            "id": 9312003,
            "title": "Add OpenAPI coverage and reproducibility tests",
            "description": "Add e2e tests that validate coverage.byOperation, OP_* targets and reproducibility of coverage reports across identical runs.",
            "status": "done",
            "estimatedHours": 3,
            "file": "packages/core/test/e2e/coverage-openapi-acceptance.spec.ts",
            "parentId": "9312",
            "updatedAt": "2025-11-30T02:44:30.378Z"
          },
          {
            "id": 9312004,
            "title": "Document coverage invariants and limitations",
            "description": "Update architecture and invariants docs to describe coverage-specific constraints and how they compose with existing pipeline guarantees. Document that diagnostic-only targets such as SCHEMA_REUSED_COVERED are emitted with status:'deprecated' so they are excluded from all coverage denominators while remaining visible in reports, and that unreachable targets are identified by status:'unreachable' in CoverageTargetReport entries with no separate unreachableTargets array in coverage-report/v1; consumers must derive unreachable views by filtering on status.",
            "status": "done",
            "estimatedHours": 3,
            "file": "docs/spec-coverage-aware-v1.x.md",
            "parentId": "9312",
            "updatedAt": "2025-11-30T02:44:39.175Z"
          }
        ],
        "updatedAt": "2025-11-30T02:44:39.175Z"
      },
      {
        "id": 9320,
        "title": "Document coverage-aware modes and CLI usage in README",
        "description": "Update top-level README.md with coverage=off|measure|guided modes, dimensions, thresholds and examples for CLI and Node API.",
        "priority": "medium",
        "estimatedHours": 8,
        "dependencies": [
          "9302",
          "9303",
          "9304"
        ],
        "status": "done",
        "complexityScore": 2,
        "details": "[Context]\nREADME.md currently focuses on the 5-stage pipeline, CLI and Node APIs but does not surface coverage-aware behavior or coverage CLI flags introduced in tasks 9302–9304.\n\n[Key requirements]\n- Add a dedicated \"Coverage-aware generation\" section explaining coverage modes (off/measure/guided), dimensionsEnabled, excludeUnreachable and minCoverage semantics at a high level.\n- Extend the CLI section with coverage flags (--coverage, --coverage-dimensions, --coverage-min, --coverage-report, --coverage-profile, --coverage-exclude-unreachable) and example commands for JSON Schema and OpenAPI entrypoints.\n- Explain where coverage reports are written (CLI --coverage-report path vs Node API Promise) and how they relate to the coverage-report/v1 spec document (docs/spec-coverage-aware-v1.x.md).\n- Keep the README balanced: coverage is an opt-in feature layered on top of the existing pipeline, not a separate product.\n\n[Deliverables]\n- Updated README.md with a coverage section under or near the existing \"How it works\" / \"CLI\" sections.\n- At least two worked examples showing coverage usage in CI (one JSON Schema, one OpenAPI).\n\n[Definition of Done]\n- All coverage explanations in README.md are consistent with the coverage-aware-v1 spec and with CLI behavior shipped in 9304.\n- README examples run successfully against the current CLI (manual check or simple smoke script).",
        "testStrategy": "Manual doc review plus a small smoke script that runs the CLI examples from README in CI to ensure they stay valid over time.",
        "subtasks": [
          {
            "id": 9320001,
            "title": "Add coverage overview and modes to README",
            "description": "Introduce a \"Coverage-aware generation\" section in README.md that explains coverage modes, dimensionsEnabled and the high-level reporting model, linking to docs/spec-coverage-aware-v1.x.md for full details.",
            "status": "done",
            "estimatedHours": 3,
            "file": "README.md",
            "parentId": "9320",
            "updatedAt": "2025-11-30T02:59:10.696Z"
          },
          {
            "id": 9320002,
            "title": "Document CLI coverage flags and examples in README",
            "description": "Extend the CLI section in README.md with a table and short examples for --coverage, --coverage-dimensions, --coverage-min, --coverage-report, --coverage-profile and --coverage-exclude-unreachable on generate/openapi commands.",
            "status": "done",
            "estimatedHours": 3,
            "file": "README.md",
            "parentId": "9320",
            "updatedAt": "2025-11-30T02:59:16.270Z"
          },
          {
            "id": 9320003,
            "title": "Describe Node API access to coverage reports",
            "description": "Add a short paragraph and code snippet in the Node.js API section showing how to consume the CoverageReport Promise from the pipeline result (coverageStatus, thresholds.overall, metrics.byDimension/byOperation).",
            "status": "done",
            "estimatedHours": 2,
            "file": "README.md",
            "parentId": "9320",
            "updatedAt": "2025-11-30T02:59:21.335Z"
          }
        ],
        "updatedAt": "2025-11-30T02:59:21.335Z"
      },
      {
        "id": 9321,
        "title": "Align feature and limits docs with coverage-aware behavior",
        "description": "Update COMPREHENSIVE_FEATURE_SUPPORT.md, Features.md and Known-Limits.md to describe coverage-aware v1 semantics, dimensions and guarded behaviors.",
        "priority": "medium",
        "estimatedHours": 10,
        "dependencies": [
          "9302",
          "9303",
          "9304",
          "9307",
          "9309",
          "9310"
        ],
        "status": "done",
        "complexityScore": 3,
        "details": "[Context]\nCOMPREHENSIVE_FEATURE_SUPPORT.md and Features.md focus on JSON Schema feature support, while Known-Limits.md documents complexity caps and AP:false coverage constraints. None of them currently describe coverage dimensions, coverage metrics or diagnostic-only targets as defined by coverage-aware-v1.\n\n[Key requirements]\n- Extend COMPREHENSIVE_FEATURE_SUPPORT.md with a short subsection summarizing which JSON Schema features have coverage-aware behavior (AP:false must-cover, contains, conditionals, boundaries, OpenAPI operations) and how they contribute to coverage metrics.\n- Add one or more rows to Features.md that track coverage support by dimension and phase (structure/branches/enum M0, guided coverage M1, boundaries and per-operation coverage M2), with the same ✓ / ~ / ⚠️ legend.\n- Expand Known-Limits.md with coverage-specific limits: caps on target counts where applicable, AP:false coverage nuances, boundaries dimension constraints, and how excludeUnreachable and dimensionsEnabled affect denominators while leaving IDs/statuses stable.\n- Explicitly document that diagnostic-only targets such as SCHEMA_REUSED_COVERED are emitted with status:'deprecated' so they never contribute to metrics or thresholds even when present in targets/uncoveredTargets.\n\n[Deliverables]\n- Updated COMPREHENSIVE_FEATURE_SUPPORT.md, Features.md and Known-Limits.md that mention coverage-aware behavior where relevant and link back to the coverage spec for full definitions.\n\n[Definition of Done]\n- Feature tables and narrative docs no longer contradict the coverage-aware-v1 spec or the implementation status of tasks 9302–9304/9309/9310.\n- Known-Limits.md has an explicit subsection for coverage-aware constraints, not just composition-time limits.",
        "testStrategy": "Doc review against the coverage-aware-v1 spec plus a quick check that all added rows in Features.md remain accurate when scanning the implementation status of coverage tasks.",
        "subtasks": [
          {
            "id": 9321001,
            "title": "Extend COMPREHENSIVE_FEATURE_SUPPORT.md with coverage-aware notes",
            "description": "Add a small \"Coverage-aware behavior\" subsection under JSON Schema features, calling out how AP:false, contains, numeric bounds and OpenAPI operations interact with coverage dimensions and metrics.",
            "status": "done",
            "estimatedHours": 3,
            "file": "COMPREHENSIVE_FEATURE_SUPPORT.md",
            "parentId": "9321",
            "updatedAt": "2025-11-30T13:27:36.369Z"
          },
          {
            "id": 9321002,
            "title": "Add coverage rows to Features.md matrix",
            "description": "Add one or more rows to the feature matrix summarizing support for coverage measurement, guided coverage, boundaries and per-operation metrics, using the existing ✓ / ~ / ⚠️ legend.",
            "status": "done",
            "estimatedHours": 3,
            "file": "Features.md",
            "parentId": "9321",
            "updatedAt": "2025-11-30T13:36:04.824Z"
          },
          {
            "id": 9321003,
            "title": "Expand Known-Limits.md with coverage-aware limits",
            "description": "Update Known-Limits.md with explicit coverage-aware constraints (AP:false coverage semantics, boundary target limits, streaming instrumentation overhead assumptions, operationsScope/selectedOperations semantics for byOperation).",
            "status": "done",
            "estimatedHours": 4,
            "file": "Known-Limits.md",
            "parentId": "9321",
            "updatedAt": "2025-11-30T14:07:37.081Z"
          }
        ],
        "updatedAt": "2025-11-30T14:07:37.081Z"
      },
      {
        "id": 9322,
        "title": "Extend invariants and architecture docs for coverage-aware pipeline",
        "description": "Document coverage-aware invariants and architecture, and add an evaluation hook for coverage usage.",
        "priority": "medium",
        "estimatedHours": 10,
        "dependencies": [
          "9302",
          "9303",
          "9307",
          "9308",
          "9312"
        ],
        "status": "done",
        "complexityScore": 3,
        "details": "[Context]\nInvariants.md and ARCHITECTURE.md describe the 5-stage pipeline, AJV parity and AP:false behavior but do not yet capture the coverage-aware layers (CoverageAnalyzer, instrumentation, CoverageEvaluator, planner/hints) or their invariants. EVALUATION.md focuses on basic data generation evaluation and does not show how to quickly inspect coverage.\n\n[Key requirements]\n- Add a \"Coverage invariants\" section to Invariants.md, covering: CoverageTarget.id determinism, dimension semantics (structure/branches/enum/boundaries/operations), status values ('active'/'unreachable'/'deprecated'), metrics behavior under dimensionsEnabled/excludeUnreachable, and the guarantee that diagnostic-only targets are excluded from all denominators.\n- Describe streaming coverage instrumentation as an invariant: per-instance coverage state, commit-after-validate, no second JSON parse, no additional network I/O, and reuse of the original AJV as oracle.\n- Extend ARCHITECTURE.md with a description of coverage-specific modules (CoverageAnalyzer between Compose and Generate, CoveragePlanner/hints for coverage=guided, CoverageEvaluator/coverage-report, streaming instrumentation attached to Generate/Repair/Validate) and how they compose with the 5-stage pipeline.\n- Update EVALUATION.md with an optional step that demonstrates running with coverage enabled (e.g. coverage=measure with a small n and dimensionsEnabled) and interpreting the CLI coverage summary at a high level.\n\n[Deliverables]\n- New \"Coverage invariants\" section in Invariants.md.\n- Updated ARCHITECTURE.md showing coverage-aware modules and their constraints.\n- EVALUATION.md updated with an optional coverage evaluation step.\n\n[Definition of Done]\n- Core coverage invariants are written once in Invariants.md and referenced from other docs instead of being duplicated ad hoc.\n- Architecture and evaluation docs are consistent with the implementation and the spec-level doc docs/spec-coverage-aware-v1.x.md.",
        "testStrategy": "Doc review against Invariants.md and ARCHITECTURE.md plus a quick manual run of the evaluation steps (with coverage enabled) to ensure the suggested commands still work.",
        "subtasks": [
          {
            "id": 9322001,
            "title": "Add coverage invariants section to Invariants.md",
            "description": "Describe coverage-target ID stability, dimension semantics, status handling ('active'/'unreachable'/'deprecated'), minCoverage/coverageStatus and streaming commit-after-validate behavior in Invariants.md.",
            "status": "done",
            "estimatedHours": 4,
            "file": "Invariants.md",
            "parentId": "9322",
            "updatedAt": "2025-11-30T13:08:17.315Z"
          },
          {
            "id": 9322002,
            "title": "Extend ARCHITECTURE.md with coverage-aware modules",
            "description": "Update ARCHITECTURE.md to show where CoverageAnalyzer, streaming instrumentation, CoveragePlanner/hints and CoverageEvaluator sit relative to Normalize → Compose → Generate → Repair → Validate, including their no-network-I/O and AJV-as-oracle constraints.",
            "status": "done",
            "estimatedHours": 4,
            "file": "ARCHITECTURE.md",
            "parentId": "9322",
            "updatedAt": "2025-11-30T13:15:11.158Z"
          },
          {
            "id": 9322003,
            "title": "Add optional coverage step to EVALUATION.md",
            "description": "Extend EVALUATION.md with an optional step that runs the CLI with coverage=measure on a real schema, inspects the coverage summary and briefly explains how to read per-dimension/overall coverage.",
            "status": "done",
            "estimatedHours": 2,
            "file": "EVALUATION.md",
            "parentId": "9322",
            "updatedAt": "2025-11-30T13:19:24.724Z"
          }
        ],
        "updatedAt": "2025-11-30T13:19:24.724Z"
      },
      {
        "id": 9323,
        "title": "Document coverage-report/v1 and coverage diff tooling",
        "description": "Extend reporter docs with coverage-report/v1 contract and coverage diff CLI usage.",
        "priority": "medium",
        "estimatedHours": 8,
        "dependencies": [
          "9303",
          "9304",
          "9310",
          "9311"
        ],
        "status": "done",
        "complexityScore": 3,
        "details": "[Context]\npackages/reporter/README.md documents the json-schema-reporter CLI and bench/corpus modes but does not yet describe the coverage-report/v1 JSON format or the coverage diff command introduced in 9311.\n\n[Key requirements]\n- Add a concise description of the coverage-report/v1 structure to packages/reporter/README.md: header (version, engine, run), metrics.overall/byDimension/byOperation, targets/targetsByStatus/uncoveredTargets and thresholds/coverageStatus.\n- Document how to obtain coverage-report/v1 files via the core CLI (--coverage-report) and how the reporter layer can consume them if relevant.\n- Add a dedicated section for the coverage diff CLI (e.g. \"foundrydata coverage diff A.json B.json\"): arguments, basic behavior, version compatibility checks and exit-code semantics when regressions are detected.\n- Cross-link from the core README coverage section to the reporter diff documentation so users can discover the diff workflow from either side.\n\n[Deliverables]\n- Updated packages/reporter/README.md with coverage-report/v1 and coverage diff sections.\n- Optional small JSON snippet showing a trimmed example CoverageReport for illustration.\n\n[Definition of Done]\n- Users reading packages/reporter/README.md understand how to obtain coverage reports, how to diff them between runs and what guarantees/limits apply to the diff output.",
        "testStrategy": "Doc review plus a small script in tests or CI that runs the coverage diff CLI on two fixture reports and ensures the documented command line matches reality.",
        "subtasks": [
          {
            "id": 9323001,
            "title": "Describe coverage-report/v1 in reporter README",
            "description": "Add a section to packages/reporter/README.md that explains the CoverageReport header, metrics, targets, targetsByStatus and thresholds fields at a high level, with a small example.",
            "status": "done",
            "estimatedHours": 3,
            "file": "packages/reporter/README.md",
            "parentId": "9323",
            "updatedAt": "2025-11-30T12:43:15.675Z"
          },
          {
            "id": 9323002,
            "title": "Document coverage diff CLI usage",
            "description": "Document the coverage diff CLI command in packages/reporter/README.md (or a linked doc): arguments, behavior on regressions, exit-code contract and compatibility rules for comparing reports.",
            "status": "done",
            "estimatedHours": 3,
            "file": "packages/reporter/README.md",
            "parentId": "9323",
            "updatedAt": "2025-11-30T12:56:56.560Z"
          },
          {
            "id": 9323003,
            "title": "Add cross-links between core README and reporter docs",
            "description": "From README.md coverage section, link to the reporter / coverage diff documentation, and from packages/reporter/README.md link back to the coverage-aware overview in README.md.",
            "status": "done",
            "estimatedHours": 2,
            "file": "packages/reporter/README.md",
            "parentId": "9323",
            "updatedAt": "2025-11-30T13:01:10.566Z"
          }
        ],
        "updatedAt": "2025-11-30T13:01:10.566Z"
      },
      {
        "id": 9324,
        "title": "Add coverage-aware CLI examples and use cases docs",
        "description": "Update docs/use-cases/product-scenarios.md and examples/README.md to demonstrate coverage-aware modes (measure/guided), profiles (quick/balanced/thorough), and CI integration patterns with practical examples.",
        "details": "[Context]\nExtend user-facing documentation to showcase coverage-aware capabilities introduced in M0/M1, per spec §6 (Execution modes & UX) and §7 (Reporting & observability). The examples and use cases should help developers understand when and how to use coverage modes, profiles, and thresholds in CI/CD workflows.\n\n[Key requirements]\n- Update `docs/use-cases/product-scenarios.md` to add new scenarios or extend existing ones (API mocks, contract tests, LLM testing) with coverage-aware examples showing:\n  - `coverage=measure` for passive coverage tracking without changing output\n  - `coverage=guided` for coverage-oriented generation with hints\n  - Profile selection (`--coverage-profile quick|balanced|thorough`) and their trade-offs\n  - Threshold enforcement (`--coverage-min 0.8`) for CI gates\n  - Coverage report generation (`--coverage-report coverage.json`) and inspection\n  \n- Update `examples/README.md` to include practical CLI examples demonstrating:\n  - Basic coverage measurement with existing example schemas (e.g., `ecommerce-schema.json`, `payment.json`)\n  - Guided coverage runs with dimension selection (`--coverage-dimensions structure,branches,enum`)\n  - Profile usage showing different instance budgets and coverage depth\n  - CI integration pattern with exit code handling for failed thresholds\n  - Reading and interpreting coverage-report/v1 JSON output\n  \n- Add a dedicated subsection to `examples/README.md` titled \"Coverage-aware generation\" that includes:\n  - Quick examples of `coverage=off|measure|guided` modes\n  - Dimension flags (`--coverage-dimensions`)\n  - Profile flags (`--coverage-profile`)\n  - Threshold and report path flags\n  - Sample CI snippet showing coverage threshold enforcement in GitHub Actions or similar\n  \n- Ensure all examples align with implemented CLI flags from task 9304 (coverage-options.ts: mode, dimensionsEnabled, excludeUnreachable, minCoverage, reportPath, profile)\n\n- Reference spec anchors for deeper reading but keep examples practical and copy-paste ready\n\n[Implementation notes]\n- Use existing example schemas (ecommerce-schema.json, payment.json, users-api.json) as test subjects\n- Show realistic instance counts and thresholds (e.g., `--n 100 --coverage-min 0.75`)\n- Demonstrate `--print-metrics` and `--debug-passes` for observability\n- Include a simple CI script example (bash/yaml) that runs coverage and fails the build if coverage < threshold\n- Keep examples concise and focused on one coverage feature at a time\n- Add cross-references between use-cases and examples for discoverability",
        "testStrategy": "Doc review checklist:\n- Verify all CLI flags referenced in examples match coverage-options.ts implementation (mode, dimensions, profile, minCoverage, reportPath, excludeUnreachable)\n- Run each CLI example command manually to confirm it executes without error and produces expected coverage output\n- Validate that coverage JSON report examples reference the correct coverage-report/v1 schema from spec §7.1\n- Check that CI integration examples are syntactically valid for target platforms (GitHub Actions, GitLab CI, or generic bash)\n- Confirm that product-scenarios.md examples align with existing scenario structure (User context, Goal, Success criteria, CLI example, Node API example, Friction/gaps, Current status)\n- Ensure cross-references between docs/use-cases and examples/README.md are correct and navigable\n- Snapshot test one or two coverage examples in CI to ensure they remain valid as coverage implementation evolves",
        "status": "done",
        "dependencies": [
          "9302",
          "9303",
          "9304"
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement coverage-aware CLI examples and docs",
            "description": "Update docs/use-cases/product-scenarios.md and examples/README.md with coverage-aware CLI usage, profiles (quick/balanced/thorough), coverage modes (off/measure/guided), thresholds and CI patterns, aligned with coverage-options.ts and coverage-report/v1 spec.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 9324,
            "updatedAt": "2025-11-30T12:26:02.263Z",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-11-30T12:26:02.263Z"
      },
      {
        "id": 9325,
        "title": "Detect conflicting coverage hints early with CONFLICTING_CONSTRAINTS",
        "description": "Extend CoverageAnalyzer and CoveragePlanner to detect when coverage hints target structurally impossible schema fragments (e.g., ensurePropertyPresence on properties disabled by not/required combinations) and emit CONFLICTING_CONSTRAINTS early, before generation begins.",
        "details": "[Context]\nImplement early static detection of conflicting coverage hints as described in spec §5 (Hints & interaction with Repair) and the UnsatisfiedHintReasonCode type definition in coverage-report.ts. Currently, CONFLICTING_CONSTRAINTS is emitted reactively during or after generation/repair when hints fail. This task adds proactive detection at the CoverageAnalyzer/Planner stage to catch structurally impossible hints before any instance generation occurs.\n\n[Key requirements]\n- Extend CoverageAnalyzer (packages/core/src/coverage/analyzer.ts) to detect structurally impossible targets during graph construction:\n  * Property presence hints targeting properties that are provably unreachable due to not/allOf/required contradictions\n  * Branch hints (preferBranch) targeting oneOf/anyOf branches already marked unreachable in planDiag\n  * Enum hints (coverEnumValue) targeting out-of-range enum indices or values incompatible with other constraints\n  * Property presence hints on AP:false objects where CoverageIndex.has() returns false for the target property\n  \n- Add a static constraint validation phase in CoveragePlanner.buildHintsForTarget() (packages/core/src/coverage/coverage-planner.ts:469-530):\n  * Before constructing hints for a target, check if the target's status is 'unreachable'\n  * Validate that ensurePropertyPresence hints reference properties that exist in the CoverageIndex when AP:false applies\n  * Validate that preferBranch hints reference branches within valid index bounds for the parent oneOf/anyOf\n  * Validate that coverEnumValue hints reference valid enum indices based on the canonical schema enum array length\n  \n- Introduce a ConflictDetector utility class in coverage/conflict-detector.ts:\n  ```typescript\n  export interface ConflictCheckInput {\n    hint: CoverageHint;\n    target: CoverageTarget;\n    canonSchema: unknown;\n    coverageIndex: CoverageIndex;\n    planDiag?: ComposeDiagnostics;\n  }\n  \n  export interface ConflictCheckResult {\n    isConflicting: boolean;\n    reasonCode?: UnsatisfiedHintReasonCode;\n    reasonDetail?: string;\n  }\n  \n  export class ConflictDetector {\n    static checkHintConflict(input: ConflictCheckInput): ConflictCheckResult;\n    private static checkPropertyPresenceConflict(...): ConflictCheckResult;\n    private static checkBranchConflict(...): ConflictCheckResult;\n    private static checkEnumConflict(...): ConflictCheckResult;\n  }\n  ```\n  \n- Emit conflicting hints early as UnsatisfiedHint records:\n  * When planTestUnits() constructs TestUnits, run ConflictDetector.checkHintConflict() on each generated hint\n  * Accumulate conflicting hints in a new CoveragePlannerResult.conflictingHints: UnsatisfiedHint[] field\n  * Mark the corresponding targets with diagnostic metadata (e.g., meta.conflictDetected: true)\n  * Ensure these early-detected conflicting hints are merged into the final CoverageReport.unsatisfiedHints array\n  \n- Integrate with existing UNSAT detection:\n  * Reuse buildUnsatPathSet() from analyzer.ts:55-87 to identify unreachable schema paths\n  * Cross-reference hints against unsatPaths to detect UNREACHABLE_BRANCH cases early\n  * Respect the existing strongUnsatCodes set (UNSAT_AP_FALSE_EMPTY_COVERAGE, UNSAT_NUMERIC_BOUNDS, etc.)\n  * Ensure conflict detection does NOT introduce a separate proof engine; rely solely on existing planDiag diagnostics\n  \n- Extend CoveragePlannerInput and CoveragePlannerResult types:\n  ```typescript\n  // In coverage-planner.ts\n  export interface CoveragePlannerInput {\n    graph: CoverageGraph;\n    targets: CoverageTarget[];\n    config: CoveragePlannerConfig;\n    canonSchema: unknown; // NEW: for conflict validation\n    coverageIndex: CoverageIndex; // NEW: for AP:false property checks\n    planDiag?: ComposeDiagnostics; // NEW: for UNSAT cross-checks\n  }\n  \n  export interface CoveragePlannerResult {\n    testUnits: TestUnit[];\n    conflictingHints: UnsatisfiedHint[]; // NEW\n  }\n  ```\n  \n- Update the orchestrator (packages/core/src/pipeline/orchestrator.ts) to:\n  * Pass canonSchema, coverageIndex, and planDiag to planTestUnits()\n  * Collect conflictingHints from CoveragePlannerResult\n  * Merge them into the final CoverageReport.unsatisfiedHints before CoverageEvaluator runs\n  \n- Document conflict detection heuristics in ARCHITECTURE.md or Invariants.md:\n  * List the specific structural patterns that trigger CONFLICTING_CONSTRAINTS\n  * Clarify that this is a conservative early filter, not a complete proof system\n  * Note that some conflicts may still be detected later during generation/repair if static analysis misses them\n\n[Example scenarios to handle]\n1. Schema with `{\"not\": {\"required\": [\"foo\"]}}` → ensurePropertyPresence(foo, true) is conflicting\n2. Schema with `{\"properties\": {\"bar\": false}}` → ensurePropertyPresence(bar, true) is conflicting (bar schema is false)\n3. oneOf with 3 branches, one marked unreachable → preferBranch(unreachableBranch) is UNREACHABLE_BRANCH\n4. enum with 5 values → coverEnumValue(valueIndex: 10) is CONFLICTING_CONSTRAINTS (out of bounds)\n5. AP:false object with CoverageIndex that excludes \"baz\" → ensurePropertyPresence(baz, true) is CONFLICTING_CONSTRAINTS\n\n[Implementation notes]\n- Keep conflict detection deterministic and side-effect-free\n- Prefer false negatives (missing conflicts) over false positives (incorrectly flagging valid hints)\n- Reuse existing UNSAT diagnostics from Compose; do not re-implement schema constraint solving\n- Ensure conflict detection overhead is O(#hints), not O(#hints * #targets)\n- Add a feature flag or config option to disable early conflict detection for debugging if needed",
        "testStrategy": "Unit tests for ConflictDetector:\n- Test checkPropertyPresenceConflict with not/required contradictions, false schemas, and AP:false objects\n- Test checkBranchConflict with unreachable branches marked in planDiag\n- Test checkEnumConflict with out-of-range indices and empty enums\n- Property-based tests that generate random schemas + hints and verify conflict detection is conservative (no false positives)\n\nIntegration tests in coverage-planner.test.ts:\n- Run planTestUnits() on schemas with known conflicting hints and assert conflictingHints array is populated\n- Verify that conflicting hints do NOT appear in TestUnit.hints arrays\n- Verify that non-conflicting hints remain in TestUnit.hints as expected\n- Test that conflicting hints are merged into CoverageReport.unsatisfiedHints with reasonCode: 'CONFLICTING_CONSTRAINTS'\n\nEnd-to-end tests in coverage-guided-planner.spec.ts:\n- Run coverage=guided on a schema with not/required contradictions and assert CONFLICTING_CONSTRAINTS appears in the coverage report\n- Run coverage=guided on an AP:false schema with CoverageIndex exclusions and verify conflicting property hints are flagged\n- Compare coverage reports before and after the feature to ensure no valid hints are incorrectly flagged\n\nSnapshot tests:\n- Generate coverage reports for fixtures with known conflicting hints and snapshot the unsatisfiedHints array\n- Ensure reasonDetail field provides actionable information (e.g., \"Property 'foo' is disabled by not.required constraint at #/not\")\n\nPerformance tests:\n- Benchmark planTestUnits() with 1000+ targets and verify conflict detection overhead is < 5% of total planning time\n- Ensure conflict detection does not trigger additional schema traversals beyond the existing CoverageAnalyzer pass",
        "status": "done",
        "dependencies": [
          "9301",
          "9305",
          "9306"
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement early conflict detection",
            "description": "Extend CoverageAnalyzer/Planner with a ConflictDetector to flag structurally impossible hints before generation, expose conflicting hints in the report, and add regression tests.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 9325,
            "updatedAt": "2025-11-29T16:03:37.626Z",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-11-29T16:03:37.626Z"
      },
      {
        "id": 9326,
        "title": "Detect impossible hints conflicting with keywords",
        "description": "Recognize when coverage hints target schema fragments that are structurally ruled out (not+required, contradictory allOf/oneOf, etc.), emit CONFLICTING_CONSTRAINTS early, and document the rule in AGENTS.md.",
        "details": "[Context]\nExtend the hint conflict detection pipeline to identify and report coverage hints that are impossible to satisfy due to structural schema constraints. Per the coverage-aware spec and the existing UnsatisfiedHintReasonCode infrastructure (coverage-report.ts:38-44), hints can conflict not only with each other but also with schema keywords that make them structurally unreachable. This task implements early detection of such impossible hints during the CoveragePlanner phase and ensures they are surfaced as CONFLICTING_CONSTRAINTS diagnostics.\n\n[Key requirements]\n- Implement structural constraint analysis in CoveragePlanner that detects impossible hint scenarios:\n  * Hints targeting properties marked as required in a schema fragment with \"not\" around it\n  * Contradictory allOf branches where hints request mutually exclusive constraints\n  * oneOf branches where a hint targets a branch that is structurally incompatible with other constraints\n  * Property presence hints conflicting with additionalProperties:false and missing from properties/patternProperties\n- Emit CONFLICTING_CONSTRAINTS (already defined in UnsatisfiedHintReasonCode) during the planning phase when impossible hints are detected, before generation begins\n- Add detection hook in CoveragePlanner.planTestUnits() that validates hints against canonical schema structure using compose artifacts (canonSchema, ptrMap)\n- Record impossible hints in unsatisfiedHints[] with reasonCode:'CONFLICTING_CONSTRAINTS' and detailed reasonDetail explaining the structural conflict\n- Ensure traceability: each detected conflict must reference the specific canonPath, hint kind, hint params, and conflicting schema keywords\n- Document the detection rules and examples in AGENTS.md under a new section \"Coverage hint structural validation\"\n\n[Deliverables]\n- packages/core/src/coverage/coverage-planner.ts: Add validateHintStructuralFeasibility() function that analyzes hints against canonical schema\n- packages/core/src/coverage/coverage-planner.ts: Integrate validation into planTestUnits() to filter out impossible hints before test unit creation\n- packages/core/src/coverage/__tests__/coverage-planner.test.ts: Unit tests for each impossible hint pattern (not+required, contradictory allOf, incompatible oneOf, AP:false violations)\n- packages/core/test/e2e/coverage-guided-planner.spec.ts: Integration tests using executePipeline that verify CONFLICTING_CONSTRAINTS appears in coverage report unsatisfiedHints\n- AGENTS.md: New section documenting the structural validation rules with examples\n- Ensure generator hooks respect the filtered hints and do not attempt to apply structurally impossible hints\n\n[Definition of Done]\n- CoveragePlanner detects and filters hints that conflict with \"not\" wrapping required properties\n- CoveragePlanner detects hints targeting branches ruled out by contradictory allOf/oneOf constraints\n- Impossible hints appear in CoverageReport.unsatisfiedHints[] with reasonCode:'CONFLICTING_CONSTRAINTS' and actionable reasonDetail\n- Unit tests achieve >=80% coverage on new validation logic in coverage-planner.ts\n- Integration tests with executePipeline demonstrate end-to-end flow: impossible hint → planner detection → unsatisfiedHints in coverage-report/v1\n- AGENTS.md documents each detection rule with canonical schema examples\n- No regression in existing hint resolution tests",
        "testStrategy": "Unit tests in coverage-planner.test.ts:\n- Test validateHintStructuralFeasibility() with schemas containing \"not\": {\"required\": [\"foo\"]} and hints requesting ensurePropertyPresence for \"foo\" → expect CONFLICTING_CONSTRAINTS\n- Test contradictory allOf scenarios where hints request conflicting enum values or type constraints\n- Test oneOf with hints targeting mutually exclusive branches\n- Test property presence hints against AP:false schemas where property is not in properties/patternProperties\n- Property-based tests that generate random hint sets and verify no false positives on valid hints\n\nIntegration tests in coverage-guided-planner.spec.ts:\n- Create schemas with impossible hint scenarios and run executePipeline with coverage=guided\n- Assert that CoverageReport.unsatisfiedHints includes entries with reasonCode:'CONFLICTING_CONSTRAINTS'\n- Verify reasonDetail contains specific schema keyword conflicts (e.g., \"hint targets property 'x' marked required within 'not' constraint at #/not\")\n- Ensure metrics.overall and coverage.byDimension are unaffected by impossible hint filtering\n\nEnd-to-end traceability tests:\n- Run pipeline with multiple impossible hints and verify each appears exactly once in unsatisfiedHints\n- Verify that valid hints in the same TestUnit are not affected by filtering of impossible hints\n- Snapshot tests for unsatisfiedHints output format consistency",
        "status": "done",
        "dependencies": [
          "9305",
          "9307",
          "9308"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2025-11-29T16:47:43.497Z"
      },
      {
        "id": 9327,
        "title": "Detect impossible coverage hints",
        "description": "Identify when a coverage hint targets schema fragments the SPEC renders impossible (e.g., ensurePropertyPresence under not/required blocks, contradictory allOf/oneOf), emit CONFLICTING_CONSTRAINTS during planning or generation, and update AGENTS.md to capture the decision process so the topic isn't left dangling.",
        "details": "[Context]\nExtend the hint conflict detection pipeline to identify and report coverage hints that are impossible to satisfy due to structural schema constraints. Per the coverage-aware spec and the existing UnsatisfiedHintReasonCode infrastructure (coverage-report.ts:38-44), hints can conflict not only with each other but also with schema keywords that make them structurally unreachable. This task implements early detection of such impossible hints during the CoveragePlanner phase and ensures the generator and repair stages honor this classification.\n\n[Key requirements]\n- Implement a structural feasibility check in CoveragePlanner that validates hints against canonical schema constraints before planning TestUnits\n- Detect ensurePropertyPresence hints that conflict with \"not\": {\"required\": [\"prop\"]}, false schemas under properties, or additionalProperties: false for undeclared properties\n- Detect preferBranch hints that target branches marked unreachable in planDiag or that violate allOf/oneOf exclusivity constraints\n- Detect coverEnumValue hints with valueIndex outside the enum array bounds or targeting empty enums\n- Emit CONFLICTING_CONSTRAINTS early via recordUnsatisfiedHint when structural conflicts are detected, before TestUnit generation begins\n- Integrate the feasibility check into the CoveragePlanner workflow: resolve hint conflicts first (resolveCoverageHintConflicts), then validate structural feasibility, filtering out impossible hints before buildHintsForTarget\n- Update AGENTS.md to document the decision process for impossible hint detection, including the rationale for structural checks and examples of conflicting constraints\n- Ensure the detection logic operates on the canonical schema view and honors the same invariants as the generator (no side effects on RNG or instance shape)\n\n[Deliverables]\n- New module coverage/hint-feasibility.ts with validation helpers:\n  - validateHintStructuralFeasibility(hint: CoverageHint, canonSchema: Schema, graph: CoverageGraph, planDiag?: NodeDiagnostics): UnsatisfiedHint | null\n  - checkPropertyPresenceConflict(hint: EnsurePropertyPresenceHint, canonSchema: Schema): boolean\n  - checkBranchConflict(hint: PreferBranchHint, canonSchema: Schema, planDiag?: NodeDiagnostics): boolean\n  - checkEnumConflict(hint: CoverEnumValueHint, canonSchema: Schema): boolean\n- Integration of feasibility checks into CoveragePlanner.planTestUnits: after resolveCoverageHintConflicts, run validateHintStructuralFeasibility on each effective hint and record unsatisfied hints with CONFLICTING_CONSTRAINTS before proceeding to TestUnit construction\n- Generator-side assertion: when processing hints, if a hint was missed by planner validation, emit CONFLICTING_CONSTRAINTS during generation (defensive fallback)\n- AGENTS.md entry documenting:\n  - The decision to detect impossible hints at planning time\n  - Schema patterns that trigger CONFLICTING_CONSTRAINTS (not/required, false schemas, allOf/oneOf contradictions, out-of-bounds enum indices)\n  - Traceability note linking this capability to task 9327 and the coverage-aware spec §5 (Hints & interaction with Repair)\n- Unit tests in coverage/__tests__/hint-feasibility.test.ts covering:\n  - ensurePropertyPresence vs \"not\": {\"required\": [\"foo\"]}\n  - ensurePropertyPresence vs additionalProperties: false for undeclared properties\n  - preferBranch vs unreachable oneOf branches (planDiag-marked)\n  - coverEnumValue vs out-of-range indices and empty enums\n  - contradictory allOf scenarios where hints request conflicting enum values or branches\n- Integration test in coverage-planner.test.ts that constructs a CoverageGraph with planDiag, passes hints that conflict with schema structure, and asserts CONFLICTING_CONSTRAINTS entries are recorded before TestUnits are built\n- E2E pipeline test in test/e2e/coverage-guided-planner.spec.ts that runs executePipeline with coverage=guided, impossible hints, and checks the coverage report's unsatisfiedHints array contains the expected CONFLICTING_CONSTRAINTS entries\n\n[Definition of Done]\n- validateHintStructuralFeasibility and helper functions exist in coverage/hint-feasibility.ts with type-safe signatures\n- CoveragePlanner.planTestUnits integrates feasibility validation after hint conflict resolution and before TestUnit construction\n- Generator emits CONFLICTING_CONSTRAINTS for impossible hints as a defensive fallback (coverage/foundry-generator.ts:1089-1093 pattern)\n- AGENTS.md contains a dedicated section on impossible hint detection with examples and traceability\n- Unit tests for all conflict patterns pass with ≥80% coverage on hint-feasibility.ts\n- Integration test in coverage-planner.test.ts asserts early unsatisfied hint recording\n- E2E test in coverage-guided-planner.spec.ts validates the full pipeline behavior with impossible hints\n- npm run build, typecheck, lint, test all pass without regressions",
        "testStrategy": "Unit tests for hint-feasibility.ts:\n- Test validateHintStructuralFeasibility() with schemas containing \"not\": {\"required\": [\"foo\"]} and hints requesting ensurePropertyPresence for \"foo\" → expect CONFLICTING_CONSTRAINTS with reasonDetail explaining the not/required conflict\n- Test checkPropertyPresenceConflict with additionalProperties: false and hint requesting a property not in declared properties → expect conflict\n- Test checkPropertyPresenceConflict with properties: { foo: false } and hint requesting ensurePropertyPresence for \"foo\" → expect conflict\n- Test checkBranchConflict with oneOf containing unreachable branches (marked in planDiag) and preferBranch hint targeting those indices → expect conflict\n- Test checkBranchConflict with contradictory allOf where branch selection is structurally impossible → expect conflict\n- Test checkEnumConflict with enum: [\"red\", \"green\"] and coverEnumValue hint with valueIndex: 5 → expect conflict\n- Test checkEnumConflict with empty enum: [] and any coverEnumValue hint → expect conflict\n- Test validateHintStructuralFeasibility returns null for valid hints (no conflicts detected)\n\nIntegration tests in coverage-planner.test.ts:\n- Construct a CoverageGraph with planDiag containing unreachable branch metadata\n- Pass hints array with impossible ensurePropertyPresence, preferBranch, and coverEnumValue hints\n- Assert that planTestUnits calls recordUnsatisfiedHint with CONFLICTING_CONSTRAINTS for each impossible hint before returning TestUnits\n- Verify that TestUnits do not include the conflicting hints in their hints array\n\nE2E pipeline test in coverage-guided-planner.spec.ts:\n- Build a schema with \"not\": {\"required\": [\"blockedProp\"]} and additionalProperties: false\n- Run executePipeline with coverage=guided and hints requesting ensurePropertyPresence for \"blockedProp\" and an undeclared property\n- Assert the coverage report's unsatisfiedHints array contains entries with reasonCode: 'CONFLICTING_CONSTRAINTS' and reasonDetail describing the structural conflict\n- Verify that generated instances do not satisfy the impossible hints and that the coverage metrics are unaffected by the unsatisfied hints\n\nRegression tests:\n- Ensure that valid hints (no structural conflicts) continue to work correctly and do not trigger false CONFLICTING_CONSTRAINTS\n- Run existing coverage-guided tests (generator-hints.spec.ts, repair-hints.spec.ts) to confirm no behavioral regressions\n- Check that the generator's defensive CONFLICTING_CONSTRAINTS fallback is exercised when planner validation is bypassed (unit test with direct generateFromCompose call)",
        "status": "done",
        "dependencies": [
          "9305",
          "9307",
          "9308"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2025-11-29T16:28:21.406Z"
      },
      {
        "id": 9330,
        "title": "Harden coverage invariants (unreachable, AP:false, determinism)",
        "description": "Strengthen coverage-aware invariants around unreachable targets, AP:false behavior and determinism so that coverage=measure/guided remains a pure projection layer fully aligned with the canonical + coverage-aware specs.",
        "priority": "high",
        "estimatedHours": 14,
        "dependencies": [
          "9300",
          "9301",
          "9302",
          "9303"
        ],
        "status": "done",
        "complexityScore": 4,
        "details": "[Context]\nThe current coverage implementation respects the high-level invariants (no coverage layer under coverage=off, AP:false delegated to CoverageIndex, deterministic IDs and reports) but relies on several implicit assumptions (diagnostic codes, AP:false branches, planner diagnostics). This task consolidates those invariants into explicit code paths and tests.\n\n[Key requirements]\n- Centralize the mapping between UNSAT/guardrail diagnostics and unreachable targets so that applyUnreachableStatusToTargets is driven by a single, well-documented list of strong UNSAT codes.\n- Guarantee that excludeUnreachable only affects denominators in metrics (overall, byDimension, byOperation) and never changes CoverageTarget.id or status; unreachable targets must remain discoverable through status:'unreachable' in targets/uncoveredTargets.\n- Under AP:false, assert that PROPERTY_PRESENT targets for undeclared names are only materialized when backed by CoverageIndex.has/enumerate, and never by patternProperties/propertyNames heuristics alone.\n- Extend determinism checks for coverage=off vs coverage=measure and coverage=measure vs coverage=guided on a broader schema corpus (including AP:false, OpenAPI and compound conditionals), ensuring instance streams and metrics obey the spec.\n\n[Deliverables]\n- Hardened unreachable mapping logic and tests in coverage-analyzer-unreachable.\n- Additional AP:false/ CoverageIndex-specific tests in analyzer and generator acceptance suites.\n- Extended pipeline/e2e tests comparing off vs measure and measure vs guided for representative schemas.\n\n[Definition of Done]\n- All unreachable/UNSAT behavior goes through a single mapping table with tests capturing expected paths.\n- AP:false invariants for PROPERTY_PRESENT and CoverageIndex are enforced by targeted unit/e2e tests.\n- Determinism tests for off/measure/guided cover at least: simple object schema, AP:false schema, oneOf/anyOf with hints, and a small OpenAPI spec; tests pass consistently.",
        "testStrategy": "Add unit tests in coverage-analyzer-unreachable to assert which diagnostic codes produce unreachable targets and to verify prefix-based matching on canonPath. Extend analyzer tests to cover AP:false + CoverageIndex combinations, including propertyNames/patternProperties with and without PNAMES_REWRITE_APPLIED. In pipeline-orchestrator and e2e coverage tests, add scenarios that run executePipeline under coverage=off vs coverage=measure and measure vs guided on multiple schemas and assert that (a) final items are byte-identical for off vs measure, and (b) guided branch/enum coverage is >= measure while IDs and unreachable statuses remain stable. Validate metrics with excludeUnreachable true/false and confirm only denominators change.",
        "subtasks": [
          {
            "id": 9330001,
            "title": "Centralize UNSAT codes and unreachable mapping",
            "description": "Refactor applyUnreachableStatusToTargets to use a single, shared list of strong UNSAT/guardrail codes, and add tests that prove unreachable status is derived only from these diagnostics and canonPath relations.",
            "status": "done",
            "estimatedHours": 4,
            "file": "packages/core/src/coverage/coverage-analyzer-unreachable.ts",
            "parentId": "9330",
            "updatedAt": "2025-11-30T15:34:04.232Z"
          },
          {
            "id": 9330002,
            "title": "Reinforce AP:false & CoverageIndex invariants",
            "description": "Add explicit checks and tests ensuring that PROPERTY_PRESENT targets under additionalProperties:false and AP:false cases are always backed by CoverageIndex.has/enumerate, never by heuristics over propertyNames or patternProperties alone.",
            "status": "done",
            "estimatedHours": 5,
            "file": "packages/core/src/coverage/analyzer.ts",
            "parentId": "9330",
            "updatedAt": "2025-11-30T15:38:16.726Z"
          },
          {
            "id": 9330003,
            "title": "Extend determinism tests for off/measure/guided",
            "description": "Broaden the pipeline/e2e coverage tests so that executePipeline is exercised with coverage=off, measure and guided on a corpus of schemas (plain JSON Schema, AP:false heavy schema, OpenAPI spec) and assert deterministic items, CoverageTargets and metrics.",
            "status": "done",
            "estimatedHours": 5,
            "file": "packages/core/test/e2e/coverage-acceptance.spec.ts",
            "parentId": "9330",
            "updatedAt": "2025-11-30T15:41:07.651Z"
          }
        ],
        "updatedAt": "2025-11-30T15:41:07.651Z"
      },
      {
        "id": 9331,
        "title": "Extract a dedicated coverage runtime from the pipeline orchestrator",
        "description": "Refactor executePipeline to delegate coverage-specific orchestration (Analyzer, Planner, hooks, Evaluator, report) to a focused coverage runtime module without changing observable behavior or spec compliance.",
        "priority": "medium",
        "estimatedHours": 12,
        "dependencies": [
          "9302",
          "9303",
          "9330"
        ],
        "status": "done",
        "complexityScore": 4,
        "details": "[Context]\nThe current pipeline orchestrator wires coverage logic inline (Analyzer, Planner, streaming accumulator, unsatisfied hints, coverageReport), increasing complexity and coupling. The spec treats coverage as a layer on top of Normalize→Compose→Generate→Repair→Validate. Isolating a coverage runtime improves maintainability and makes future evolution safer.\n\n[Key requirements]\n- Introduce a small internal API (coverage runtime) that takes canonical schema, Compose artifacts, resolved coverage options and generator outcomes, then returns coverageTargets, coverageMetrics, coverageReport and any planner diagnostics.\n- Move Analyzer + Planner + accumulator + Evaluator wiring into this runtime, preserving existing options semantics (mode, dimensionsEnabled, excludeUnreachable, minCoverage, reportMode) and determinism guarantees.\n- Keep executePipeline responsible for phase sequencing and diagnostics envelope enforcement, but make coverage a clearly separated phase after Validate.\n\n[Deliverables]\n- New module encapsulating coverage orchestration and hooks.\n- executePipeline updated to call this module when coverage is enabled, with no behavior change visible to existing tests or CLI.\n\n[Definition of Done]\n- All existing tests involving coverage (core, e2e, CLI) pass unchanged.\n- New tests validate that the coverage runtime API is stable and enforces the same invariants as before (gating, determinism, thresholds, reportMode).",
        "testStrategy": "Add unit tests for the new coverage runtime module with synthetic inputs (CoverageTargets, generator items, coverage options) to assert metrics, report arrays and unsatisfiedHints wiring. Extend pipeline-orchestrator tests to confirm that executePipeline status, stages and artifacts (including coverageReport and coverageMetrics) remain identical before/after refactor. Run existing coverage e2e and CLI tests to ensure no regressions.",
        "subtasks": [
          {
            "id": 9331001,
            "title": "Introduce coverage runtime helper module",
            "description": "Create a new internal module that encapsulates calling analyzeCoverage, resolveCoveragePlannerConfig, planTestUnits, accumulate coverage events, evaluateCoverage and building coverage-report/v1.",
            "status": "done",
            "estimatedHours": 5,
            "file": "packages/core/src/coverage/runtime.ts",
            "parentId": "9331",
            "updatedAt": "2025-11-30T17:25:30.727Z"
          },
          {
            "id": 9331002,
            "title": "Refactor executePipeline to use coverage runtime",
            "description": "Replace inline coverage wiring in orchestrator.ts with a call to the coverage runtime, maintaining gating, hooks and artifacts shape.",
            "status": "done",
            "estimatedHours": 4,
            "file": "packages/core/src/pipeline/orchestrator.ts",
            "parentId": "9331",
            "updatedAt": "2025-11-30T17:25:33.835Z"
          },
          {
            "id": 9331003,
            "title": "Add tests for coverage runtime wiring",
            "description": "Add focused tests that drive executePipeline with coverage on/off and assert that coverageTargets, coverageMetrics and coverageReport match snapshot expectations and prior behavior.",
            "status": "done",
            "estimatedHours": 3,
            "file": "packages/core/src/pipeline/tests/pipeline-orchestrator.test.ts",
            "parentId": "9331",
            "updatedAt": "2025-11-30T17:25:36.499Z"
          }
        ],
        "updatedAt": "2025-11-30T17:25:36.499Z"
      },
      {
        "id": 9332,
        "title": "Refine boundaries and operations coverage model",
        "description": "Consolidate and extend the coverage model for boundaries and operations dimensions so that target materialization, IDs and diagnostics match the coverage-aware spec and remain scalable.",
        "priority": "medium",
        "estimatedHours": 16,
        "dependencies": [
          "9301",
          "9303",
          "9309",
          "9310"
        ],
        "status": "done",
        "complexityScore": 5,
        "details": "[Context]\nBoundaries (numeric/string/array) and operations coverage (OpenAPI operations, SCHEMA_REUSED_COVERED) are implemented but need a tighter contract for semantics, volumetry and diagnostics. The spec requires precise target shapes, deterministic IDs and clear diagnostic-only behavior for SCHEMA_REUSED_COVERED.\n\n[Key requirements]\n- Precisely document and implement which combinations of min/max/exclusive*, minLength/maxLength and minItems/maxItems map to NUMERIC_, STRING_ and ARRAY_* boundary targets, with deterministic IDs and limited volumetry.\n- For operations: ensure operation nodes and edges cover realistic OpenAPI patterns (multiple responses, components refs, request-only or response-only operations). SCHEMA_REUSED_COVERED targets must always be diagnostic-only (status:'deprecated') and excluded from metrics.\n- Extend tests to cover boundary/operations target IDs stability and diff behavior when toggling dimensionsEnabled, ensuring non-operations/non-boundaries targets keep identical IDs.\n\n[Deliverables]\n- Clarified boundary materialization logic and tests in analyzer and generator.\n- Enhanced OpenAPI coverage analyzer handling for additional request/response patterns and SCHEMA_REUSED_COVERED behavior.\n- Tests for ID stability and metrics correctness across dimensions projections.\n\n[Definition of Done]\n- Boundary and operations targets have a documented mapping from schema/OpenAPI patterns to target kinds and params.\n- SCHEMA_REUSED_COVERED is always status:'deprecated' and never influences metrics.overall/byDimension/byOperation or thresholds.\n- ID stability tests pass when toggling boundaries/operations in dimensionsEnabled.",
        "testStrategy": "In analyzer tests, add cases for multiple numeric, string and array boundary combinations and assert which targets are materialized and with which params. In generator tests, verify that boundary hit events toggle hit flags as expected without affecting RNG decisions. In OpenAPI analyzer tests, add scenarios with multiple content types, multiple responses and shared component schemas, and verify operation nodes, edges and SCHEMA_REUSED_COVERED targets. Extend diff and evaluator tests to check that turning operations/boundaries on/off in dimensionsEnabled preserves IDs for other dimensions.",
        "subtasks": [
          {
            "id": 9332001,
            "title": "Clarify boundaries target semantics and tests",
            "description": "Refine boundaries target creation (numeric, string, array) and add tests to pin the mapping between schema constraints and NUMERIC_/STRING_/ARRAY_* targets, including mixed min/max and exclusive* cases.",
            "status": "done",
            "estimatedHours": 6,
            "file": "packages/core/src/coverage/analyzer.ts",
            "parentId": "9332",
            "updatedAt": "2025-11-30T15:52:08.691Z"
          },
          {
            "id": 9332002,
            "title": "Harden operations dimension and SCHEMA_REUSED_COVERED behavior",
            "description": "Extend coverage-analyzer-openapi to handle richer OpenAPI patterns and add tests ensuring operation-level targets and SCHEMA_REUSED_COVERED entries behave exactly as specified and remain diagnostic-only.",
            "status": "done",
            "estimatedHours": 6,
            "file": "packages/core/src/coverage/coverage-analyzer-openapi.ts",
            "parentId": "9332",
            "updatedAt": "2025-11-30T15:55:35.595Z"
          },
          {
            "id": 9332003,
            "title": "Validate ID stability and diff for boundaries/operations",
            "description": "Add tests around coverage ID generation and diff that confirm toggling boundaries/operations in dimensionsEnabled does not change IDs of targets in other dimensions and that diff remains compatible across reports.",
            "status": "done",
            "estimatedHours": 4,
            "file": "packages/core/src/coverage/tests/coverage-diff.spec.ts",
            "parentId": "9332",
            "updatedAt": "2025-11-30T15:59:53.853Z"
          }
        ],
        "updatedAt": "2025-11-30T15:59:53.853Z"
      },
      {
        "id": 9333,
        "title": "Harden CLI coverage profiles and coverage-report UX",
        "description": "Make coverage profiles (quick/balanced/thorough), CLI flags and coverage-summary output strictly conform to the coverage-aware spec, with black-box tests driving the CLI and mapping precisely to coverage-report/v1.",
        "priority": "medium",
        "estimatedHours": 14,
        "dependencies": [
          "9302",
          "9303",
          "9322",
          "9323",
          "9324"
        ],
        "status": "done",
        "complexityScore": 4,
        "details": "[Context]\nThe CLI exposes coverage through profiles, dimensions flags and a stderr summary, while coverage-report/v1 provides the canonical machine-readable view. To support platform integration and CI, these layers must be tightly aligned and tested end-to-end.\n\n[Key requirements]\n- For each profile quick/balanced/thorough, formalize and test the effective dimensionsEnabled, maxInstances recommendation and planner caps, ensuring they match the spec narrative.\n- Add CLI-level tests that run foundrydata generate/openapi with different coverage modes and profiles, then assert the coverage summary is a faithful projection of coverage-report/v1 (dimensions, operations, overall, targetsByStatus, caps, unsatisfiedHints counts).\n- Provide a documented “recommended CI profile” using coverage=measure + a specific profile and minCoverage, with examples based on coverage-report/v1.\n\n[Deliverables]\n- Strengthened resolveCliCoverageOptions behavior with tests encoding profile semantics and error handling.\n- CLI tests validating coverage summary and coverage-report/v1 alignment for generate and openapi.\n- Updated docs describing profiles, flags and coverage-report fields as a coherent UX.\n\n[Definition of Done]\n- Changing profile or flags has well-specified, tested effects on coverage options and reported metrics.\n- CLI coverage summary is demonstrably derived from coverage-report/v1 for all covered scenarios.",
        "testStrategy": "In coverage-options tests, assert for each profile the exact dimensionsEnabled, planner caps and recommendedMaxInstances. In CLI index tests, run foundrydata generate/openapi on small schemas with coverage=measure and different profiles, then parse stderr summary and the written coverage-report/v1 file to check consistency of metrics, targetsByStatus, caps count and unsatisfiedHints count. Update docs examples to mirror these tests and avoid drift.",
        "subtasks": [
          {
            "id": 9333001,
            "title": "Pin CLI coverage profile semantics with tests",
            "description": "Add tests for quick/balanced/thorough in resolveCliCoverageOptions to enforce dimensions, caps and recommendedMaxInstances as per spec, including error handling for invalid flags.",
            "status": "done",
            "estimatedHours": 5,
            "file": "packages/cli/src/config/coverage-options.ts",
            "parentId": "9333",
            "updatedAt": "2025-11-30T17:56:00.997Z"
          },
          {
            "id": 9333002,
            "title": "Align CLI coverage summary with coverage-report/v1",
            "description": "Extend CLI tests so that coverage summary lines are compared against coverage-report/v1 metrics and diagnostics for both generate and openapi flows.",
            "status": "done",
            "estimatedHours": 5,
            "file": "packages/cli/src/index.test.ts",
            "parentId": "9333",
            "updatedAt": "2025-11-30T17:56:02.564Z"
          },
          {
            "id": 9333003,
            "title": "Document recommended CI profile and report reading",
            "description": "Update docs to describe a recommended CI configuration (coverage mode/profile/minCoverage) and how to interpret coverage-report/v1 and CLI output in that context.",
            "status": "done",
            "estimatedHours": 4,
            "file": "docs/Features.md",
            "parentId": "9333",
            "updatedAt": "2025-11-30T18:18:37.222Z"
          }
        ],
        "updatedAt": "2025-11-30T18:18:37.222Z"
      },
      {
        "id": 9334,
        "title": "Define coverage-report/v1 JSON schema and compatibility guards",
        "description": "Introduce a formal JSON Schema for coverage-report/v1 and add compatibility tests so that future changes remain backward compatible and spec-compliant.",
        "priority": "medium",
        "estimatedHours": 12,
        "dependencies": [
          "9303",
          "9323"
        ],
        "status": "done",
        "complexityScore": 4,
        "details": "[Context]\nCoverage-report/v1 is the contract between the engine, CLI, reporter and external consumers. A formal JSON Schema and compatibility checks are needed to keep this contract stable as new fields or dimensions are added.\n\n[Key requirements]\n- Define a JSON Schema for coverage-report/v1 that matches the shared CoverageReport types and coverage-aware spec (including engine/run headers, metrics, targets, uncoveredTargets, unsatisfiedHints and diagnostics).\n- Validate generated coverage reports against this schema in tests (and optionally in a debug-only assertion path) to catch regressions early.\n- Extend coverage diff tests to ensure older reports continue to be accepted and that new fields are treated in a backward-compatible way.\n\n[Deliverables]\n- coverage-report/v1 JSON Schema file checked into the repo (either under docs or reporter package).\n- Reporter/core tests that validate sample reports against the schema.\n- Extended diff tests for compatibility between baseline and newer reports.\n\n[Definition of Done]\n- All tests generating coverage-report/v1 validate the JSON output against the new schema.\n- Compatibility tests cover cross-version diffs and ensure new fields do not break existing consumers.",
        "testStrategy": "Create a JSON Schema for coverage-report/v1 and add tests in reporter/core that load representative reports (from unit/e2e tests) and validate them via AJV. Extend coverage-report JSON tests to ensure required fields remain present and optional fields are handled gracefully. In coverage diff tests, add fixtures representing older reports and assert that diffCoverageReports can compare them to newer ones without errors and with stable compatibility diagnostics.",
        "subtasks": [
          {
            "id": 9334001,
            "title": "Define coverage-report/v1 JSON Schema",
            "description": "Author a JSON Schema describing coverage-report/v1 that matches @foundrydata/shared CoverageReport types and the coverage-aware spec.",
            "status": "done",
            "estimatedHours": 4,
            "file": "packages/reporter/src/schemas/coverage-report-v1.schema.json",
            "parentId": "9334",
            "updatedAt": "2025-11-30T16:06:45.650Z"
          },
          {
            "id": 9334002,
            "title": "Validate generated reports against the schema in tests",
            "description": "Add tests that validate coverage-report/v1 instances from core and CLI runs against the new JSON Schema using AJV.",
            "status": "done",
            "estimatedHours": 4,
            "file": "packages/core/src/coverage/tests/coverage-report-json.test.ts",
            "parentId": "9334",
            "updatedAt": "2025-11-30T16:43:43.810Z"
          },
          {
            "id": 9334003,
            "title": "Extend coverage diff compatibility tests",
            "description": "Add fixtures and tests to check compatibility between old and new coverage-report/v1 files, ensuring diffCoverageReports remains stable and reports compatibility issues explicitly.",
            "status": "done",
            "estimatedHours": 4,
            "file": "packages/core/src/coverage/tests/coverage-diff.spec.ts",
            "parentId": "9334",
            "updatedAt": "2025-11-30T16:54:43.778Z"
          }
        ],
        "updatedAt": "2025-11-30T16:54:43.778Z"
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-11-30T18:18:37.223Z",
      "taskCount": 26,
      "completedCount": 26,
      "tags": [
        "coverage-aware-v1"
      ],
      "created": "2025-12-02T22:38:18.337Z",
      "description": "Tasks for coverage-aware-v1 context",
      "updated": "2025-12-02T22:38:18.337Z"
    }
  },
  "generator-vs-repair-contract": {
    "tasks": [
      {
        "id": "9400",
        "title": "Formalize Generator vs Repair contract and G_valid v1 in canonical spec",
        "description": "Introduce the Generator vs Repair contract and the G_valid (Generator-valid) zone into the canonical SPEC.",
        "priority": "high",
        "estimatedHours": 10,
        "dependencies": [],
        "status": "done",
        "complexityScore": 3,
        "details": "[Context]\nThe canonical spec and architecture describe the 5-stage pipeline but leave the Generator vs Repair boundary implicit.\nAligns with spec §6 (High-Level Architecture), §9 (Generator) and §10 (Repair Engine), and introduces a new subsection under §6 for the Generator / Repair contract and generator-valid zone (G_valid).\n\n[Key requirements]\n- Add a normative \"Generator vs Repair contract\" subsection to the generator/repair sections.\n- Define G_valid v1 scope (simple objects, simple arrays with items+contains, no AP:false/unevaluated* interplay) and the meaning of \"AJV-valid by construction\" (structural validity with only numeric/format nudges left to Repair).\n- State explicitly that outside G_valid the existing \"minimal witness + bounded Repair\" regime remains in force.\n- Document the UUID + contains example as a reference motif.\n\n[Deliverables]\n- Updated docs/spec-canonical-json-schema-generator.md (spec §6/§9/§10), ARCHITECTURE.md and Invariants/Known-Limits with the new contract.",
        "testStrategy": "- Spec review checklist covering: presence of the new section, correct G_valid v1 scope, explicit description of allowed/forbidden Repair actions.\n- Consistency pass between canonical spec, ARCHITECTURE.md, COMPREHENSIVE_FEATURE_SUPPORT.md and Invariants.md.\n- Internal review with generator/repair owners to confirm the wording matches what can be implemented without breaking existing invariants.",
        "subtasks": [
          {
            "id": 9400001,
            "title": "Add Generator vs Repair contract and G_valid section to canonical spec",
            "description": "Draft the new section in docs/spec-canonical-json-schema-generator.md and link it from the Generator (spec §9) and Repair (spec §10) chapters.",
            "status": "done",
            "estimatedHours": 4,
            "file": "docs/spec-canonical-json-schema-generator.md",
            "parentId": "9400",
            "updatedAt": "2025-12-03T19:27:40.375Z"
          },
          {
            "id": 9400002,
            "title": "Align ARCHITECTURE.md with the new contract",
            "description": "Update ARCHITECTURE.md so that the Generate and Repair stage descriptions explicitly reference the Generator vs Repair contract and G_valid zones (spec §6 overview, §6.x new subsection).",
            "status": "done",
            "estimatedHours": 2,
            "file": "ARCHITECTURE.md",
            "parentId": "9400",
            "updatedAt": "2025-12-03T19:27:46.409Z"
          },
          {
            "id": 9400003,
            "title": "Extend invariants and known limits with G_valid guarantees",
            "description": "Add a short list of G_valid invariants and non-goals to Invariants.md and Known-Limits.md, including what Repair is allowed to do inside G_valid zones, referencing spec §6.4–§6.6.",
            "status": "done",
            "estimatedHours": 2,
            "file": "Invariants.md",
            "parentId": "9400",
            "updatedAt": "2025-12-03T19:27:53.949Z"
          },
          {
            "id": 9400004,
            "title": "Document UUID + contains pattern as reference example",
            "description": "Write a self-contained example for the UUID + contains pattern that illustrates the change from minimal-witness generation with Repair filling required fields to G_valid generation where the Generator produces a fully valid item, aligned with spec §6.3.2.",
            "status": "done",
            "estimatedHours": 2,
            "file": "docs/examples/g-valid-uuid-contains.md",
            "parentId": "9400",
            "updatedAt": "2025-12-03T19:27:59.172Z"
          }
        ],
        "updatedAt": "2025-12-03T19:27:59.172Z"
      },
      {
        "id": "9401",
        "title": "Implement motif classification and G_valid zoning in core pipeline",
        "description": "Introduce a motif classification layer that marks schema locations as G_valid or non-G_valid based on the effective schema shape.",
        "priority": "high",
        "estimatedHours": 16,
        "dependencies": [
          "9400"
        ],
        "status": "in-progress",
        "complexityScore": 4,
        "details": "[Context]\nTo enforce the contract only where safe, the engine must classify schema locations into G_valid vs non-G_valid motifs using the Compose effective view.\nAligns with spec §6.3–§6.5 (Generator / Repair contract and G_valid v1) and §8 (Compose / effective view) as sources of truth for classification inputs.\n\n[Key requirements]\n- Define an internal motif enum/tag (e.g. \"simple-object-required\", \"array-items-contains-simple\", \"ap-false-must-cover\", \"complex-contains\", etc.) plus a boolean G_valid flag.\n- Implement a classifier over canonical/Compose artifacts that marks each canonPath with motif + G_valid, without re-parsing the original schema.\n- Respect v1 exclusions (AP:false + CoverageIndex, unevaluated*, complex contains bags, deep conditionals) per spec §6.3.\n- Expose motif info to generator, repair and metrics via a cheap lookup in the execution context.\n- Add a planOptions/feature flag to disable G_valid classification/enforcement for compatibility.",
        "testStrategy": "- Unit tests that feed canonical schemas + Compose outputs and assert motif + G_valid classification per canonPath.\n- Edge-case tests for AP:false + propertyNames/patternProperties, unevaluatedProperties/unevaluatedItems and multi-contains bags.\n- Stability tests showing classification is deterministic for fixed inputs and insensitive to allOf branch ordering.\n- Smoke tests proving that when the feature flag is off, pipeline behavior matches the current baseline.",
        "subtasks": [
          {
            "id": 9401001,
            "title": "Design G_valid motif types and internal API",
            "description": "Define motif and G_valid state types plus helpers (e.g. isGValidSimpleObject, isGValidArrayContains) to be used by generator, repair and metrics, consistent with spec §6.3.",
            "status": "done",
            "estimatedHours": 4,
            "file": "packages/core/src/transform/g-valid-classifier.ts",
            "parentId": "9401",
            "updatedAt": "2025-12-03T19:32:28.229Z"
          },
          {
            "id": 9401002,
            "title": "Implement classifier over Compose artifacts",
            "description": "Implement the classifier using canonical schema, CoverageIndex and Compose diagnostics to mark canonPaths as G_valid or non-G_valid without re-parsing the original schema, aligned with spec §8 and §6.3.",
            "status": "done",
            "estimatedHours": 6,
            "file": "packages/core/src/transform/g-valid-classifier.ts",
            "parentId": "9401",
            "updatedAt": "2025-12-03T19:41:24.073Z"
          },
          {
            "id": 9401003,
            "title": "Wire classifier into generator and repair planning",
            "description": "Expose G_valid motif lookup to generator and repair (e.g. via plan context or per-path metadata) so they can adjust behavior inside G_valid zones, per spec §6.4–§6.5.",
            "status": "pending",
            "estimatedHours": 3,
            "file": "packages/core/src/pipeline/orchestrator.ts",
            "parentId": "9401",
            "updatedAt": "2025-12-02T23:00:00.000Z"
          },
          {
            "id": 9401004,
            "title": "Add tests for motif classification",
            "description": "Create tests that exercise classification for simple objects, arrays with items+contains, AP:false + CoverageIndex cases and unevaluatedProperties/unevaluatedItems, asserting expected G_valid flags according to spec §6.3.",
            "status": "pending",
            "estimatedHours": 3,
            "file": "packages/core/src/transform/**tests**/g-valid-classifier.spec.ts",
            "parentId": "9401",
            "updatedAt": "2025-12-02T23:00:00.000Z"
          }
        ],
        "updatedAt": "2025-12-03T19:41:24.073Z"
      },
      {
        "id": "9402",
        "title": "Make array generation G_valid-aware for items + contains motifs",
        "description": "Update array generation so that, in G_valid zones, items satisfying contains also respect the effective items schema and are AJV-valid by construction.",
        "priority": "high",
        "estimatedHours": 18,
        "dependencies": [
          "9401"
        ],
        "status": "pending",
        "complexityScore": 4,
        "details": "[Context]\nThe current array generator enforces contains bags but may emit minimal witnesses that rely on Repair to fill required fields. In G_valid arrays (simple items + contains, no AP:false/unevaluated*), the Generator must produce elements that satisfy both items and contains subschemas without structural Repair.\nAligns with spec §6.3.2 (arrays with simple items+contains in G_valid) and §9 (Generator obligations in G_valid zones).\n\n[Key requirements]\n- For canonPaths marked G_valid with items + contains:\n  - generate targeted elements against the effective items schema AND the contains subschema,\n  - ensure required properties and referenced shapes in items are satisfied by the Generator.\n- Preserve existing behavior for non-G_valid motifs (AP:false, complex bags, heavy uniqueItems).\n- Keep determinism and existing contains diagnostics/caps (e.g. CONTAINS_BAG_COMBINED, CONTAINS_UNSAT_BY_SUM) as described in spec §8/§9.",
        "testStrategy": "- Unit tests for G_valid array schemas asserting that generated elements already satisfy required properties and refs before Repair.\n- Fixtures including the UUID + contains pattern and golden snapshots comparing pre/post behavior.\n- Integration tests verifying that non-G_valid arrays keep identical behavior and diagnostics to the baseline.\n- Property-style tests comparing AJV validity before/after changes to ensure no regressions and preserved determinism for non-G_valid motifs.",
        "subtasks": [
          {
            "id": 9402001,
            "title": "Plumb G_valid hints into array generation paths",
            "description": "Inject G_valid motif information into array generation code paths to select between G_valid and legacy strategies, respecting spec §6.4 and §9 deterministic behavior.",
            "status": "pending",
            "estimatedHours": 4,
            "file": "packages/core/src/generator/foundry-generator.ts",
            "parentId": "9402",
            "updatedAt": "2025-12-02T23:00:00.000Z"
          },
          {
            "id": 9402002,
            "title": "Implement combined items + contains generation for G_valid arrays",
            "description": "Implement logic that, for G_valid arrays, generates elements satisfying both the effective items schema and the contains subschema, reusing existing planning/composition outputs and honoring spec §6.3.2.",
            "status": "pending",
            "estimatedHours": 8,
            "file": "packages/core/src/generator/foundry-generator.ts",
            "parentId": "9402",
            "updatedAt": "2025-12-02T23:00:00.000Z"
          },
          {
            "id": 9402003,
            "title": "Add fixtures for G_valid array motifs",
            "description": "Create fixtures capturing UUID + contains and other simple array motifs to validate G_valid behavior as defined in spec §6.3.2.",
            "status": "pending",
            "estimatedHours": 3,
            "file": "packages/core/src/generator/**tests**/fixtures/g-valid-arrays.json",
            "parentId": "9402",
            "updatedAt": "2025-12-02T23:00:00.000Z"
          },
          {
            "id": 9402004,
            "title": "Write tests for G_valid arrays and golden snapshots",
            "description": "Add tests asserting that structural Repair is unused for G_valid arrays and that non-G_valid arrays preserve previous behavior, per spec §6.4–§6.5.",
            "status": "pending",
            "estimatedHours": 3,
            "file": "packages/core/src/generator/**tests**/g-valid-arrays.spec.ts",
            "parentId": "9402",
            "updatedAt": "2025-12-02T23:00:00.000Z"
          }
        ],
        "updatedAt": "2025-12-02T23:00:00.000Z"
      },
      {
        "id": "9403",
        "title": "Make object generation G_valid-aware for simple required/properties motifs",
        "description": "Adjust object generation so that, in G_valid zones, the Generator satisfies required properties and basic bounds without relying on Repair to synthesize placeholder values.",
        "priority": "high",
        "estimatedHours": 16,
        "dependencies": [
          "9401"
        ],
        "status": "pending",
        "complexityScore": 4,
        "details": "[Context]\nFor simple objects without AP:false/unevaluated* and with clear properties/required constraints, the Generator should produce AJV-valid instances on its own, leaving only numeric/format tweaks to Repair.\nAligns with spec §6.3.1 (objects without hard evaluation guards) and §9 (Generator obligations).\n\n[Key requirements]\n- For objects marked G_valid:\n  - always emit all required properties from the effective schema,\n  - respect basic type/enum/const bounds using existing helpers,\n  - avoid depending on Repair to create whole sub-objects or required scalars.\n- Leave behavior unchanged for AP:false, unevaluated* or complex conditional motifs.\n- Preserve determinism for non-G_valid objects as mandated by spec §3 and §9.",
        "testStrategy": "- Unit tests on simple object fixtures asserting that G_valid objects contain all required properties with non-empty values before Repair.\n- Integration tests mixing G_valid and non-G_valid objects to verify that only G_valid ones change behavior and still pass AJV, while others keep baseline behavior.\n- Negative tests with intentionally unsatisfiable schemas to confirm diagnostics remain clear and consistent.",
        "subtasks": [
          {
            "id": 9403001,
            "title": "Wire G_valid hints into object generation paths",
            "description": "Inject G_valid motif information into object generation routines to choose between G_valid and legacy minimal-witness strategies, following spec §6.4.",
            "status": "pending",
            "estimatedHours": 4,
            "file": "packages/core/src/generator/foundry-generator.ts",
            "parentId": "9403",
            "updatedAt": "2025-12-02T23:00:00.000Z"
          },
          {
            "id": 9403002,
            "title": "Implement minimal-but-valid object construction for G_valid motifs",
            "description": "Implement logic ensuring all required properties and basic constraints are satisfied for G_valid objects, reusing existing rational/enum helpers, consistent with spec §6.3.1 and §9.",
            "status": "pending",
            "estimatedHours": 8,
            "file": "packages/core/src/generator/foundry-generator.ts",
            "parentId": "9403",
            "updatedAt": "2025-12-02T23:00:00.000Z"
          },
          {
            "id": 9403003,
            "title": "Add fixtures and tests for G_valid objects",
            "description": "Create schemas and tests that verify G_valid object behavior (including nested required properties) while AP:false/unevaluated* cases remain unchanged, per spec §6.3.1.",
            "status": "pending",
            "estimatedHours": 4,
            "file": "packages/core/src/generator/**tests**/g-valid-objects.spec.ts",
            "parentId": "9403",
            "updatedAt": "2025-12-02T23:00:00.000Z"
          }
        ],
        "updatedAt": "2025-12-02T23:00:00.000Z"
      },
      {
        "id": "9404",
        "title": "Constrain Repair behavior inside G_valid zones and surface violations",
        "description": "Update the Repair engine so that structural fixes in G_valid zones are treated as contract violations and surfaced via diagnostics/metrics instead of normal behavior.",
        "priority": "high",
        "estimatedHours": 14,
        "dependencies": [
          "9401",
          "9402",
          "9403"
        ],
        "status": "pending",
        "complexityScore": 4,
        "details": "[Context]\nToday Repair may synthesize required fields or empty objects/arrays when AJV reports gaps. Inside G_valid zones, this should be exceptional and visible, not routine.\nAligns with spec §6.4–§6.5 (Repair obligations and limits in G_valid) and §10 (Repair Engine mapping and budgets).\n\n[Key requirements]\n- Consume G_valid motif information in Repair so actions can branch on per-path G_valid state.\n- In G_valid zones, prevent or strongly discourage structural actions (adding required props, synthesizing sub-objects/arrays); when needed, emit explicit diagnostics and count them.\n- Keep non-structural actions (numeric nudges, uniqueItems de-duplication) allowed as in spec §6.5.\n- Preserve current behavior and diagnostics for non-G_valid locations, including budgets and UNSAT_BUDGET_EXHAUSTED.\n- Provide a feature flag to relax G_valid constraints for compatibility/debugging.",
        "testStrategy": "- Unit tests simulating AJV errors on G_valid paths that require structural fixes, asserting that Repair either rejects them with diagnostics or marks them as contract violations.\n- Tests verifying that numeric/format tweaks and uniqueItems de-duplication still run in G_valid zones.\n- Integration tests on G_valid schemas confirming that structural Repair is not used in nominal cases and that non-G_valid schemas preserve baseline behavior.\n- Tests for the feature flag toggling G_valid constraints without breaking determinism.",
        "subtasks": [
          {
            "id": 9404001,
            "title": "Wire G_valid motif information into Repair engine",
            "description": "Plumb G_valid motif metadata into repair-engine.ts so Repair actions can branch on per-path G_valid state, according to spec §6.4–§6.5.",
            "status": "pending",
            "estimatedHours": 4,
            "file": "packages/core/src/repair/repair-engine.ts",
            "parentId": "9404",
            "updatedAt": "2025-12-02T23:00:00.000Z"
          },
          {
            "id": 9404002,
            "title": "Restrict structural Repair actions in G_valid zones",
            "description": "Update the (keyword → action) registry to avoid structural additions/removals on G_valid paths and introduce diagnostics when such actions would be required, following spec §6.5 and §10.",
            "status": "pending",
            "estimatedHours": 6,
            "file": "packages/core/src/repair/repair-engine.ts",
            "parentId": "9404",
            "updatedAt": "2025-12-02T23:00:00.000Z"
          },
          {
            "id": 9404003,
            "title": "Add tests and diagnostics for G_valid Repair violations",
            "description": "Define diagnostics for G_valid Repair violations, update diag schemas and add tests asserting they are emitted under simulated contract breaches, aligned with spec §6.5 and §15/§20 for test gates.",
            "status": "pending",
            "estimatedHours": 4,
            "file": "packages/core/src/repair/**tests**/g-valid-repair.spec.ts",
            "parentId": "9404",
            "updatedAt": "2025-12-02T23:00:00.000Z"
          }
        ],
        "updatedAt": "2025-12-02T23:00:00.000Z"
      },
      {
        "id": "9405",
        "title": "Add repair usage metrics and G_valid motif observability",
        "description": "Instrument the pipeline with motif-level metrics so that repair usage inside and outside G_valid zones is observable and testable.",
        "priority": "high",
        "estimatedHours": 20,
        "dependencies": [
          "9401",
          "9402",
          "9403",
          "9404"
        ],
        "status": "pending",
        "complexityScore": 4,
        "details": "[Context]\nThe brief requires that the Generator/Repair boundary be observable. G_valid zones should exhibit little or no structural Repair, and any drift must be visible in metrics and tests.\nAligns with spec §6.6 (Metrics and testing for G_valid) and with existing metrics sections (§15/§20) for integration into the current metrics model.\n\n[Key requirements]\n- Define a metrics model for repair usage per motif (motif id, items, itemsWithRepair, actions, G_valid flag) and integrate it into existing metrics.\n- Tag Repair actions with canonPath + motif + G_valid and aggregate them at run end.\n- Surface aggregated metrics through existing metrics snapshots and optionally diagnostics/logs.\n- Add e2e tests for micro-schemas explicitly labeled as G_valid that assert structural Repair counts are zero (or within a small numeric-only allowance).\n- Update tests-traceability docs with a new \"Generator-valid zone\" motif family and its invariants, referencing spec §6.6.",
        "testStrategy": "- Unit tests for metrics aggregation ensuring per-motif counters are incremented and grouped correctly by G_valid flag.\n- Integration tests running the full pipeline on pure G_valid and mixed schemas, verifying that structural Repair counts for G_valid motifs are zero in nominal cases.\n- Golden tests on metrics snapshots to detect regressions in Repair usage over time.\n- Documentation/tests-traceability checks confirming that the new motif family and invariants are documented.",
        "subtasks": [
          {
            "id": 9405001,
            "title": "Define repair usage metrics model by motif and G_valid flag",
            "description": "Design types for motif-level repair usage metrics and integrate them into the existing metrics model, aligned with spec §6.6 and existing metrics sections (§15/§20).",
            "status": "pending",
            "estimatedHours": 5,
            "file": "packages/core/src/util/metrics.ts",
            "parentId": "9405",
            "updatedAt": "2025-12-02T23:00:00.000Z"
          },
          {
            "id": 9405002,
            "title": "Instrument Repair to emit motif-tagged usage events",
            "description": "Emit lightweight events or counters from Repair whenever an action is applied, tagged with canonPath, motif and G_valid flag, and feed them into the new metrics model per spec §6.6.",
            "status": "pending",
            "estimatedHours": 7,
            "file": "packages/core/src/repair/repair-engine.ts",
            "parentId": "9405",
            "updatedAt": "2025-12-02T23:00:00.000Z"
          },
          {
            "id": 9405003,
            "title": "Aggregate and expose repair usage metrics in pipeline orchestrator",
            "description": "Wire repair usage metrics into the pipeline orchestrator so they are aggregated per run and exposed with existing timing/validation metrics, consistent with spec §15/§20.",
            "status": "pending",
            "estimatedHours": 4,
            "file": "packages/core/src/pipeline/orchestrator.ts",
            "parentId": "9405",
            "updatedAt": "2025-12-02T23:00:00.000Z"
          },
          {
            "id": 9405004,
            "title": "Add G_valid no-repair e2e tests and traceability entries",
            "description": "Create end-to-end tests and update tests-traceability documentation for G_valid micro-schemas asserting that structural Repair is unused, per spec §6.6–§6.7.",
            "status": "pending",
            "estimatedHours": 4,
            "file": "packages/core/test/e2e/g-valid-no-repair.spec.ts",
            "parentId": "9405",
            "updatedAt": "2025-12-02T23:00:00.000Z"
          }
        ],
        "updatedAt": "2025-12-02T23:00:00.000Z"
      },
      {
        "id": "9406",
        "title": "Expose G_valid behavior and Generator vs Repair contract in CLI, profiles and docs",
        "description": "Surface the Generator vs Repair contract and G_valid behavior through PlanOptions, CLI profiles and developer documentation.",
        "priority": "medium",
        "estimatedHours": 12,
        "dependencies": [
          "9400",
          "9401",
          "9402",
          "9403",
          "9404",
          "9405"
        ],
        "status": "pending",
        "complexityScore": 3,
        "details": "[Context]\nOnce implemented, G_valid and the tightened Generator vs Repair contract must be discoverable and controllable through configuration and docs.\nAligns with spec §6.7 (Interaction with other sections / public behavior) and the general configuration sections that describe PlanOptions and CLI flags.\n\n[Key requirements]\n- Add PlanOptions knobs (and Node API mapping) for enabling/disabling G_valid classification/enforcement and controlling strictness of Repair inside G_valid zones.\n- Wire these options through CLI flags and profiles, with defaults that preserve current behavior when G_valid is off.\n- Update COMPREHENSIVE_FEATURE_SUPPORT/Features/docs to explain the contract, G_valid scope, and how to interpret repair usage metrics.",
        "testStrategy": "- Unit tests for PlanOptions parsing and CLI flags, asserting correct mapping and backward-compatible defaults.\n- Integration tests running CLI/Node API with different G_valid configurations and checking that Generator/Repair/metrics behavior matches expectations.\n- Documentation checks confirming that new options and the contract are mentioned consistently in feature docs and examples.",
        "subtasks": [
          {
            "id": 9406001,
            "title": "Add G_valid-related options to PlanOptions and core API",
            "description": "Extend PlanOptions and core API types with fields controlling G_valid classification/enforcement and map them into pipeline context, consistent with spec §6.7.",
            "status": "pending",
            "estimatedHours": 4,
            "file": "packages/core/src/api.ts",
            "parentId": "9406",
            "updatedAt": "2025-12-02T23:00:00.000Z"
          },
          {
            "id": 9406002,
            "title": "Wire G_valid options through CLI flags and profiles",
            "description": "Map new G_valid options into CLI flags and profiles, defining which profiles enable G_valid by default and how to turn it off for compatibility.",
            "status": "pending",
            "estimatedHours": 4,
            "file": "packages/cli/src/commands/generate.ts",
            "parentId": "9406",
            "updatedAt": "2025-12-02T23:00:00.000Z"
          },
          {
            "id": 9406003,
            "title": "Update feature and usage docs with G_valid guidance",
            "description": "Document G_valid behavior, options and typical usage scenarios in COMPREHENSIVE_FEATURE_SUPPORT, Features and examples docs, referencing spec §6 and the Generator vs Repair contract subsection.",
            "status": "pending",
            "estimatedHours": 4,
            "file": "docs/COMPREHENSIVE_FEATURE_SUPPORT.md",
            "parentId": "9406",
            "updatedAt": "2025-12-02T23:00:00.000Z"
          }
        ],
        "updatedAt": "2025-12-02T23:00:00.000Z"
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-12-03T19:41:24.074Z",
      "taskCount": 7,
      "completedCount": 1,
      "tags": [
        "generator-vs-repair-contract"
      ]
    }
  }
}
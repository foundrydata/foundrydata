{
  "project": "FoundryData",
  "version": "0.1.0-mvp",
  "approach": "Hybrid (Task Master structure + granular subtasks)",
  "coverage-aware-v1": {
    "tasks": [
      {
        "id": "9300",
        "title": "Define coverage core types and ID semantics",
        "description": "Introduce CoverageTarget, CoverageGraph and related types with deterministic, stable IDs for coverage-aware runs.",
        "priority": "high",
        "estimatedHours": 10,
        "dependencies": [],
        "status": "done",
        "complexityScore": 3,
        "details": "[Context]\nDefine the core coverage model for FoundryData, including CoverageTarget, CoverageTargetReport and CoverageGraph nodes and dimensions. Align with the coverage-aware spec §3 (Coverage model) and §3.2 (CoverageTargets), and ensure IDs are stable across runs and independent of dimensionsEnabled.\n\n[Key requirements]\n- Design CoverageTarget, CoverageTargetReport and CoverageGraph types that can represent structure, branches, enum values, boundaries and operation-linked nodes.\n- Introduce a canonical CoverageDimension union used consistently in core and shared packages: type CoverageDimension = 'structure' | 'branches' | 'enum' | 'boundaries' | 'operations'; and reuse it for CoverageTarget.dimension, run.dimensionsEnabled and metrics.byDimension keys.\n- Define a deterministic, canonical ID scheme for CoverageTarget.id that only depends on canonical schema, optional OpenAPI mapping, FoundryData major version and coverage-report format major; IDs MUST NOT depend on dimensionsEnabled or runtime coverage options.\n- Represent dimensions (structure, branches, enum, boundaries, operations) and statuses ('active', 'unreachable' and 'deprecated'), plus inert fields weight and polarity.\n- Support diagnostic-only target kinds such as SCHEMA_REUSED_COVERED by always emitting them with status:'deprecated' so they remain visible in targets[] and diagnostics but never contribute to metrics.overall, metrics.byDimension, metrics.byOperation or minCoverage enforcement.\n- Ensure the CoverageGraph can be derived from Normalize/Compose canonical artifacts without reparsing the raw schema or re-implementing JSON Schema semantics.\n- Provide basic helpers for mapping canonical JSON Pointers and operation keys (operationId or <METHOD> <path>) to coverage nodes, without forcing OpenAPI operation-level logic into the core analyzer before task 9310.\n\n[Deliverables]\n- Core coverage model types under packages/core/src/coverage/model.ts.\n- Utility functions for CoverageGraph construction hooks under packages/core/src/coverage/graph.ts.\n- Shared type exports in packages/shared/src/types/coverage.ts for CLI and reporter consumers.\n\n[Definition of Done]\n- CoverageTarget, CoverageTargetReport, CoverageGraph and CoverageDimension types are defined and exported from core and shared packages.\n- The ID generation scheme is documented and deterministic in unit tests: the same canonical schema and OpenAPI mapping produce the same IDs, and changing dimensionsEnabled does not change IDs for any target that exists under both projections.\n- The model supports all dimensions defined in the spec, including future boundaries and operation-linked kinds, and can represent diagnostic-only targets such as SCHEMA_REUSED_COVERED while keeping their status:'deprecated' semantics aligned with metrics exclusions.\n- No new model type requires reparsing user schemas; everything is expressed in terms of canonical schema pointers and Compose artifacts.\n- Basic unit tests for the ID generator and CoverageGraph helpers are green and integrated in CI.",
        "testStrategy": "Unit tests for ID determinism and stability across runs with fixed canonical schemas; property-based tests that hash canonical views and check CoverageTarget.id stability when dimensionsEnabled is toggled; type-level tests to ensure dimensions, statuses and diagnostic kinds like SCHEMA_REUSED_COVERED match the spec; review of public exports to avoid breaking shared consumers; property-based tests that build Analyzer output twice for the same canonical schema with different dimensionsEnabled projections (e.g. ['structure','branches'] vs ['structure','branches','enum']) and assert that IDs and shapes of non-enum targets remain identical after sorting by id.",
        "subtasks": [
          {
            "id": 9300001,
            "title": "Design CoverageTarget and CoverageGraph types",
            "description": "Sketch and implement CoverageTarget, CoverageTargetReport and CoverageGraph interfaces, including dimensions, status, weight, polarity and meta fields. Define branch target kinds ONEOF_BRANCH, ANYOF_BRANCH and CONDITIONAL_PATH (for if/then/else and dependentSchemas paths) and a params shape that records pathKind and branchKey without depending on dimensionsEnabled.",
            "status": "pending",
            "estimatedHours": 3,
            "file": "packages/core/src/coverage/model.ts",
            "parentId": "9300"
          },
          {
            "id": 9300002,
            "title": "Implement deterministic CoverageTarget ID generator",
            "description": "Implement a stable ID generator for coverage targets based on canonical paths, kind, dimension and optional operationKey and params, independent of dimensionsEnabled. IDs MUST NOT depend on status, hit, weight, polarity, meta, dimensionsEnabled, excludeUnreachable, planner caps, hints or any runtime coverage results.",
            "status": "pending",
            "estimatedHours": 3,
            "file": "packages/core/src/coverage/id-generator.ts",
            "parentId": "9300"
          },
          {
            "id": 9300003,
            "title": "Expose coverage types in shared package",
            "description": "Re-export coverage types in the shared package for consumption by CLI and reporter.",
            "status": "pending",
            "estimatedHours": 2,
            "file": "packages/shared/src/types/coverage.ts",
            "parentId": "9300"
          },
          {
            "id": 9300004,
            "title": "Add unit tests for ID stability and dimensions",
            "description": "Add tests that assert IDs are stable when dimensionsEnabled, excludeUnreachable or planner/cap options change, including a projection test where the same canonical schema is analyzed with different dimensionsEnabled sets (e.g. ['structure','branches'] vs ['structure','branches','enum']) and non-enum CoverageTarget.id values remain identical.",
            "status": "pending",
            "estimatedHours": 2,
            "file": "packages/core/src/coverage/__tests__/model.spec.ts",
            "parentId": "9300"
          }
        ],
        "updatedAt": "2025-11-27T22:28:08.637Z"
      },
      {
        "id": "9301",
        "title": "Implement CoverageAnalyzer from canonical Compose artifacts",
        "description": "Build CoverageAnalyzer to derive the CoverageGraph and full CoverageTarget set from Normalize/Compose artifacts.",
        "priority": "high",
        "estimatedHours": 14,
        "dependencies": [
          "9300"
        ],
        "status": "done",
        "complexityScore": 4,
        "details": "[Context]\nImplement CoverageAnalyzer as a new stage between Compose and generation, per coverage-aware spec §4.1 (CoverageAnalyzer) and §3.1 (CoverageGraph). The analyzer consumes canonical schemas, ptrMap, CoverageIndex, planDiag and optional OpenAPI context and produces a deterministic CoverageGraph plus the exhaustive CoverageTarget set for the enabled dimensions (structure, branches, enum) in M0/M1.\n\n[Key requirements]\n- Consume only canonical view and Compose artifacts (canonSchema, ptrMap, CoverageIndex, planDiag) and optional OpenAPI context; never reparse the raw schema, and do not construct OperationNodes or OP_* targets in this task.\n- Materialize CoverageGraph nodes and edges for schemas, properties, branches (oneOf/anyOf/conditionals), enums (including potentially large enums) and simple structural constraints, as preparation for the boundaries dimension introduced in task 9309, without yet materializing *_HIT targets for boundaries, with structural, logical and reference edges.\n- Generate CoverageTargets for all enabled dimensions (structure, branches, enum in M0/M1) with stable IDs using the model defined in task 9300. In standard modes, do not materialize targets for dimensions that are not in dimensionsEnabled; any future debug/introspection mode must be explicitly opt-in.\n- For large enums, Analyzer MAY deterministically subsample enum values into CoverageTargets, recording this in target meta (for example meta.enumSubsampled:true and/or skipped indices) so behavior is reproducible and visible to tooling.\n- Under AP:false, PROPERTY_PRESENT targets for undeclared property names must be backed exclusively by CoverageIndex.has / CoverageIndex.enumerate; CoverageAnalyzer must not introduce a separate automaton for AP:false property names, must only create PROPERTY_PRESENT targets for names exposed by CoverageIndex and must not diverge from CoverageIndex semantics.\n- Derive status:'unreachable' targets conservatively from existing diagnostics (e.g. UNSAT_* codes, CoverageIndex emptiness) and branch pruning heuristics, without introducing a separate proof engine; when in doubt, prefer leaving targets active and uncovered.\n- Ensure analyzer output is deterministic for fixed inputs and options, with no RNG or time-dependent behavior, and treat dimensionsEnabled as a projection over a stable target universe (toggling dimensionsEnabled does not change IDs of targets present in both configurations).\n- Ensure CoverageAnalyzer is only invoked when coverageMode is 'measure' or 'guided'; pipeline runs with coverage=off must skip CoverageAnalyzer entirely to keep overhead close to the current engine.\n\n[Deliverables]\n- CoverageAnalyzer implementation under packages/core/src/coverage/coverage-analyzer.ts.\n- Integration glue in the pipeline orchestrator to run CoverageAnalyzer after Compose and before planner/generator when coverageMode != 'off'.\n- Unit tests and fixtures for schemas with oneOf/anyOf, AP:false objects and enums to validate CoverageGraph topology and targets.\n\n[Definition of Done]\n- CoverageAnalyzer can be invoked from the pipeline with canonical Compose outputs and returns a deterministic CoverageGraph and CoverageTarget[] for the enabled dimensions.\n- Analyzer never reparses the raw schema or re-implements JSON Schema semantics; all logic is driven by canonical views and existing diagnostics.\n- Unreachable targets are marked only when supported by strong signals (UNSAT diagnostics or CoverageIndex emptiness), and tests cover false-positive avoidance.\n- When an OpenAPI document is present, schema-level targets and IDs remain stable; operation-level targets and OperationNodes are added later by task 9310, and enabling/disabling OpenAPI context does not change schema-level CoverageTarget.id values.\n- Pipeline integration tests verify that CoverageAnalyzer is not called when coverageMode is 'off'.\n- All new diagnostics and status markings are covered by unit tests and pass CI.",
        "testStrategy": "Unit tests using small JSON Schema fixtures (including AP:false objects) to snapshot CoverageGraph topology and targets; property-based tests that show adding or removing dimensionsEnabled does not change existing target IDs; targeted tests around AP:false to ensure PROPERTY_PRESENT for undeclared names aligns exactly with CoverageIndex.enumerate; integration tests in the pipeline to assert CoverageAnalyzer is invoked only for coverage=measure/guided and output is deterministic across repeated runs.",
        "subtasks": [
          {
            "id": 9301001,
            "title": "Wire CoverageAnalyzer inputs from Compose",
            "description": "Connect canonSchema, ptrMap, CoverageIndex and planDiag into a CoverageAnalyzer entry point, gated so it is only called when coverageMode is 'measure' or 'guided'.",
            "status": "done",
            "estimatedHours": 3,
            "file": "packages/core/src/coverage/coverage-analyzer.ts",
            "parentId": "9301",
            "updatedAt": "2025-11-27T23:03:38.786Z"
          },
          {
            "id": 9301002,
            "title": "Implement graph construction for schema, property and branch nodes",
            "description": "Build CoverageGraph nodes and edges for schemas, properties and oneOf/anyOf/conditional branches using canonical pointers.",
            "status": "done",
            "estimatedHours": 4,
            "file": "packages/core/src/coverage/coverage-analyzer.ts",
            "parentId": "9301",
            "updatedAt": "2025-11-27T23:13:14.654Z"
          },
          {
            "id": 9301003,
            "title": "Generate CoverageTargets for structure, branches and enum dimensions",
            "description": "Materialize SCHEMA_NODE, PROPERTY_PRESENT, ONEOF_BRANCH, ANYOF_BRANCH, CONDITIONAL_PATH and ENUM_VALUE_HIT targets for enabled dimensions, with IDs independent of dimensionsEnabled.",
            "status": "done",
            "estimatedHours": 3,
            "file": "packages/core/src/coverage/coverage-analyzer.ts",
            "parentId": "9301",
            "updatedAt": "2025-11-27T23:24:56.021Z"
          },
          {
            "id": 9301004,
            "title": "Derive unreachable targets from existing diagnostics",
            "description": "Integrate UNSAT_* and AP:false diagnostics and CoverageIndex signals to mark a conservative subset of targets as status:'unreachable'.",
            "status": "done",
            "estimatedHours": 2,
            "file": "packages/core/src/coverage/coverage-analyzer-unreachable.ts",
            "parentId": "9301",
            "updatedAt": "2025-11-27T23:30:00.195Z"
          },
          {
            "id": 9301005,
            "title": "Add unit tests for CoverageAnalyzer determinism and topology",
            "description": "Create fixtures and tests verifying target sets, IDs and statuses stay stable across runs and for different dimensionsEnabled and coverageMode configurations, including schemas with if/then/else or dependentSchemas so CONDITIONAL_PATH targets are materialized and tracked, and large enums where subsampled enum targets and their meta remain deterministic.",
            "status": "done",
            "estimatedHours": 2,
            "file": "packages/core/src/coverage/__tests__/coverage-analyzer.spec.ts",
            "parentId": "9301",
            "updatedAt": "2025-11-27T23:34:31.947Z"
          }
        ],
        "updatedAt": "2025-11-27T23:34:31.947Z"
      },
      {
        "id": "9302",
        "title": "Add passive coverage instrumentation for measurement mode (M0)",
        "description": "Instrument generator and repair stages to emit coverage events for structure, branches and enums in coverage=measure mode without changing generated instances.",
        "priority": "high",
        "estimatedHours": 16,
        "dependencies": [
          "9300",
          "9301"
        ],
        "status": "done",
        "complexityScore": 4,
        "details": "[Context]\nImplement M0 coverage measurement for the existing pipeline, per coverage-aware spec §2.1 (Phase M0) and §4.3 (Generator instrumentation). coverage=measure must compute coverage from final instances (after Repair + Validate) for SCHEMA_NODE, PROPERTY_PRESENT, ONEOF_BRANCH, ANYOF_BRANCH, CONDITIONAL_PATH and ENUM_VALUE_HIT targets, while leaving generator behavior identical to coverage=off for a given (schema, seed, options).\n\n[Key requirements]\n- Extend Generate and Repair to emit coverage events for schema nodes, optional property presence, oneOf/anyOf/conditional branches and enum values, using canonical pointers from the CoverageGraph.\n- Under AP:false, property presence coverage for undeclared property names MUST be derived solely from CoverageIndex.has / CoverageIndex.enumerate; instrumentation must not infer additional property names from patternProperties or propertyNames beyond what CoverageIndex exposes.\n- Ensure events are only committed as hits once instances have passed Validate; invalid instances must not mark targets as hit.\n- For coverage=measure, guarantee that the sequence of emitted instances is byte-for-byte identical to coverage=off for the same inputs; instrumentation must be purely observational and must not affect generation decisions.\n- Implement a first coverage accumulator that can support temporary post-pass computation for M0, while anticipating streaming updates required in M1.\n- Add toggles so coverage instrumentation is fully disabled when coverage=off, keeping overhead negligible and ensuring that in that mode neither CoverageAnalyzer nor coverage accumulators are invoked.\n\n[Deliverables]\n- Coverage event models and accumulator implementation under packages/core/src/coverage/coverage-events.ts.\n- Instrumentation hooks in generator and repair code paths to record branches, property presence and enum usage.\n- Configuration plumbing from CLI and Node API to select coverage=off or coverage=measure and to pass dimensionsEnabled down to instrumentation.\n\n[Definition of Done]\n- With coverage=measure and coverage=off, the generated data streams are identical for the same schemas and seeds, confirmed by golden tests.\n- Coverage accumulators correctly mark hits only after Validate, and targets remain unhit when instances are invalid or filtered out.\n- Property presence and branch hits (including ANYOF_BRANCH and CONDITIONAL_PATH) are derived from canonical view and CoverageGraph, not raw schema re-parsing, and AP:false property coverage matches CoverageIndex semantics for undeclared names.\n- Overhead of coverage=measure is measured and documented via existing metrics, and instrumentation cost is included in per-phase timings.\n- New instrumentation paths are guarded by feature flags so coverage=off behavior and performance remain within existing SLOs.",
        "testStrategy": "Golden snapshot tests comparing coverage=off vs coverage=measure output for the same schema and seed; unit tests for coverage event aggregation and per-target hit semantics (including ANYOF_BRANCH and CONDITIONAL_PATH); integration tests that run the full pipeline and assert that coverage metrics match expected hits on small schemas with oneOf, anyOf, conditional branches, optional properties and enums; tests for AP:false fixtures where CoverageIndex is empty and PROPERTY_PRESENT for undeclared names never appears, and where non-empty CoverageIndex ensures PROPERTY_PRESENT only for names it exposes; benchmark runs to confirm overhead stays within acceptable bounds.",
        "subtasks": [
          {
            "id": 9302001,
            "title": "Define coverage event model and accumulator",
            "description": "Create event types for schema, property, branch and enum hits and an accumulator that maps them to CoverageTargets.",
            "status": "done",
            "estimatedHours": 3,
            "file": "packages/core/src/coverage/coverage-events.ts",
            "parentId": "9302",
            "updatedAt": "2025-11-27T23:43:50.250Z"
          },
          {
            "id": 9302002,
            "title": "Instrument generator for branches and enums",
            "description": "Add hooks in the generator to emit coverage events when oneOf/anyOf/conditional branches are chosen and enum values are produced, keyed by canonical paths and branch identifiers.",
            "status": "done",
            "estimatedHours": 4,
            "file": "packages/core/src/generator/foundry-generator.ts",
            "parentId": "9302",
            "updatedAt": "2025-11-28T18:06:32.425Z"
          },
          {
            "id": 9302003,
            "title": "Instrument repair and property presence",
            "description": "Emit coverage events when properties are added or removed in Repair and when optional properties are present in final instances, including AP:false objects where property names come from CoverageIndex.",
            "status": "done",
            "estimatedHours": 3,
            "file": "packages/core/src/repair/repair-engine.ts",
            "parentId": "9302",
            "updatedAt": "2025-11-28T18:24:32.286Z"
          },
          {
            "id": 9302004,
            "title": "Integrate coverage accumulators into pipeline orchestrator",
            "description": "Wire coverage accumulators into the pipeline so coverage=measure collects events during Generate and Repair and finalizes after Validate, with all coverage code completely disabled when coverage=off.",
            "status": "done",
            "estimatedHours": 3,
            "file": "packages/core/src/pipeline/orchestrator.ts",
            "parentId": "9302",
            "updatedAt": "2025-11-28T18:40:56.119Z"
          },
          {
            "id": 9302005,
            "title": "Add regression tests for coverage=off vs coverage=measure equivalence",
            "description": "Create tests that run generate with and without coverage measurement and assert identical outputs while coverage metrics differ, including schemas with conditional branches (if/then/else or dependentSchemas) to verify CONDITIONAL_PATH events are emitted without changing generated instances.",
            "status": "done",
            "estimatedHours": 3,
            "file": "packages/core/test/e2e/coverage-measurement.spec.ts",
            "parentId": "9302",
            "updatedAt": "2025-11-28T18:49:48.162Z"
          }
        ],
        "updatedAt": "2025-11-28T18:49:48.162Z"
      },
      {
        "id": "9303",
        "title": "Implement coverage report format and CoverageEvaluator",
        "description": "Aggregate coverage results into the versioned JSON coverage-report/v1 format and expose coverage metrics and uncovered targets.",
        "priority": "high",
        "estimatedHours": 14,
        "dependencies": [
          "9300",
          "9301",
          "9302"
        ],
        "status": "done",
        "complexityScore": 4,
        "details": "[Context]\nImplement CoverageEvaluator and the JSON coverage report format per coverage-aware spec §4.4 (CoverageEvaluator) and §7.1 (JSON coverage report). This includes computing metrics.overall, metrics.byDimension, metrics.byOperation, targetsByStatus and thresholds, and emitting targets and uncoveredTargets arrays according to reportMode semantics.\n\n[Key requirements]\n- Implement CoverageEvaluator that consumes CoverageTargets, hit information, coverage options (dimensionsEnabled, excludeUnreachable) and planner diagnostics and produces metrics and report arrays.\n- Compute metrics.overall, metrics.byDimension and metrics.byOperation exactly as defined in the spec, including correct handling of status:'unreachable' and dimensionsEnabled filtering; metrics.byOperation MUST be computed as a projection over all reachable targets per operation whose dimension is enabled.\n- Ensure targets with status:'deprecated' (including diagnostic-only targets such as SCHEMA_REUSED_COVERED) never contribute to metrics.overall, metrics.byDimension, metrics.byOperation or minCoverage enforcement, while still being visible in targets, uncoveredTargets and diagnostics.\n- Represent unreachable targets solely via their status:'unreachable' in targets (and uncoveredTargets when hit:false); there is no dedicated unreachableTargets array in the report, and any unreachable-only view MUST be obtained by filtering on status.\n- Implement report header fields (version, reportMode, engine, run, metrics, thresholds, diagnostics) with deterministic values for a given run and options.\n- Support both full and summary report modes, with clear semantics: full materializes the complete targets[] set for all enabled dimensions, summary may truncate targets[] and uncoveredTargets[] while still computing metrics over the full target universe built by the Analyzer.\n- Expose uncoveredTargets sorted by priority (dimension, weight, type, path) and include unsatisfiedHints and plannerCapsHit diagnostics for guided runs; in reportMode:'full', uncoveredTargets MUST contain all targets with hit:false whose status is either 'active' or 'unreachable'; in reportMode:'summary', uncoveredTargets MAY be truncated while all metrics are still computed over the full target universe built by the Analyzer.\n\n[Deliverables]\n- CoverageEvaluator implementation under packages/core/src/coverage/coverage-evaluator.ts.\n- CoverageReport type definition under packages/shared/src/types/coverage-report.ts.\n- Integration in the pipeline result and Node API to return a CoverageReport Promise alongside the data stream.\n\n[Definition of Done]\n- CoverageEvaluator computes metrics that match hand-calculated expectations on small fixtures for all dimensions, including operations when available once task 9310 is implemented.\n- coverage-report/v1 JSON structure matches the spec, including reportMode semantics, dimensionsEnabled and excludeUnreachable behavior (denominators only, IDs and statuses unchanged), thresholds wiring for overall coverage only, and unreachable targets discoverable solely via status:'unreachable' in targets/uncoveredTargets.\n- Diagnostic-only targets such as SCHEMA_REUSED_COVERED are present in targets[] and diagnostics but are excluded from all coverage metrics and thresholds via status:'deprecated'.\n- Coverage reports are deterministic across repeated runs for the same (schema, options, seed, AJV major, registryFingerprint).\n- Uncovered targets list and targetsByStatus counters are consistent and validated in tests.\n- Node API and CLI can emit a valid coverage-report/v1 JSON file for coverage=measure and coverage=guided runs.",
        "testStrategy": "Unit tests for CoverageEvaluator that feed synthetic CoverageTargets and hit bitmaps and assert metrics and report arrays; tests that exercise excludeUnreachable true/false and confirm denominators change while targetsByStatus stays consistent and unreachable targets are discoverable by filtering status:'unreachable' from targets/uncoveredTargets; tests toggling dimensionsEnabled to ensure IDs for common targets remain stable and metrics are computed only over enabled dimensions; tests that include SCHEMA_REUSED_COVERED targets with status:'deprecated' and verify they never affect metrics.overall, metrics.byDimension or metrics.byOperation; golden JSON fixtures for coverage-report/v1 to catch regressions; integration tests that run the pipeline end-to-end on small schemas and OpenAPI specs (once 9310 is present) and compare the resulting coverage report with expected metrics and unreachable views derived from status; include a pre-9310 scenario where metrics.byOperation is empty while other metrics are still computed correctly, to document intermediate behavior before operation-level coverage is available.",
        "subtasks": [
          {
            "id": 9303001,
            "title": "Define CoverageReport types and thresholds structure",
            "description": "Create TypeScript definitions for CoverageReport, PlannerCapHit and UnsatisfiedHintReasonCode matching the spec.",
            "status": "done",
            "estimatedHours": 3,
            "file": "packages/shared/src/types/coverage-report.ts",
            "parentId": "9303",
            "updatedAt": "2025-11-28T19:16:38.971Z"
          },
          {
            "id": 9303002,
            "title": "Implement CoverageEvaluator metrics aggregation",
            "description": "Compute metrics.overall, metrics.byDimension, metrics.byOperation, targetsByStatus, thresholds and uncoveredTargets from CoverageTargets and hit data, respecting dimensionsEnabled, excludeUnreachable (denominators-only) and diagnostic-only targets; uncoveredTargets must include all targets with hit:false whose status is either 'active' or 'unreachable', and unreachable targets must be represented via status:'unreachable' in targets (and uncoveredTargets when hit:false) rather than a dedicated unreachableTargets array, so unreachable-only views are obtained by filtering on status.",
            "status": "done",
            "estimatedHours": 4,
            "file": "packages/core/src/coverage/coverage-evaluator.ts",
            "parentId": "9303",
            "updatedAt": "2025-11-28T19:35:32.090Z"
          },
          {
            "id": 9303003,
            "title": "Implement reportMode full vs summary behavior",
            "description": "Add logic to include or truncate targets and uncoveredTargets arrays depending on reportMode while keeping metrics exact over the full target universe.",
            "status": "done",
            "estimatedHours": 2,
            "file": "packages/core/src/coverage/coverage-evaluator.ts",
            "parentId": "9303",
            "updatedAt": "2025-11-28T19:51:24.348Z"
          },
          {
            "id": 9303004,
            "title": "Wire CoverageEvaluator into pipeline result and Node API",
            "description": "Attach coverage report computation to the pipeline orchestrator and expose it as a Promise alongside the data stream.",
            "status": "done",
            "estimatedHours": 3,
            "file": "packages/core/src/pipeline/orchestrator.ts",
            "parentId": "9303",
            "updatedAt": "2025-11-28T20:07:26.512Z"
          },
          {
            "id": 9303005,
            "title": "Add snapshot tests for coverage-report/v1 JSON",
            "description": "Create snapshot tests that generate coverage reports on sample schemas and assert stable JSON shape and values, including dimensionsEnabled and targetsByStatus.",
            "status": "done",
            "estimatedHours": 2,
            "file": "packages/core/test/e2e/coverage-report.spec.ts",
            "parentId": "9303",
            "updatedAt": "2025-11-28T20:15:31.394Z"
          }
        ],
        "updatedAt": "2025-11-28T20:15:31.394Z"
      },
      {
        "id": "9304",
        "title": "Add CLI coverage modes, options and CI-friendly summary",
        "description": "Expose coverage=off|measure|guided, dimensions, thresholds and report path via CLI flags and print a human-readable coverage summary for CI logs.",
        "priority": "high",
        "estimatedHours": 12,
        "dependencies": [
          "9301",
          "9302",
          "9303"
        ],
        "status": "pending",
        "complexityScore": 3,
        "details": "[Context]\nExtend the CLI to configure coverage-aware behavior and surface summary metrics, per coverage-aware spec §6 (Execution modes & UX) and §7.2 (CLI summary). The CLI must support coverage modes, dimensions, thresholds, report path, excludeUnreachable and profiles, and output a clear summary for CI that emphasizes per-dimension and per-operation coverage before the global overall figure.\n\n[Key requirements]\n- Implement CLI flags: --coverage=off|measure|guided, --coverage-dimensions, --coverage-min, --coverage-report, --coverage-profile and --coverage-exclude-unreachable; map them to internal options and CoverageReport.run fields.\n- Ensure --n (or --count) is reused as maxInstances for coverage=guided and is passed to the planner and evaluator.\n- Implement CI-friendly summary output that prints metrics.byDimension, metrics.byOperation, metrics.overall, targetsByStatus and a short summary of planner caps and unsatisfied hints, in that order of importance.\n- Ensure coverage=off behaves exactly as today with minimal overhead, and coverage=measure does not change outputs relative to coverage=off for fixed seeds; pipeline wiring must not invoke CoverageAnalyzer or coverage instrumentation when coverage=off.\n- Implement coverage profiles as presets over maxInstances, dimensionsEnabled and planner caps:\n  - quick: dimensionsEnabled = ['structure','branches'], small maxInstances (order of 50–100) and aggressive caps per dimension/schema/operation.\n  - balanced (default): dimensionsEnabled = ['structure','branches','enum'], moderate maxInstances (order of 200–500) and moderate caps favoring branches and enums.\n  - thorough: dimensionsEnabled = ['structure','branches','enum','boundaries'] once the boundaries dimension is available, maxInstances >= 1000 and planner caps disabled except for hard global constraints (e.g. global memory/time limits).\n- Ensure any future debug/introspection CLI option that materializes additional targets beyond dimensionsEnabled is explicit opt-in and does not change metric or threshold semantics: coverage.overall, coverage.byDimension, coverage.byOperation and minCoverage MUST always be computed solely from dimensions listed in dimensionsEnabled.\n- Document coverage options and profiles in CLI help text and examples to match the spec’s suggested usage and default behavior.\n\n[Deliverables]\n- Extended CLI option parsing in packages/cli/src/commands/generate.ts and openapi.ts.\n- Summary printer in packages/cli/src/coverage/coverage-summary.ts.\n- Updated --help output and docs snippets for coverage usage.\n\n[Definition of Done]\n- CLI accepts coverage flags and forwards them to the core pipeline and coverage evaluator consistently for JSON Schema and OpenAPI entrypoints.\n- coverage=off, coverage=measure and coverage=guided modes can be invoked via CLI and map to the engine’s coverageMode field in the report and to whether CoverageAnalyzer/instrumentation are invoked.\n- Profiles quick, balanced and thorough map to well-defined presets for maxInstances, dimensionsEnabled and planner caps, and tests verify that selecting a profile results in the expected internal configuration.\n- Summary output for a representative run includes per-dimension and per-operation coverage, overall coverage, targetsByStatus and concise planner/hints summaries, with per-dimension and per-operation displayed before the overall figure.\n- CLI examples in README or dedicated docs show typical coverage usage patterns and are kept in sync with the implemented flags and profiles.",
        "testStrategy": "CLI integration tests that run foundrydata generate and foundrydata openapi with different coverage flags and assert exit codes, coverage summary output and generated coverage-report JSON; tests that verify coverage=off does not trigger CoverageAnalyzer or coverage instrumentation; snapshot tests for the summary formatter to ensure ordering (byDimension, byOperation, overall) remains stable; tests that run the CLI with --coverage-profile=quick|balanced|thorough and assert that the resulting dimensionsEnabled, maxInstances and caps match the documented presets.",
        "subtasks": [
          {
            "id": 9304001,
            "title": "Add coverage flags to generate and openapi commands",
            "description": "Extend CLI argument parsing to accept coverage mode, dimensions, minCoverage, report path, profile and excludeUnreachable options.",
            "status": "pending",
            "estimatedHours": 3,
            "file": "packages/cli/src/commands/generate.ts",
            "parentId": "9304"
          },
          {
            "id": 9304002,
            "title": "Map CLI coverage options to core pipeline configuration",
            "description": "Translate CLI flags into the coverage configuration passed to the pipeline orchestrator and coverage evaluator, ensuring coverage=off fully skips CoverageAnalyzer and coverage instrumentation, that coverage-report and minCoverage-related options are ignored (with a clear warning or note) when coverage=off, and that unknown or not-yet-implemented dimensions in --coverage-dimensions are handled deterministically (either rejected with a clear error or dropped with a diagnostic note).",
            "status": "pending",
            "estimatedHours": 3,
            "file": "packages/cli/src/config/coverage-options.ts",
            "parentId": "9304"
          },
          {
            "id": 9304003,
            "title": "Implement coverage summary printer for CI logs",
            "description": "Format metrics.byDimension, metrics.byOperation, metrics.overall, targetsByStatus and diagnostics into a concise CLI summary, with per-dimension and per-operation metrics emphasized before overall.",
            "status": "pending",
            "estimatedHours": 3,
            "file": "packages/cli/src/coverage/coverage-summary.ts",
            "parentId": "9304"
          },
          {
            "id": 9304004,
            "title": "Add CLI tests for coverage modes and thresholds",
            "description": "Create tests that run the CLI with different coverage modes, profiles and minCoverage values and assert exit codes and summaries, including edge cases such as coverage=off combined with coverage-report/minCoverage flags and unknown dimensions in --coverage-dimensions.",
            "status": "pending",
            "estimatedHours": 3,
            "file": "packages/cli/test/coverage-cli.spec.ts",
            "parentId": "9304"
          }
        ]
      },
      {
        "id": "9305",
        "title": "Implement static CoveragePlanner for guided coverage (M1)",
        "description": "Create a greedy, deterministic CoveragePlanner that proposes TestUnits with hints and respects maxInstances and planner caps.",
        "priority": "high",
        "estimatedHours": 16,
        "dependencies": [
          "9301",
          "9302",
          "9303",
          "9307"
        ],
        "status": "pending",
        "complexityScore": 5,
        "details": "[Context]\nImplement the CoveragePlanner stage for coverage=guided, as specified in §4.2 (CoveragePlanner) and §6.2 (Budget & profiles). The planner consumes CoverageGraph and targets and produces a deterministic sequence of TestUnits with derived seeds, planned instance counts and per-unit hints, under an overall maxInstances budget and optional caps.\n\n[Key requirements]\n- Implement a static, greedy planner that builds all TestUnits up front from the initial CoverageTarget set, without adaptive feedback during the run.\n- Prioritize targets by scope (operations first when present), dimension (branches → enum → structure → boundaries) and then by weight and canonical path, with stable sorting rules.\n- Respect maxInstances as an upper bound, allowing early stop when all active targets are covered or when only unreachable or capped targets remain.\n- Implement deterministic caps per dimension/schema/operation and surface them via diagnostics.plannerCapsHit and meta.planned:false on unplanned targets.\n- Generate TestUnit seeds deterministically from a masterSeed and stable derivation rules so that runs are reproducible across executions.\n\n[Deliverables]\n- CoveragePlanner implementation under packages/core/src/coverage/coverage-planner.ts.\n- Planner diagnostics and meta fields wiring into CoverageTargets and CoverageReport.diagnostics.plannerCapsHit.\n- Integration in the pipeline orchestrator for coverage=guided mode, including mapping CLI --n and profiles to maxInstances and caps.\n\n[Commands]\n- npm run build\n- npm run test -- --runInBand\n- npm run test packages/core/src/coverage/__tests__/coverage-planner.spec.ts\n\n[Definition of Done]\n- For small schemas, planner produces TestUnits that exercise all active branch and enum targets within the budget, matching acceptance scenarios for oneOf and enums.\n- Planner respects maxInstances as a hard upper bound and may stop earlier once coverage objectives are satisfied.\n- Planner caps behavior (when large target sets are present) is deterministic and fully surfaced in plannerCapsHit and meta.planned:false on unplanned targets.\n- Seeds and TestUnit ordering are stable across runs for the same inputs and options.\n- Integration tests show that coverage=guided improves coverage.byDimension for branches and enums compared to coverage=measure under the same maxInstances.",
        "testStrategy": "Unit tests for planner prioritization and caps, using synthetic CoverageTargets to verify TestUnit sequences and meta.planned flags; property-based tests for seed derivation and determinism; integration tests that run coverage=guided on sample schemas and assert that branch and enum coverage reach 100% when budget permits, matching acceptance criteria; tests that compare planned vs unplanned targets when caps are hit.",
        "subtasks": [
          {
            "id": 9305001,
            "title": "Design TestUnit structure and planner inputs",
            "description": "Define TestUnit type and planner configuration (maxInstances, dimensions, priorities, caps) and integrate with CoverageGraph and CoverageTargets.",
            "status": "pending",
            "estimatedHours": 3,
            "file": "packages/core/src/coverage/coverage-planner.ts",
            "parentId": "9305"
          },
          {
            "id": 9305002,
            "title": "Implement greedy prioritization and budget handling",
            "description": "Implement the greedy selection algorithm over targets, enforcing prioritization rules and maxInstances constraints.",
            "status": "pending",
            "estimatedHours": 4,
            "file": "packages/core/src/coverage/coverage-planner.ts",
            "parentId": "9305"
          },
          {
            "id": 9305003,
            "title": "Implement planner caps and diagnostics",
            "description": "Add deterministic caps per dimension/schema/operation and report them via diagnostics.plannerCapsHit and meta.planned:false.",
            "status": "pending",
            "estimatedHours": 3,
            "file": "packages/core/src/coverage/coverage-planner-caps.ts",
            "parentId": "9305"
          },
          {
            "id": 9305004,
            "title": "Derive deterministic seeds for TestUnits",
            "description": "Implement masterSeed derivation into per-TestUnit seeds and add tests for reproducibility across runs.",
            "status": "pending",
            "estimatedHours": 3,
            "file": "packages/core/src/coverage/seed-planner.ts",
            "parentId": "9305"
          },
          {
            "id": 9305005,
            "title": "Add integration tests for coverage=guided planning behavior",
            "description": "Run the full pipeline on acceptance schemas to confirm planner helps hit all oneOf branches and enum values with sufficient budget.",
            "status": "pending",
            "estimatedHours": 3,
            "file": "packages/core/test/e2e/coverage-guided-planner.spec.ts",
            "parentId": "9305"
          }
        ]
      },
      {
        "id": "9306",
        "title": "Wire coverage hints into generator with conflict resolution and unsatisfied hints",
        "description": "Implement preferBranch, ensurePropertyPresence and coverEnumValue hints in the generator and record unsatisfied hints and reasons.",
        "priority": "high",
        "estimatedHours": 14,
        "dependencies": [
          "9302",
          "9305",
          "9307"
        ],
        "status": "pending",
        "complexityScore": 4,
        "details": "[Context]\nImplement coverage hints and their interaction with the generator and Repair, as described in §5 (Hints & interaction with Repair). coverage=guided uses hints attached to TestUnits to steer branch choices, property presence and enum values while preserving AJV validity and determinism, and records unsatisfied hints when constraints prevent their satisfaction.\n\n[Key requirements]\n- Implement hint types preferBranch(schemaPath, branchIndex), ensurePropertyPresence(schemaPath, property, present) and coverEnumValue(schemaPath, valueIndex) and attach them to TestUnits from the planner.\n- Extend the generator to consume hints in coverage=guided mode only, with AJV validity taking precedence and default heuristics used when hints are absent, inapplicable or unsatisfiable.\n- Implement deterministic conflict resolution with a global priority order (coverEnumValue > preferBranch > ensurePropertyPresence) and stable ordering within each kind (first in hints[] wins).\n- Detect unsatisfied hints when Repair modifies values or when constraints make the hinted target unreachable, and record them as unsatisfiedHints with reasonCode and reasonDetail in the coverage report.\n- Ensure hints have no effect in coverage=off and coverage=measure modes and do not alter external driver behavior.\n\n[Deliverables]\n- Hint definitions and helper utilities in packages/core/src/coverage/hints.ts.\n- Generator integration for hint consumption in packages/core/src/generator/foundry-generator.ts.\n- UnsatisfiedHints collection and wiring into CoverageEvaluator and CoverageReport.unsatisfiedHints.\n\n[Commands]\n- npm run build\n- npm run test -- --runInBand\n- npm run test packages/core/src/generator/__tests__/coverage-hints.spec.ts\n\n[Definition of Done]\n- Generator respects hints in coverage=guided mode while still emitting only AJV-valid instances; invalid instances caused by hints are rejected and hints are marked unsatisfied.\n- Conflict resolution across multiple hints for the same node is deterministic and covered by unit tests.\n- Unsatisfied hints are reported with appropriate reasonCode values such as UNREACHABLE_BRANCH, REPAIR_MODIFIED_VALUE or PLANNER_CAP, and are visible in coverage reports without affecting coverageStatus in V1.\n- Runs with coverage=off or coverage=measure show no behavioral difference compared to pre-hints behavior.\n- Acceptance scenarios for oneOf branches and enum coverage are supported by guided runs that use hints to reach full coverage under sufficient budget.",
        "testStrategy": "Focused unit tests that drive the generator with individual hints and conflicting hints and assert chosen branches, properties and enum values; tests that exercise Repair interactions to produce unsatisfied hints; integration tests in coverage=guided mode verifying that hints improve coverage and that unsatisfiedHints are recorded when constraints make hints impossible to satisfy.",
        "subtasks": [
          {
            "id": 9306001,
            "title": "Define hint types and priority rules",
            "description": "Implement Hint interfaces and establish global priority and conflict resolution rules for different hint kinds.",
            "status": "pending",
            "estimatedHours": 3,
            "file": "packages/core/src/coverage/hints.ts",
            "parentId": "9306"
          },
          {
            "id": 9306002,
            "title": "Integrate hints into generator decision points",
            "description": "Consume hints in the generator when selecting branches, deciding property presence and picking enum values in coverage=guided mode, without changing AP:false name semantics or CoverageIndex behavior (property-name coverage still comes solely from CoverageIndex).",
            "status": "pending",
            "estimatedHours": 4,
            "file": "packages/core/src/generator/foundry-generator.ts",
            "parentId": "9306"
          },
          {
            "id": 9306003,
            "title": "Record unsatisfied hints from generator and repair",
            "description": "Detect when hints cannot be satisfied or are undone by Repair and record UnsatisfiedHint entries with reason codes.",
            "status": "pending",
            "estimatedHours": 3,
            "file": "packages/core/src/coverage/unsatisfied-hints.ts",
            "parentId": "9306"
          },
          {
            "id": 9306004,
            "title": "Add tests for hint precedence and determinism",
            "description": "Write tests confirming hint precedence order and stable behavior across runs for the same hints.",
            "status": "pending",
            "estimatedHours": 2,
            "file": "packages/core/src/generator/__tests__/coverage-hints.spec.ts",
            "parentId": "9306"
          },
          {
            "id": 9306005,
            "title": "Add end-to-end tests for guided hints on schemas with oneOf and enums",
            "description": "Create e2e tests that show full branch and enum coverage under coverage=guided with sufficient budget and visible unsatisfied hints when impossible.",
            "status": "pending",
            "estimatedHours": 2,
            "file": "packages/core/test/e2e/coverage-guided-hints.spec.ts",
            "parentId": "9306"
          }
        ]
      },
      {
        "id": "9307",
        "title": "Implement streaming coverage instrumentation with per-instance commit",
        "description": "Upgrade coverage instrumentation to a streaming model that updates coverage as instances flow through Generate, Repair and Validate without a second JSON parse.",
        "priority": "medium",
        "estimatedHours": 12,
        "dependencies": [
          "9302",
          "9303"
        ],
        "status": "pending",
        "complexityScore": 4,
        "details": "[Context]\nMove from any temporary post-pass coverage computation to the streaming model required for steady-state V1, per §4.3 (Generator instrumentation) and §8 (Technical constraints & invariants). Coverage must be updated as instances pass through Generate and Repair, with hits committed only after Validate, and total overhead must remain O(#instances + #targets).\n\n[Key requirements]\n- Replace any full post-pass re-parse of generated output with in-memory, streaming coverage instrumentation across Generate, Repair and Validate.\n- Maintain per-instance coverage state that accumulates events, then commit hits to global target bitmaps once Validate accepts the instance.\n- Ensure coverage=guided mode uses the same streaming infrastructure as coverage=measure, with additional hints but no extra parse.\n- Integrate coverage instrumentation metrics into existing per-phase metrics (e.g. generateMs, repairMs, validateMs) to make overhead measurable.\n- Preserve determinism: coverage bitmaps and reports must be identical across runs for fixed inputs and options.\n\n[Deliverables]\n- Streaming coverage accumulator implementation in packages/core/src/coverage/coverage-state.ts.\n- Orchestrator wiring to attach per-instance coverage state and commit hits after validation.\n- Updated metrics plumbing to capture coverage-related overhead.\n\n[Commands]\n- npm run build\n- npm run test -- --runInBand\n- npm run bench\n\n[Definition of Done]\n- No phase performs a second JSON parse of the emitted output solely for coverage; coverage computation is fully streaming.\n- Coverage metrics and reports remain unchanged relative to the M0 implementation on existing tests and fixtures.\n- Overhead is measured via bench scripts and remains within acceptable SLOs given the additional instrumentation.\n- Determinism tests confirm that repeated runs produce identical coverage bitmaps and reports.",
        "testStrategy": "Unit tests for streaming coverage state that simulate per-instance event flows and validate final hit sets; integration tests that run the full pipeline and compare coverage reports before and after the streaming refactor; benchmark runs to assess performance overhead and confirm O(#instances + #targets) behavior; determinism tests that run multiple times and compare coverage reports bit-for-bit.",
        "subtasks": [
          {
            "id": 9307001,
            "title": "Implement per-instance coverage state and bitmap representation",
            "description": "Create structures to capture per-instance events and global bitmaps for CoverageTargets in a streaming fashion.",
            "status": "pending",
            "estimatedHours": 3,
            "file": "packages/core/src/coverage/coverage-state.ts",
            "parentId": "9307"
          },
          {
            "id": 9307002,
            "title": "Wire streaming coverage into pipeline phases",
            "description": "Attach coverage state across Generate, Repair and Validate so hits are committed only after successful validation.",
            "status": "pending",
            "estimatedHours": 4,
            "file": "packages/core/src/pipeline/orchestrator.ts",
            "parentId": "9307"
          },
          {
            "id": 9307003,
            "title": "Remove any post-pass coverage computation",
            "description": "Eliminate or guard any remaining full post-pass coverage code paths and ensure tests rely only on streaming instrumentation.",
            "status": "pending",
            "estimatedHours": 2,
            "file": "packages/core/src/coverage/coverage-postpass-legacy.ts",
            "parentId": "9307"
          },
          {
            "id": 9307004,
            "title": "Benchmark streaming coverage overhead",
            "description": "Use existing bench harnesses to measure the impact of streaming coverage and adjust implementation if needed.",
            "status": "pending",
            "estimatedHours": 3,
            "file": "packages/reporter/test/bench.runner.test.ts",
            "parentId": "9307"
          }
        ]
      },
      {
        "id": "9308",
        "title": "Enforce global minCoverage threshold and map to exit codes",
        "description": "Wire metrics.overall to a configurable minCoverage threshold and ensure CLI and Node API expose structured coverageStatus results.",
        "priority": "medium",
        "estimatedHours": 8,
        "dependencies": [
          "9303",
          "9304"
        ],
        "status": "pending",
        "complexityScore": 3,
        "details": "[Context]\nImplement enforcement of minCoverage on metrics.overall and connect it to CLI exit codes and Node API status, per §7.3 (Thresholds) and the acceptance criterion on coverage threshold. In V1, only the overall threshold is honored; per-dimension and per-operation thresholds are reserved for future use.\n\n[Key requirements]\n- Add minCoverage configuration to coverage options and propagate it to CoverageEvaluator.\n- Compute metrics.thresholds.overall and metrics.coverageStatus:'ok'|'minCoverageNotMet' based on metrics.overall and minCoverage.\n- Map coverageStatus to a dedicated non-zero CLI exit code when minCoverage is not met, distinct from other error conditions.\n- Ensure Node API returns coverageStatus alongside the CoverageReport so callers can react programmatically.\n- Keep thresholds.byDimension and thresholds.byOperation descriptive only in V1, without affecting behavior.\n\n[Deliverables]\n- Thresholds handling in CoverageEvaluator and coverage-report/v1 metrics.\n- CLI exit code mapping and documentation for coverage failures.\n- Node API shape that exposes coverageStatus and thresholds to callers.\n\n[Commands]\n- npm run build\n- npm run test -- --runInBand\n- npm run test packages/cli/test/coverage-cli.spec.ts -- --runTestsByPath\n\n[Definition of Done]\n- Runs with metrics.overall below minCoverage produce metrics.coverageStatus:'minCoverageNotMet' and the CLI exits with the configured coverage failure code.\n- Acceptance scenario where minCoverage=0.8 and metrics.overall=0.6 is covered by tests that assert exit code and summary content.\n- Node API returns a structured result that includes coverageStatus and thresholds.overall.\n- Adding or omitting per-dimension and per-operation thresholds in metrics does not affect behavior in V1.",
        "testStrategy": "Unit tests in CoverageEvaluator for threshold handling; CLI tests that run with minCoverage set above expected coverage and assert non-zero exit codes and clear summary output; Node API tests that inspect coverageStatus and thresholds in the returned CoverageReport; regression tests to ensure behavior remains unchanged when thresholds.byDimension or thresholds.byOperation are present but not enforced.",
        "subtasks": [
          {
            "id": 9308001,
            "title": "Propagate minCoverage config to CoverageEvaluator",
            "description": "Extend coverage options to include minCoverage and apply it when computing thresholds.overall and coverageStatus.",
            "status": "pending",
            "estimatedHours": 3,
            "file": "packages/core/src/coverage/coverage-evaluator.ts",
            "parentId": "9308"
          },
          {
            "id": 9308002,
            "title": "Map coverageStatus to CLI exit codes",
            "description": "Add a dedicated coverage failure exit code in the CLI and wire it to metrics.coverageStatus.",
            "status": "pending",
            "estimatedHours": 3,
            "file": "packages/cli/src/coverage/coverage-exit-codes.ts",
            "parentId": "9308"
          },
          {
            "id": 9308003,
            "title": "Test coverage threshold enforcement end-to-end",
            "description": "Create an end-to-end test that runs with minCoverage above achievable coverage and asserts exit code and summary diagnostics.",
            "status": "pending",
            "estimatedHours": 2,
            "file": "packages/core/test/e2e/coverage-threshold.spec.ts",
            "parentId": "9308"
          }
        ]
      },
      {
        "id": "9309",
        "title": "Add boundaries coverage dimension and instrumentation (M2)",
        "description": "Extend coverage model, analyzer and instrumentation to track hits for numeric, string and array boundary constraints.",
        "priority": "medium",
        "estimatedHours": 14,
        "dependencies": [
          "9300",
          "9301",
          "9302",
          "9307"
        ],
        "status": "pending",
        "complexityScore": 4,
        "details": "[Context]\nImplement the boundaries dimension for M2, covering numeric, string and array bounds as described in §3.3 (Boundaries) and §9 (M2 – Boundaries, OpenAPI & diff). This includes NUMERIC_MIN_HIT, NUMERIC_MAX_HIT, STRING_MIN_LENGTH_HIT, STRING_MAX_LENGTH_HIT, ARRAY_MIN_ITEMS_HIT and ARRAY_MAX_ITEMS_HIT targets and their hit semantics.\n\n[Key requirements]\n- Extend CoverageTarget model and CoverageAnalyzer to identify constraint nodes for numeric, string and array boundaries in the canonical view, and materialize corresponding boundary coverage targets when the dimension is enabled.\n- Implement hit semantics for inclusive and exclusive numeric bounds, including representative values based on existing numeric planning and multipleOf handling; avoid introducing separate numeric optimality logic in the coverage layer.\n- Handle degenerate cases where min==max (or similar for lengths and items) deterministically, either as a single logical boundary or as two co-hit targets.\n- Use existing UNSAT diagnostics and numeric feasibility checks to avoid marking unreachable boundary values as active; unreachable boundaries should be either omitted or flagged status:'unreachable'.\n- Instrument generator and repair to emit boundary coverage events in streaming mode without adding new passes over the data.\n\n[Deliverables]\n- Boundaries dimension extensions in coverage model and analyzer under packages/core/src/coverage/model.ts and coverage-analyzer.ts.\n- Boundary-specific instrumentation in generator and repair to record hits when boundary representatives are emitted.\n- Tests and fixtures for numeric bounds with multipleOf, string length and array length constraints, including unreachable cases.\n\n[Commands]\n- npm run build\n- npm run test -- --runInBand\n- npm run test packages/core/src/coverage/__tests__/boundaries.spec.ts\n\n[Definition of Done]\n- When boundaries dimension is enabled, reports contain boundary targets and coverage.byDimension['boundaries'] metrics consistent with hand-calculated expectations on fixtures.\n- Boundary targets respect reachability rules and do not stay active for values proven to be outside the admissible domain.\n- generator and repair instrumentation uses existing numeric planning rules to choose representative values and does not require special-case numeric logic in the coverage layer.\n- Performance remains acceptable when boundaries are enabled; tests measure the added overhead and ensure it remains bounded.",
        "testStrategy": "Unit tests for boundary target discovery in CoverageAnalyzer; generator-focused tests that emit values exactly at or around bounds and assert boundary hit flags; tests that combine boundaries with multipleOf and verify unreachable cases are marked correctly; integration tests with coverage=guided where boundaries dimension is enabled and coverage.byDimension['boundaries'] behaves as expected.",
        "subtasks": [
          {
            "id": 9309001,
            "title": "Extend coverage model and analyzer for boundaries dimension",
            "description": "Add boundaries dimension kinds and discover boundary constraints in canonical schemas to create coverage targets.",
            "status": "pending",
            "estimatedHours": 4,
            "file": "packages/core/src/coverage/coverage-analyzer.ts",
            "parentId": "9309"
          },
          {
            "id": 9309002,
            "title": "Instrument generator for numeric and length boundary hits",
            "description": "Emit coverage events when numeric values, string lengths and array lengths hit boundary representatives.",
            "status": "pending",
            "estimatedHours": 4,
            "file": "packages/core/src/generator/foundry-generator.ts",
            "parentId": "9309"
          },
          {
            "id": 9309003,
            "title": "Handle unreachable or degenerate boundary targets",
            "description": "Use existing UNSAT diagnostics and numeric feasibility checks to mark unreachable boundaries appropriately.",
            "status": "pending",
            "estimatedHours": 3,
            "file": "packages/core/src/coverage/coverage-analyzer-unreachable.ts",
            "parentId": "9309"
          },
          {
            "id": 9309004,
            "title": "Add tests for boundary coverage semantics",
            "description": "Create fixtures and tests that validate inclusive vs exclusive, min==max and multipleOf interactions for boundary coverage, including cases where a boundary-hitting value that passes AJV remains unchanged by Repair unless another constraint requires a different value so boundary hits are not lost unnecessarily.",
            "status": "pending",
            "estimatedHours": 3,
            "file": "packages/core/src/coverage/__tests__/boundaries.spec.ts",
            "parentId": "9309"
          }
        ]
      },
      {
        "id": "9310",
        "title": "Implement OpenAPI per-operation coverage and byOperation metrics (M2)",
        "description": "Track coverage per OpenAPI operation, including OP_REQUEST_COVERED, OP_RESPONSE_COVERED, SCHEMA_REUSED_COVERED and coverage.byOperation ratios.",
        "priority": "medium",
        "estimatedHours": 16,
        "dependencies": [
          "9301",
          "9302",
          "9303",
          "9305"
        ],
        "status": "pending",
        "complexityScore": 4,
        "details": "[Context]\nExtend coverage-aware behavior to OpenAPI operations for M2, per §3.3 (Inter-schema / API coverage), §3.5 (Metrics & semantics) and §9 (M2 – Boundaries, OpenAPI & diff). The system must compute per-operation coverage metrics and define OP_REQUEST_COVERED, OP_RESPONSE_COVERED and SCHEMA_REUSED_COVERED targets based on deterministic schema selection rules.\n\n[Key requirements]\n- Extend CoverageAnalyzer with an OpenAPI-aware layer to build OperationNode entries and attach schema nodes for request and response payloads, with operationKey defined as operationId or <METHOD> <path> when operationId is absent. This layer builds on the schema-level CoverageGraph produced by task 9301 without changing existing target IDs.\n- Treat operation-level targets (OP_REQUEST_COVERED, OP_RESPONSE_COVERED, SCHEMA_REUSED_COVERED) as belonging to the 'operations' coverage dimension and only materialize them when 'operations' is present in run.dimensionsEnabled; when 'operations' is absent, the analyzer may still build internal operation mappings but MUST NOT emit operation-level CoverageTargets in targets[] for standard modes.\n- Implement OP_REQUEST_COVERED and OP_RESPONSE_COVERED targets per operationKey in the 'operations' coverage dimension and map schema-level targets (structure, branches, enum, boundaries) reachable from each operation to that operation for coverage.byOperation computation.\n- Implement SCHEMA_REUSED_COVERED as a diagnostic-only target kind for canonical schemas reused across multiple operations; these targets must be emitted and visible in targets/uncoveredTargets and diagnostics with status:'deprecated' but excluded from metrics.overall, metrics.byDimension, metrics.byOperation and minCoverage.\n- Implement deterministic request/response schema selection for JSON media types in line with the spec (lexicographic media type order, preference for 200 and 2xx JSON responses).\n- Populate run.operationsScope and run.selectedOperations in the coverage report when only a subset of operations is targeted, and ensure only in-scope operations contribute to coverage.byOperation and activeTargetsTotal; metrics.byOperation and selectedOperations must always be interpreted within the declared operationsScope.\n- Integrate coverage.byOperation into CLI summary output (task 9304), highlighting least-covered operations in a deterministic order.\n\n[Deliverables]\n- Operation-aware target generation in CoverageAnalyzer under packages/core/src/coverage/coverage-analyzer-openapi.ts.\n- Mapping logic from schema targets to operations for coverage.byOperation metrics in CoverageEvaluator.\n- CLI support for operation selection flags (if not already present) that set operationsScope and selectedOperations in the report.\n\n[Definition of Done]\n- For an OpenAPI fixture with multiple operations (with and without operationId), coverage reports include coverage.byOperation[operationKey] entries with expected ratios.\n- OP_REQUEST_COVERED and OP_RESPONSE_COVERED targets behave as specified, and schema-level targets reachable from each operation are correctly attributed without changing schema-level IDs defined by 9301.\n- SCHEMA_REUSED_COVERED targets are emitted for schemas used in more than one operation, are hit when those schemas are instantiated at least once, and are clearly diagnostic-only so that metrics and thresholds are unaffected via status:'deprecated' in the 'operations' dimension.\n- operationsScope and selectedOperations fields behave as specified when running against a subset of operations, and toggling operationsScope or selectedOperations never changes schema-level CoverageTarget.id values.\n- CLI summary shows per-operation coverage and highlights the least-covered operations in a deterministic order.",
        "testStrategy": "Unit tests for operation selection and target construction using small OpenAPI specs with multiple operations and content types; evaluator tests for coverage.byOperation mapping and ratios honoring dimensionsEnabled; tests confirming SCHEMA_REUSED_COVERED targets are emitted with status:'deprecated', remain visible in targets/uncoveredTargets and do not affect metrics.overall, metrics.byDimension or metrics.byOperation; tests that run coverage on an OpenAPI fixture with 'operations' present and absent in dimensionsEnabled and assert that schema-level CoverageTarget.id values remain unchanged while OP_* targets are only present and counted when 'operations' is enabled; CLI integration tests that generate coverage for selected operations and assert operationsScope, selectedOperations and byOperation metrics in the JSON report and summary output.",
        "subtasks": [
          {
            "id": 9310001,
            "title": "Build OperationNode mapping and operationKey derivation",
            "description": "Extend CoverageAnalyzer with OpenAPI-specific logic to create OperationNodes and derive operationKey from operationId or HTTP method and path.",
            "status": "pending",
            "estimatedHours": 4,
            "file": "packages/core/src/coverage/coverage-analyzer-openapi.ts",
            "parentId": "9310"
          },
          {
            "id": 9310002,
            "title": "Implement OP_REQUEST_COVERED, OP_RESPONSE_COVERED and SCHEMA_REUSED_COVERED targets",
            "description": "Create operation-level coverage targets for request and response schemas and diagnostic-only SCHEMA_REUSED_COVERED targets for schemas reused across operations, and mark hits when at least one payload is generated.",
            "status": "pending",
            "estimatedHours": 4,
            "file": "packages/core/src/coverage/coverage-analyzer-openapi.ts",
            "parentId": "9310"
          },
          {
            "id": 9310003,
            "title": "Map schema targets to operations for coverage.byOperation",
            "description": "Implement deterministic mapping from schema-level targets to operation keys and compute coverage.byOperation ratios, without changing schema-level CoverageTarget.id values.",
            "status": "pending",
            "estimatedHours": 4,
            "file": "packages/core/src/coverage/coverage-evaluator.ts",
            "parentId": "9310"
          },
          {
            "id": 9310004,
            "title": "Add tests and fixtures for OpenAPI coverage behavior",
            "description": "Write tests on OpenAPI fixtures that validate per-operation metrics, operationKey shapes, operationsScope semantics and SCHEMA_REUSED_COVERED diagnostics.",
            "status": "pending",
            "estimatedHours": 4,
            "file": "packages/core/src/coverage/__tests__/openapi-coverage.spec.ts",
            "parentId": "9310"
          }
        ]
      },
      {
        "id": "9311",
        "title": "Add coverage diff tool for multi-run comparison (M2)",
        "description": "Provide a coverage diff command that compares two coverage-report/v1 files and highlights regressions, added and removed targets.",
        "priority": "medium",
        "estimatedHours": 10,
        "dependencies": [
          "9303"
        ],
        "status": "pending",
        "complexityScore": 3,
        "details": "[Context]\nImplement a coverage diff tool as described in §7.4 (Multi-run diff). The tool compares two coverage-report/v1 JSON files produced by compatible engine majors and report versions and surfaces changes in metrics and target statuses, suitable for CI regression checks.\n\n[Key requirements]\n- Implement a diff algorithm that classifies targets into unchanged, added, removed and statusChanged, based on id and identifying shape (dimension, kind, canonPath).\n- Compute and present deltas for metrics.overall and metrics.byOperation between the two reports, highlighting regressions; metric deltas must be computed over the common universe of targets and dimensions (targets present in both reports and dimensions enabled on both sides), while targets from newly enabled dimensions are treated as added and reported explicitly.\n- Identify newly uncovered targets (present in the newer report and uncovered, or that transitioned from hit:true to hit:false) and present them explicitly rather than folding into aggregate regressions.\n- Ensure diff is only considered valid when both reports share the same coverage-report version and compatible FoundryData major (and, for byOperation deltas, a compatible operationsScope); otherwise surface a clear error.\n- Provide a CLI entrypoint (e.g. foundrydata coverage diff A.json B.json) that prints a textual summary and can return a non-zero exit code on regressions if desired.\n\n[Deliverables]\n- Diff implementation in packages/reporter/src/coverage/coverage-diff.ts.\n- CLI command wiring in packages/cli/src/commands/coverage-diff.ts.\n- Tests and JSON fixtures for typical diff scenarios, including added/removed targets and status changes.\n\n[Commands]\n- npm run build\n- npm run test -- --runInBand\n- npm run test packages/reporter/src/coverage/__tests__/coverage-diff.spec.ts\n\n[Definition of Done]\n- coverage diff command correctly identifies target categories and metric deltas on synthetic and real coverage reports.\n- Incompatible versions, engine majors or irreconcilable operationsScope differences are rejected with clear diagnostics, and diff does not attempt to compare incompatible reports.\n- CLI output includes a concise summary of metrics.overall delta, per-operation regressions and lists of newly uncovered targets.\n- Tests cover edge cases such as empty reports, operations added or removed, dimensions newly enabled or disabled and targets changing status to or from unreachable.",
        "testStrategy": "Unit tests for coverage diff classification using small synthetic reports; integration tests that run coverage twice on modified schemas and then call the diff command to validate reported deltas; tests for error handling when versions or engine majors are incompatible; snapshot tests for the CLI diff summary output.",
        "subtasks": [
          {
            "id": 9311001,
            "title": "Implement CoverageReport diff classification logic",
            "description": "Compare two CoverageReports and classify targets as unchanged, added, removed or statusChanged, including hit changes.",
            "status": "pending",
            "estimatedHours": 4,
            "file": "packages/reporter/src/coverage/coverage-diff.ts",
            "parentId": "9311"
          },
          {
            "id": 9311002,
            "title": "Compute metric deltas and regressions",
            "description": "Compute changes in metrics.overall and metrics.byOperation over targets present in both reports (unchanged + statusChanged) and expose them in a diff summary structure, reporting newly added uncovered targets separately as new gaps.",
            "status": "pending",
            "estimatedHours": 2,
            "file": "packages/reporter/src/coverage/coverage-diff.ts",
            "parentId": "9311"
          },
          {
            "id": 9311003,
            "title": "Add CLI command for foundrydata coverage diff",
            "description": "Add a CLI command that reads two JSON coverage reports, runs the diff and prints a human-readable summary.",
            "status": "pending",
            "estimatedHours": 2,
            "file": "packages/cli/src/commands/coverage-diff.ts",
            "parentId": "9311"
          },
          {
            "id": 9311004,
            "title": "Add fixtures and tests for coverage diff behavior",
            "description": "Create JSON fixtures and tests for typical diff scenarios, including regressions and added/removed targets.",
            "status": "pending",
            "estimatedHours": 2,
            "file": "packages/reporter/src/coverage/__tests__/coverage-diff.spec.ts",
            "parentId": "9311"
          }
        ]
      },
      {
        "id": "9312",
        "title": "Validate coverage invariants, determinism and acceptance scenarios",
        "description": "Add cross-cutting tests and documentation that ensure coverage-aware behavior respects core invariants and satisfies all acceptance criteria.",
        "priority": "medium",
        "estimatedHours": 12,
        "dependencies": [
          "9302",
          "9303",
          "9304",
          "9305",
          "9306",
          "9307",
          "9308",
          "9309",
          "9310"
        ],
        "status": "pending",
        "complexityScore": 4,
        "details": "[Context]\nConsolidate cross-cutting coverage tests and docs to ensure the coverage layer respects the core pipeline invariants and satisfies the acceptance criteria listed in §10 (Acceptance criteria) and constraints in §8 (Technical constraints & invariants). This includes determinism, AJV-as-oracle behavior, no network I/O in coverage stages and compatibility with CoverageIndex under AP:false.\n\n[Key requirements]\n- Add end-to-end tests for each acceptance scenario: oneOf branches, optional properties, enums, coverage threshold, OpenAPI coverage and reproducibility of coverage reports for identical inputs.\n- Verify that coverage-aware pipeline runs preserve AJV-as-oracle behavior: final validation still uses the original schema and coverage logic never re-parses or re-interprets JSON Schema semantics independently.\n- Confirm deterministic behavior: for fixed (canonical schema, OpenAPI spec, coverage options, seed, AJV major, registryFingerprint), CoverageGraph, TestUnits, generated instances and coverage reports are identical across runs.\n- Ensure coverage stages do not introduce network I/O and remain compatible with existing external $ref resolver behavior and CoverageIndex invariants under AP:false.\n- Document coverage invariants and known limitations in docs to align with existing architecture and known-limits documents.\n\n[Deliverables]\n- Acceptance-focused e2e test suite in packages/core/test/e2e/coverage-acceptance.spec.ts.\n- Determinism tests and tooling to compare coverage reports across multiple runs.\n- Documentation updates in docs/spec-coverage-aware-v1.x and high-level README/Architecture notes.\n\n[Commands]\n- npm run build\n- npm run test -- --runInBand\n- npm run test packages/core/test/e2e/coverage-acceptance.spec.ts\n\n[Definition of Done]\n- All acceptance scenarios from the spec are covered by automated tests that assert expected coverage metrics, exit codes and report content.\n- Reproducibility tests confirm that repeated runs produce byte-identical coverage reports except for allowed timestamp fields.\n- Additional tests confirm there is no network I/O in coverage stages and that CoverageIndex semantics under AP:false are preserved.\n- Documentation for coverage invariants, determinism and limitations is merged and aligned with existing architecture and invariants docs.",
        "testStrategy": "End-to-end Vitest suites exercising coverage-aware runs over small JSON Schema and OpenAPI fixtures, asserting each acceptance criterion; determinism tests that run the same configuration multiple times and compare normalized coverage reports; tests that instrument or mock network layers to ensure coverage stages remain I/O-free; manual and code-reviewed documentation updates that describe coverage invariants and how they relate to the existing core pipeline contracts, including status:'deprecated' semantics for diagnostic-only targets such as SCHEMA_REUSED_COVERED and the use of status:'unreachable' (rather than a dedicated unreachableTargets array) to represent unreachable targets in coverage-report/v1.",
        "subtasks": [
          {
            "id": 9312001,
            "title": "Implement acceptance tests for oneOf, optional properties and enums",
            "description": "Add e2e tests that validate oneOf branch coverage, PROPERTY_PRESENT behavior and enum coverage under measure and guided modes.",
            "status": "pending",
            "estimatedHours": 4,
            "file": "packages/core/test/e2e/coverage-acceptance.spec.ts",
            "parentId": "9312"
          },
          {
            "id": 9312002,
            "title": "Add tests for minCoverage and coverage threshold behavior",
            "description": "Create tests that assert coverageStatus, CLI exit codes and summary output when minCoverage is not met.",
            "status": "pending",
            "estimatedHours": 2,
            "file": "packages/core/test/e2e/coverage-acceptance.spec.ts",
            "parentId": "9312"
          },
          {
            "id": 9312003,
            "title": "Add OpenAPI coverage and reproducibility tests",
            "description": "Add e2e tests that validate coverage.byOperation, OP_* targets and reproducibility of coverage reports across identical runs.",
            "status": "pending",
            "estimatedHours": 3,
            "file": "packages/core/test/e2e/coverage-openapi-acceptance.spec.ts",
            "parentId": "9312"
          },
          {
            "id": 9312004,
            "title": "Document coverage invariants and limitations",
            "description": "Update architecture and invariants docs to describe coverage-specific constraints and how they compose with existing pipeline guarantees. Document that diagnostic-only targets such as SCHEMA_REUSED_COVERED are emitted with status:'deprecated' so they are excluded from all coverage denominators while remaining visible in reports, and that unreachable targets are identified by status:'unreachable' in CoverageTargetReport entries with no separate unreachableTargets array in coverage-report/v1; consumers must derive unreachable views by filtering on status.",
            "status": "pending",
            "estimatedHours": 3,
            "file": "docs/spec-coverage-aware-v1.x.md",
            "parentId": "9312"
          }
        ]
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-11-28T20:15:31.395Z",
      "taskCount": 13,
      "completedCount": 4,
      "tags": [
        "coverage-aware-v1"
      ]
    }
  }
}
{
  "project": "FoundryData",
  "version": "0.1.0-mvp",
  "approach": "Hybrid (Task Master structure + granular subtasks)",
  "feature-simplification": {
    "tasks": [
      {
        "id": 8000,
        "title": "AGENT — Operating mode for Claude Code",
        "description": "Execution discipline and guardrails for building from SPEC via anchors only.",
        "priority": "medium",
        "estimatedHours": 0,
        "dependencies": [],
        "status": "done",
        "complexityScore": 1,
        "details": "[Agent Instructions — Minimal + Guardrails]\n[Goal]\n\n* Execute implementation tasks strictly per SPEC; SPEC is the single source of truth for semantics. Do not enlarge feature scope.\n  [Retrieval]\n* REFONLY via SPEC anchors. Do not paste SPEC text verbatim into tasks.\n* Runtime mapping: spec://§<n>#<slug> → docs/feature-simplification/feature-support-simplification.md#s<n>-<slug>.\n* Keep working context small: load only anchors required by the current task.\n  [Execution order]\n\n1. Read §0 metadata (task 9000).\n2. Build the reference index from 9100..9124 (anchors only).\n3. Implement tasks 1..24 in numeric order, respecting declared dependencies.\n4. Run tests and bench; validate Definition of Done.\n5. **Staging**: For `propertyNames` rewrite, implement **enum-only** in P0; **pattern-form** deferred to **P2 (#23)**.\n   [Environment]\n\n* Node >= 18; TypeScript; pnpm; monorepo layout under packages/core/* (per SPEC §22).\n  [Commands]\n* pnpm i\n* pnpm -w build\n* pnpm -w test\n* pnpm -w bench\n  [Diagnostics — phase separation]\n* REGEX_COMPLEXITY_CAPPED appears only from Normalize/Compose, with details.context ∈ {'coverage','rewrite'}.\n* COMPLEXITY_CAP_PATTERNS appears only from the Generator (pattern-witness search).\n* Compose-time caps (COMPLEXITY_CAP_ONEOF/ANYOF/ENUM/CONTAINS/SCHEMA_SIZE) are planning-only; never emit them from the Generator.\n  [Branch bookkeeping (per SPEC §8)]\n* Score-only path: record diag.scoreDetails.tiebreakRand EVEN WHEN |T|=1.\n* Score-only budget: diag.budget = { skipped:true, tried:0, limit = trials.perBranch × K_effective, reason ∈ {'skipTrialsFlag','largeOneOf','largeAnyOf','complexityCap'} }, where K_effective = min(maxBranchesToTry, branches.length AFTER Compose-time caps).\n* oneOf exclusivity step-4: if RNG is used (only when b* no longer passes), record diag.scoreDetails.exclusivityRand.\n  [AP:false coverage guardrails]\n* Under additionalProperties:false, NEVER expand coverage from propertyNames.enum unless PNAMES_REWRITE_APPLIED is present.\n* Fail-fast (AP_FALSE_UNSAFE_PATTERN) ONLY when presence pressure exists at the object (effectiveMinProperties > 0 OR effectiveRequiredKeys ≠ ∅ OR an active dependentRequired antecedent). Otherwise, proceed via conservative exclusion (no fail-fast).\n* Raw propertyNames.pattern NEVER triggers AP_FALSE_UNSAFE_PATTERN; it is gating-only unless PNAMES_REWRITE_APPLIED.\n  [Unevaluated guard]\n* For unevaluatedProperties:false, only emit property names guaranteed “evaluated” by an applicator at the SAME instance location, either present directly OR reachable through an APPLIED subschema at that location (e.g., allOf conjuncts, the selected anyOf/oneOf branch, the active then/else of if, or a $ref target). dependentSchemas does not evaluate by itself; only applicators inside its active subschema do.\n  [AJV Config Gate (per SPEC §§12–13)]\n* Two Ajv instances: Source (original schema) and Planning/Generation (canonical view). Both MUST set unicodeRegExp:true.\n* Ajv class MUST match the source schema dialect (Ajv / Ajv2019 / Ajv2020 / ajv-draft-04). Do not mix 2020-12 with earlier drafts in the same instance.\n* validateFormats MUST be identical on both instances (both false, or both true with ajv-formats). Mismatches ⇒ AJV_FLAGS_MISMATCH.\n* allowUnionTypes policy consistent with responsibilities (enabled on Planning/Generation when compiling union-typed canonical views).\n* If discriminator is claimed, set discriminator:true on BOTH instances; otherwise disabled on both.\n* multipleOfPrecision MUST equal PlanOptions.rational.decimalPrecision on BOTH instances whenever rational.fallback ∈ {'decimal','float'}; mismatches ⇒ AJV_FLAGS_MISMATCH.\n  [Definition of Done]\n* Files delivered per subtasks; tests green with ≥80% coverage on touched files.\n* Diagnostics conform to SPEC §19.1 mini-schemas.\n* Final AJV validation runs against the original schema (not the canonical/effective view).\n* Bench gates (SPEC §15) satisfied: p95LatencyMs ≤ 120 ms and memoryPeakMB ≤ 512 MB on required profiles.\n  [Diagnostics verbosity]\n* Provide a verbosity toggle: “CI verbose” (full diagnostics/metrics) vs “runtime normal” (reduced payloads) **without** changing §19.1 shapes.\n  [Self-audit before emit]\n* All SPEC task records 9100..9124: details = REFONLY; no SPEC text duplicated elsewhere.\n* Validate REFONLY: outer JSON parses; after stripping `REFONLY::`, inner JSON parses; reject if invalid.\n* Branch selection score-only invariants satisfied (tiebreakRand, budget.skipped/tried/limit/reason as above).\n* oneOf exclusivity: if RNG used at step-4, exclusivityRand recorded.\n* No REGEX_COMPLEXITY_CAPPED from Generator; no COMPLEXITY_CAP_PATTERNS from Normalize/Compose/Rewrite.\n* AP:false: no coverage expansion from propertyNames without PNAMES_REWRITE_APPLIED.\n* Repair rename guard under AP:false: use ctx.isNameInMustCover(canonPath, name) from Compose’s CoverageIndex; if absent, do NOT rename and emit MUSTCOVER_INDEX_MISSING{guard:true}.\n* External $ref handling: Strict ⇒ error EXTERNAL_REF_UNRESOLVED; Lax ⇒ warn + attempt; if Source Ajv compile fails solely due to unresolved externals, skip final validation with details.skippedValidation:true and set diag.metrics.validationsPerRow = 0.\n* Unique subtask ids are enforced (e.g., taskId*1000 + ordinal).",
        "testStrategy": "N/A — process guardrails only.",
        "subtasks": [
          {
            "id": 8000001,
            "title": "Author AGENT runbook (execution order, guardrails, DoD)",
            "status": "done",
            "estimatedHours": 0,
            "file": "docs/AGENT_RUNBOOK.md",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 9000,
        "title": "SPEC — Canonical Source (header & metadata)",
        "description": "Reference-only: section §0.",
        "priority": "low",
        "estimatedHours": 0,
        "dependencies": [],
        "status": "done",
        "complexityScore": 1,
        "details": "REFONLY::{\"source\":\"FILE\",\"uri\":\"docs/feature-simplification/feature-support-simplification.md\",\"section\":\"§0\",\"anchors\":[\"spec://§0#status\",\"spec://§0#audience\"],\"notes\":\"no-embed; fetch-on-demand\"}",
        "testStrategy": "None.",
        "subtasks": [
          {
            "id": 9000001,
            "title": "Index anchor — status",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§0#status",
            "parentId": "undefined"
          },
          {
            "id": 9000002,
            "title": "Index anchor — audience",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§0#audience",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 9050,
        "title": "SPEC — Maintenance / Evolution",
        "description": "Reference-only: section §24.",
        "priority": "low",
        "estimatedHours": 0,
        "dependencies": [
          "9000"
        ],
        "status": "done",
        "complexityScore": 1,
        "details": "REFONLY::{\"source\":\"FILE\",\"uri\":\"docs/feature-simplification/feature-support-simplification.md\",\"section\":\"§24\",\"anchors\":[\"spec://§24#normative\",\"spec://§24#alignment\"],\"notes\":\"no-embed; fetch-on-demand\"}",
        "testStrategy": "None.",
        "subtasks": [
          {
            "id": 9050001,
            "title": "Index anchor — normative references",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§24#normative",
            "parentId": "undefined"
          },
          {
            "id": 9050002,
            "title": "Index anchor — reference alignment",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§24#alignment",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 9100,
        "title": "Terminology (preamble — quick ref)",
        "description": "Reference-only: section §0.",
        "priority": "low",
        "estimatedHours": 0,
        "dependencies": [
          "9000"
        ],
        "status": "done",
        "complexityScore": 1,
        "details": "REFONLY::{\"source\":\"FILE\",\"uri\":\"docs/feature-simplification/feature-support-simplification.md\",\"section\":\"§0\",\"anchors\":[\"spec://§0#terminology\",\"spec://§0#definitions\"],\"notes\":\"no-embed; fetch-on-demand\"}",
        "testStrategy": "None.",
        "subtasks": [
          {
            "id": 9100001,
            "title": "Index anchor — terminology",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§0#terminology",
            "parentId": "undefined"
          },
          {
            "id": 9100002,
            "title": "Index anchor — definitions",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§0#definitions",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 9101,
        "title": "§1 Goal",
        "description": "Reference-only: section §1.",
        "priority": "low",
        "estimatedHours": 0,
        "dependencies": [
          "9000"
        ],
        "status": "done",
        "complexityScore": 1,
        "details": "REFONLY::{\"source\":\"FILE\",\"uri\":\"docs/feature-simplification/feature-support-simplification.md\",\"section\":\"§1\",\"anchors\":[\"spec://§1#goal\",\"spec://§1#acceptance\",\"spec://§1#bench-sli-gate\",\"spec://§1#config-gate\"],\"notes\":\"no-embed; fetch-on-demand\"}",
        "testStrategy": "None.",
        "subtasks": [
          {
            "id": 9101001,
            "title": "Index anchor — goal",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§1#goal",
            "parentId": "undefined"
          },
          {
            "id": 9101002,
            "title": "Index anchor — acceptance",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§1#acceptance",
            "parentId": "undefined"
          },
          {
            "id": 9101003,
            "title": "Index anchor — bench SLI gate",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§1#bench-sli-gate",
            "parentId": "undefined"
          },
          {
            "id": 9101004,
            "title": "Index anchor — config gate",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§1#config-gate",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 9102,
        "title": "§2 Scope",
        "description": "Reference-only: section §2.",
        "priority": "low",
        "estimatedHours": 0,
        "dependencies": [
          "9000"
        ],
        "status": "done",
        "complexityScore": 1,
        "details": "REFONLY::{\"source\":\"FILE\",\"uri\":\"docs/feature-simplification/feature-support-simplification.md\",\"section\":\"§2\",\"anchors\":[\"spec://§2#in-scope\",\"spec://§2#non-goals\",\"spec://§2#environment\",\"spec://§2#modes\"],\"notes\":\"no-embed; fetch-on-demand\"}",
        "testStrategy": "None.",
        "subtasks": [
          {
            "id": 9102001,
            "title": "Index anchor — in-scope",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§2#in-scope",
            "parentId": "undefined"
          },
          {
            "id": 9102002,
            "title": "Index anchor — non-goals",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§2#non-goals",
            "parentId": "undefined"
          },
          {
            "id": 9102003,
            "title": "Index anchor — environment & drafts",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§2#environment",
            "parentId": "undefined"
          },
          {
            "id": 9102004,
            "title": "Index anchor — modes",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§2#modes",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 9103,
        "title": "§3 Principles & Invariants",
        "description": "Reference-only: section §3.",
        "priority": "low",
        "estimatedHours": 0,
        "dependencies": [
          "9000"
        ],
        "status": "done",
        "complexityScore": 1,
        "details": "REFONLY::{\"source\":\"FILE\",\"uri\":\"docs/feature-simplification/feature-support-simplification.md\",\"section\":\"§3\",\"anchors\":[\"spec://§3#core-principles\",\"spec://§3#invariants\",\"spec://§3#apfalse-unsafe-pattern-policy\"],\"notes\":\"no-embed; fetch-on-demand\"}",
        "testStrategy": "None.",
        "subtasks": [
          {
            "id": 9103001,
            "title": "Index anchor — core principles",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§3#core-principles",
            "parentId": "undefined"
          },
          {
            "id": 9103002,
            "title": "Index anchor — invariants",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§3#invariants",
            "parentId": "undefined"
          },
          {
            "id": 9103003,
            "title": "Index anchor — AP:false unsafe-pattern policy",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§3#apfalse-unsafe-pattern-policy",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 9104,
        "title": "§4 Operational guidance",
        "description": "Reference-only: section §4.",
        "priority": "low",
        "estimatedHours": 0,
        "dependencies": [
          "9000"
        ],
        "status": "done",
        "complexityScore": 1,
        "details": "REFONLY::{\"source\":\"FILE\",\"uri\":\"docs/feature-simplification/feature-support-simplification.md\",\"section\":\"§4\",\"anchors\":[\"spec://§4#pipeline\",\"spec://§4#observability\",\"spec://§4#fail-early\"],\"notes\":\"no-embed; fetch-on-demand\"}",
        "testStrategy": "None.",
        "subtasks": [
          {
            "id": 9104001,
            "title": "Index anchor — pipeline",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§4#pipeline",
            "parentId": "undefined"
          },
          {
            "id": 9104002,
            "title": "Index anchor — observability",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§4#observability",
            "parentId": "undefined"
          },
          {
            "id": 9104003,
            "title": "Index anchor — fail-early",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§4#fail-early",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 9105,
        "title": "§5 Configuration Overview",
        "description": "Reference-only: section §5.",
        "priority": "low",
        "estimatedHours": 0,
        "dependencies": [
          "9000"
        ],
        "status": "done",
        "complexityScore": 1,
        "details": "REFONLY::{\"source\":\"FILE\",\"uri\":\"docs/feature-simplification/feature-support-simplification.md\",\"section\":\"§5\",\"anchors\":[\"spec://§5#options-table\",\"spec://§5#pattern-witness\",\"spec://§5#precedence\"],\"notes\":\"no-embed; fetch-on-demand\"}",
        "testStrategy": "None.",
        "subtasks": [
          {
            "id": 9105001,
            "title": "Index anchor — options table",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§5#options-table",
            "parentId": "undefined"
          },
          {
            "id": 9105002,
            "title": "Index anchor — pattern witness options",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§5#pattern-witness",
            "parentId": "undefined"
          },
          {
            "id": 9105003,
            "title": "Index anchor — precedence & compatibility",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§5#precedence",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 9106,
        "title": "§6 High-Level Architecture",
        "description": "Reference-only: section §6.",
        "priority": "low",
        "estimatedHours": 0,
        "dependencies": [
          "9000"
        ],
        "status": "done",
        "complexityScore": 1,
        "details": "REFONLY::{\"source\":\"FILE\",\"uri\":\"docs/feature-simplification/feature-support-simplification.md\",\"section\":\"§6\",\"anchors\":[\"spec://§6#phases\"],\"notes\":\"no-embed; fetch-on-demand\"}",
        "testStrategy": "None.",
        "subtasks": [
          {
            "id": 9106001,
            "title": "Index anchor — phases",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§6#phases",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 9107,
        "title": "§7 Schema Normalizer (Canonicalization)",
        "description": "Reference-only: section §7.",
        "priority": "low",
        "estimatedHours": 0,
        "dependencies": [
          "9000"
        ],
        "status": "done",
        "complexityScore": 1,
        "details": "REFONLY::{\"source\":\"FILE\",\"uri\":\"docs/feature-simplification/feature-support-simplification.md\",\"section\":\"§7\",\"anchors\":[\"spec://§7#object-keywords-pnames-rewrite\",\"spec://§7#conditionals-rewrite\",\"spec://§7#pass-order\",\"spec://§7#note-codes\"],\"notes\":\"no-embed; fetch-on-demand\"}",
        "testStrategy": "None.",
        "subtasks": [
          {
            "id": 9107001,
            "title": "Index anchor — propertyNames rewrite",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§7#object-keywords-pnames-rewrite",
            "parentId": "undefined"
          },
          {
            "id": 9107002,
            "title": "Index anchor — conditionals rewrite",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§7#conditionals-rewrite",
            "parentId": "undefined"
          },
          {
            "id": 9107003,
            "title": "Index anchor — pass order",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§7#pass-order",
            "parentId": "undefined"
          },
          {
            "id": 9107004,
            "title": "Index anchor — normalizer note codes",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§7#note-codes",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 9108,
        "title": "§8 Composition Engine",
        "description": "Reference-only: section §8.",
        "priority": "low",
        "estimatedHours": 0,
        "dependencies": [
          "9000"
        ],
        "status": "done",
        "complexityScore": 1,
        "details": "REFONLY::{\"source\":\"FILE\",\"uri\":\"docs/feature-simplification/feature-support-simplification.md\",\"section\":\"§8\",\"anchors\":[\"spec://§8#coverage-index-export\",\"spec://§8#coverage-index-enumerate\",\"spec://§8#branch-selection\",\"spec://§8#oneof-exclusivity\",\"spec://§8#anchored-safe-definition\",\"spec://§8#regex-complexity-cap\",\"spec://§8#apfalse-must-cover\"],\"notes\":\"no-embed; fetch-on-demand\"}",
        "testStrategy": "None.",
        "subtasks": [
          {
            "id": 9108001,
            "title": "Index anchor — Coverage Index export",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§8#coverage-index-export",
            "parentId": "undefined"
          },
          {
            "id": 9108002,
            "title": "Index anchor — enumerate order",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§8#coverage-index-enumerate",
            "parentId": "undefined"
          },
          {
            "id": 9108003,
            "title": "Index anchor — branch selection",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§8#branch-selection",
            "parentId": "undefined"
          },
          {
            "id": 9108004,
            "title": "Index anchor — oneOf exclusivity",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§8#oneof-exclusivity",
            "parentId": "undefined"
          },
          {
            "id": 9108005,
            "title": "Index anchor — anchored-safe definition",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§8#anchored-safe-definition",
            "parentId": "undefined"
          },
          {
            "id": 9108006,
            "title": "Index anchor — regex complexity cap",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§8#regex-complexity-cap",
            "parentId": "undefined"
          },
          {
            "id": 9108007,
            "title": "Index anchor — AP:false must-cover",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§8#apfalse-must-cover",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 9109,
        "title": "§9 Generator",
        "description": "Reference-only: section §9.",
        "priority": "low",
        "estimatedHours": 0,
        "dependencies": [
          "9000"
        ],
        "status": "done",
        "complexityScore": 1,
        "details": "REFONLY::{\"source\":\"FILE\",\"uri\":\"docs/feature-simplification/feature-support-simplification.md\",\"section\":\"§9\",\"anchors\":[\"spec://§9#if-aware-lite\",\"spec://§9#pattern-witness-selection\",\"spec://§9#arrays-contains\"],\"notes\":\"no-embed; fetch-on-demand\"}",
        "testStrategy": "None.",
        "subtasks": [
          {
            "id": 9109001,
            "title": "Index anchor — if-aware-lite",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§9#if-aware-lite",
            "parentId": "undefined"
          },
          {
            "id": 9109002,
            "title": "Index anchor — pattern witness selection",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§9#pattern-witness-selection",
            "parentId": "undefined"
          },
          {
            "id": 9109003,
            "title": "Index anchor — arrays contains (bag)",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§9#arrays-contains",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 9110,
        "title": "§10 Repair Engine (AJV-Driven)",
        "description": "Reference-only: section §10.",
        "priority": "low",
        "estimatedHours": 0,
        "dependencies": [
          "9000"
        ],
        "status": "done",
        "complexityScore": 1,
        "details": "REFONLY::{\"source\":\"FILE\",\"uri\":\"docs/feature-simplification/feature-support-simplification.md\",\"section\":\"§10\",\"anchors\":[\"spec://§10#mapping\",\"spec://§10#propertynames-rename-guard\",\"spec://§10#structural-hashing\",\"spec://§10#epsilon-logging\",\"spec://§10#property-order\",\"spec://§10#mustcover-index-missing\"],\"notes\":\"no-embed; fetch-on-demand\"}",
        "testStrategy": "None.",
        "subtasks": [
          {
            "id": 9110001,
            "title": "Index anchor — mapping",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§10#mapping",
            "parentId": "undefined"
          },
          {
            "id": 9110002,
            "title": "Index anchor — propertyNames rename guard",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§10#propertynames-rename-guard",
            "parentId": "undefined"
          },
          {
            "id": 9110003,
            "title": "Index anchor — structural hashing",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§10#structural-hashing",
            "parentId": "undefined"
          },
          {
            "id": 9110004,
            "title": "Index anchor — epsilon logging",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§10#epsilon-logging",
            "parentId": "undefined"
          },
          {
            "id": 9110005,
            "title": "Index anchor — property order",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§10#property-order",
            "parentId": "undefined"
          },
          {
            "id": 9110006,
            "title": "Index anchor — MUSTCOVER index missing",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§10#mustcover-index-missing",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 9111,
        "title": "§11 Modes",
        "description": "Reference-only: section §11.",
        "priority": "low",
        "estimatedHours": 0,
        "dependencies": [
          "9000"
        ],
        "status": "done",
        "complexityScore": 1,
        "details": "REFONLY::{\"source\":\"FILE\",\"uri\":\"docs/feature-simplification/feature-support-simplification.md\",\"section\":\"§11\",\"anchors\":[\"spec://§11#external-ref-probe\"],\"notes\":\"no-embed; fetch-on-demand\"}",
        "testStrategy": "None.",
        "subtasks": [
          {
            "id": 9111001,
            "title": "Index anchor — external ref probe (Lax eligibility)",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§11#external-ref-probe",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 9112,
        "title": "§12 Draft Handling",
        "description": "Reference-only: section §12.",
        "priority": "low",
        "estimatedHours": 0,
        "dependencies": [
          "9000"
        ],
        "status": "done",
        "complexityScore": 1,
        "details": "REFONLY::{\"source\":\"FILE\",\"uri\":\"docs/feature-simplification/feature-support-simplification.md\",\"section\":\"§12\",\"anchors\":[\"spec://§12#ajv-class-selection\",\"spec://§12#refs-and-dynamic\"],\"notes\":\"no-embed; fetch-on-demand\"}",
        "testStrategy": "None.",
        "subtasks": [
          {
            "id": 9112001,
            "title": "Index anchor — Ajv class selection",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§12#ajv-class-selection",
            "parentId": "undefined"
          },
          {
            "id": 9112002,
            "title": "Index anchor — refs and dynamic refs",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§12#refs-and-dynamic",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 9113,
        "title": "§13 AJV Configuration",
        "description": "Reference-only: section §13.",
        "priority": "low",
        "estimatedHours": 0,
        "dependencies": [
          "9000"
        ],
        "status": "done",
        "complexityScore": 1,
        "details": "REFONLY::{\"source\":\"FILE\",\"uri\":\"docs/feature-simplification/feature-support-simplification.md\",\"section\":\"§13\",\"anchors\":[\"spec://§13#startup-config-check\"],\"notes\":\"no-embed; fetch-on-demand\"}",
        "testStrategy": "None.",
        "subtasks": [
          {
            "id": 9113001,
            "title": "Index anchor — startup config check",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§13#startup-config-check",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 9114,
        "title": "§14 Cache Strategy",
        "description": "Reference-only: section §14.",
        "priority": "low",
        "estimatedHours": 0,
        "dependencies": [
          "9000"
        ],
        "status": "done",
        "complexityScore": 1,
        "details": "REFONLY::{\"source\":\"FILE\",\"uri\":\"docs/feature-simplification/feature-support-simplification.md\",\"section\":\"§14\",\"anchors\":[\"spec://§14#stable-hash\",\"spec://§14#planoptionssubkey\"],\"notes\":\"no-embed; fetch-on-demand\"}",
        "testStrategy": "None.",
        "subtasks": [
          {
            "id": 9114001,
            "title": "Index anchor — stable hash",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§14#stable-hash",
            "parentId": "undefined"
          },
          {
            "id": 9114002,
            "title": "Index anchor — PlanOptionsSubKey",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§14#planoptionssubkey",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 9115,
        "title": "§15 Performance, Determinism & Metrics",
        "description": "Reference-only: section §15.",
        "priority": "low",
        "estimatedHours": 0,
        "dependencies": [
          "9000"
        ],
        "status": "done",
        "complexityScore": 1,
        "details": "REFONLY::{\"source\":\"FILE\",\"uri\":\"docs/feature-simplification/feature-support-simplification.md\",\"section\":\"§15\",\"anchors\":[\"spec://§15#rng\",\"spec://§15#metrics\",\"spec://§15#slo-sli\"],\"notes\":\"no-embed; fetch-on-demand\"}",
        "testStrategy": "None.",
        "subtasks": [
          {
            "id": 9115001,
            "title": "Index anchor — RNG",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§15#rng",
            "parentId": "undefined"
          },
          {
            "id": 9115002,
            "title": "Index anchor — metrics fields",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§15#metrics",
            "parentId": "undefined"
          },
          {
            "id": 9115003,
            "title": "Index anchor — SLO/SLI gates",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§15#slo-sli",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 9116,
        "title": "§16 Implementation Plan",
        "description": "Reference-only: section §16.",
        "priority": "low",
        "estimatedHours": 0,
        "dependencies": [
          "9000"
        ],
        "status": "done",
        "complexityScore": 1,
        "details": "REFONLY::{\"source\":\"FILE\",\"uri\":\"docs/feature-simplification/feature-support-simplification.md\",\"section\":\"§16\",\"anchors\":[\"spec://§16#phase-p0\",\"spec://§16#acceptance-p0\",\"spec://§16#phase-p1\",\"spec://§16#phase-p2\"],\"notes\":\"no-embed; fetch-on-demand\"}",
        "testStrategy": "None.",
        "subtasks": [
          {
            "id": 9116001,
            "title": "Index anchor — Phase P0",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§16#phase-p0",
            "parentId": "undefined"
          },
          {
            "id": 9116002,
            "title": "Index anchor — Acceptance P0",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§16#acceptance-p0",
            "parentId": "undefined"
          },
          {
            "id": 9116003,
            "title": "Index anchor — Phase P1",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§16#phase-p1",
            "parentId": "undefined"
          },
          {
            "id": 9116004,
            "title": "Index anchor — Phase P2",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§16#phase-p2",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 9117,
        "title": "§17 Documentation Additions",
        "description": "Reference-only: section §17.",
        "priority": "low",
        "estimatedHours": 0,
        "dependencies": [
          "9000"
        ],
        "status": "done",
        "complexityScore": 1,
        "details": "REFONLY::{\"source\":\"FILE\",\"uri\":\"docs/feature-simplification/feature-support-simplification.md\",\"section\":\"§17\",\"anchors\":[\"spec://§17#invariants-doc\",\"spec://§17#known-limits\",\"spec://§17#features-matrix\"],\"notes\":\"no-embed; fetch-on-demand\"}",
        "testStrategy": "None.",
        "subtasks": [
          {
            "id": 9117001,
            "title": "Index anchor — Invariants doc",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§17#invariants-doc",
            "parentId": "undefined"
          },
          {
            "id": 9117002,
            "title": "Index anchor — Known Limits",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§17#known-limits",
            "parentId": "undefined"
          },
          {
            "id": 9117003,
            "title": "Index anchor — Features Matrix",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§17#features-matrix",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 9118,
        "title": "§18 Features Matrix",
        "description": "Reference-only: section §18.",
        "priority": "low",
        "estimatedHours": 0,
        "dependencies": [
          "9000"
        ],
        "status": "done",
        "complexityScore": 1,
        "details": "REFONLY::{\"source\":\"FILE\",\"uri\":\"docs/feature-simplification/feature-support-simplification.md\",\"section\":\"§18\",\"anchors\":[\"spec://§18#matrix\"],\"notes\":\"no-embed; fetch-on-demand\"}",
        "testStrategy": "None.",
        "subtasks": [
          {
            "id": 9118001,
            "title": "Index anchor — Features Matrix",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§18#matrix",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 9119,
        "title": "§19 Diagnostics (codes)",
        "description": "Reference-only: section §19.",
        "priority": "low",
        "estimatedHours": 0,
        "dependencies": [
          "9000"
        ],
        "status": "done",
        "complexityScore": 1,
        "details": "REFONLY::{\"source\":\"FILE\",\"uri\":\"docs/feature-simplification/feature-support-simplification.md\",\"section\":\"§19\",\"anchors\":[\"spec://§19#envelope\",\"spec://§19#payloads\",\"spec://§19#phase-separation\"],\"notes\":\"no-embed; fetch-on-demand\"}",
        "testStrategy": "None.",
        "subtasks": [
          {
            "id": 9119001,
            "title": "Index anchor — diagnostics envelope",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§19#envelope",
            "parentId": "undefined"
          },
          {
            "id": 9119002,
            "title": "Index anchor — details payloads",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§19#payloads",
            "parentId": "undefined"
          },
          {
            "id": 9119003,
            "title": "Index anchor — phase separation",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§19#phase-separation",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 9120,
        "title": "§20 Testing Strategy",
        "description": "Reference-only: section §20.",
        "priority": "low",
        "estimatedHours": 0,
        "dependencies": [
          "9000"
        ],
        "status": "done",
        "complexityScore": 1,
        "details": "REFONLY::{\"source\":\"FILE\",\"uri\":\"docs/feature-simplification/feature-support-simplification.md\",\"section\":\"§20\",\"anchors\":[\"spec://§20#unit\",\"spec://§20#integration\",\"spec://§20#bench-ci\",\"spec://§20#metamorphic\"],\"notes\":\"no-embed; fetch-on-demand\"}",
        "testStrategy": "None.",
        "subtasks": [
          {
            "id": 9120001,
            "title": "Index anchor — unit tests",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§20#unit",
            "parentId": "undefined"
          },
          {
            "id": 9120002,
            "title": "Index anchor — integration tests",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§20#integration",
            "parentId": "undefined"
          },
          {
            "id": 9120003,
            "title": "Index anchor — bench/CI",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§20#bench-ci",
            "parentId": "undefined"
          },
          {
            "id": 9120004,
            "title": "Index anchor — metamorphic/equivalence",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§20#metamorphic",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 9121,
        "title": "§21 Risks & Mitigations",
        "description": "Reference-only: section §21.",
        "priority": "low",
        "estimatedHours": 0,
        "dependencies": [
          "9000"
        ],
        "status": "done",
        "complexityScore": 1,
        "details": "REFONLY::{\"source\":\"FILE\",\"uri\":\"docs/feature-simplification/feature-support-simplification.md\",\"section\":\"§21\",\"anchors\":[\"spec://§21#mitigations\"],\"notes\":\"no-embed; fetch-on-demand\"}",
        "testStrategy": "None.",
        "subtasks": [
          {
            "id": 9121001,
            "title": "Index anchor — mitigations",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§21#mitigations",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 9122,
        "title": "§22 Deliverables (Code)",
        "description": "Reference-only: section §22.",
        "priority": "low",
        "estimatedHours": 0,
        "dependencies": [
          "9000"
        ],
        "status": "done",
        "complexityScore": 1,
        "details": "REFONLY::{\"source\":\"FILE\",\"uri\":\"docs/feature-simplification/feature-support-simplification.md\",\"section\":\"§22\",\"anchors\":[\"spec://§22#packages-core\",\"spec://§22#scripts\",\"spec://§22#docs\"],\"notes\":\"no-embed; fetch-on-demand\"}",
        "testStrategy": "None.",
        "subtasks": [
          {
            "id": 9122001,
            "title": "Index anchor — packages/core list",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§22#packages-core",
            "parentId": "undefined"
          },
          {
            "id": 9122002,
            "title": "Index anchor — scripts",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§22#scripts",
            "parentId": "undefined"
          },
          {
            "id": 9122003,
            "title": "Index anchor — docs deliverables",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§22#docs",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 9123,
        "title": "§23 Appendix — Minimal Interfaces",
        "description": "Reference-only: section §23.",
        "priority": "low",
        "estimatedHours": 0,
        "dependencies": [
          "9000"
        ],
        "status": "done",
        "complexityScore": 1,
        "details": "REFONLY::{\"source\":\"FILE\",\"uri\":\"docs/feature-simplification/feature-support-simplification.md\",\"section\":\"§23\",\"anchors\":[\"spec://§23#plan-options\",\"spec://§23#compose-interfaces\",\"spec://§23#repair-interfaces\"],\"notes\":\"no-embed; fetch-on-demand\"}",
        "testStrategy": "None.",
        "subtasks": [
          {
            "id": 9123001,
            "title": "Index anchor — PlanOptions",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§23#plan-options",
            "parentId": "undefined"
          },
          {
            "id": 9123002,
            "title": "Index anchor — compose interfaces",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§23#compose-interfaces",
            "parentId": "undefined"
          },
          {
            "id": 9123003,
            "title": "Index anchor — repair interfaces",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§23#repair-interfaces",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 9124,
        "title": "§24 Norms & References",
        "description": "Reference-only: section §24.",
        "priority": "low",
        "estimatedHours": 0,
        "dependencies": [
          "9000"
        ],
        "status": "done",
        "complexityScore": 1,
        "details": "REFONLY::{\"source\":\"FILE\",\"uri\":\"docs/feature-simplification/feature-support-simplification.md\",\"section\":\"§24\",\"anchors\":[\"spec://§24#normative\",\"spec://§24#informative\",\"spec://§24#alignment\"],\"notes\":\"no-embed; fetch-on-demand\"}",
        "testStrategy": "None.",
        "subtasks": [
          {
            "id": 9124001,
            "title": "Index anchor — normative refs",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§24#normative",
            "parentId": "undefined"
          },
          {
            "id": 9124002,
            "title": "Index anchor — informative refs",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§24#informative",
            "parentId": "undefined"
          },
          {
            "id": 9124003,
            "title": "Index anchor — alignment table",
            "status": "done",
            "estimatedHours": 0,
            "file": "spec://§24#alignment",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 1,
        "title": "Scaffolding & Monorepo",
        "description": "Initialize monorepo, packages, basic build/test/bench harness, and docs skeleton.",
        "priority": "high",
        "estimatedHours": 16,
        "dependencies": [
          "8000",
          "9000",
          "9106",
          "9122"
        ],
        "status": "done",
        "complexityScore": 3,
        "details": "[Context] SPEC anchors (§6 phases; §22 deliverables).\n- §6: spec://§6#phases\n- §22: spec://§22#packages-core, spec://§22#scripts, spec://§22#docs\n[Retrieval]\n- REFONLY::{\"source\":\"FILE\",\"uri\":\"docs/feature-simplification/feature-support-simplification.md\",\"section\":\"§6\",\"anchors\":[\"spec://§6#phases\"],\"notes\":\"no-embed; fetch-on-demand\"}\n- REFONLY::{\"source\":\"FILE\",\"uri\":\"docs/feature-simplification/feature-support-simplification.md\",\"section\":\"§22\",\"anchors\":[\"spec://§22#packages-core\",\"spec://§22#scripts\",\"spec://§22#docs\"],\"notes\":\"no-embed; fetch-on-demand\"}\n[Key requirements]\n- Monorepo (pnpm, TS), packages under packages/core per §22.\n- Wire scripts/bench.ts and basic test runner.\n- Do not implement semantics here; only scaffolding.\n[Deliverables]\n- Create files per §22, including: docs/feature-simplification/feature-support-simplification.md (SPEC path reference only), package workspaces, tsconfig, eslint.\n[Commands]\n- pnpm i\n- pnpm -w build\n- pnpm -w test\n- pnpm -w bench\n[Definition of Done]\n- Workspace builds; tests execute (empty suites OK); bench script runs and prints placeholders.\n- Lint passes; CI workflow skeleton present.",
        "testStrategy": "Smoke tests: build succeeds; unit test runner executes a trivial test; bench script prints headers.",
        "subtasks": [
          {
            "id": 1001,
            "title": "Create workspace root (pnpm, TS configs)",
            "status": "done",
            "estimatedHours": 2,
            "file": "package.json",
            "parentId": "undefined"
          },
          {
            "id": 1002,
            "title": "Init core package",
            "status": "done",
            "estimatedHours": 4,
            "file": "packages/core/package.json",
            "parentId": "undefined"
          },
          {
            "id": 1003,
            "title": "Bench harness entry",
            "status": "done",
            "estimatedHours": 4,
            "file": "scripts/bench.ts",
            "parentId": "undefined"
          },
          {
            "id": 1004,
            "title": "Docs skeleton",
            "status": "done",
            "estimatedHours": 6,
            "file": "docs/README.md",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 2,
        "title": "Dual AJV & Config Gate",
        "description": "Introduce Source vs Planning AJV instances and enforce startup parity gates.",
        "priority": "high",
        "estimatedHours": 24,
        "dependencies": [
          "8000",
          "9000",
          "9113",
          "9101",
          "9112"
        ],
        "status": "done",
        "complexityScore": 4,
        "details": "[Context] §13 startup-config-check; §12 Ajv class selection; §1 config gate.\n- spec://§13#startup-config-check\n- spec://§12#ajv-class-selection\n- spec://§1#config-gate\n[Retrieval]\n- REFONLY::{\"source\":\"FILE\",\"uri\":\"docs/feature-simplification/feature-support-simplification.md\",\"section\":\"§13\",\"anchors\":[\"spec://§13#startup-config-check\"],\"notes\":\"no-embed; fetch-on-demand\"}\n- REFONLY::{\"source\":\"FILE\",\"uri\":\"docs/feature-simplification/feature-support-simplification.md\",\"section\":\"§12\",\"anchors\":[\"spec://§12#ajv-class-selection\"],\"notes\":\"no-embed; fetch-on-demand\"}\n- REFONLY::{\"source\":\"FILE\",\"uri\":\"docs/feature-simplification/feature-support-simplification.md\",\"section\":\"§1\",\"anchors\":[\"spec://§1#config-gate\"],\"notes\":\"no-embed; fetch-on-demand\"}\n[Key requirements]\n- Two AJV instances with identical `unicodeRegExp:true` and `validateFormats` parity.\n- Align `multipleOfPrecision` to PlanOptions.rational.decimalPrecision on both instances.\n- Fail with AJV_FLAGS_MISMATCH and include diffs per §13 when deviations are detected.\n[Deliverables]\n- packages/core/src/util/ajv-source.ts\n- packages/core/src/util/ajv-planning.ts\n- packages/core/src/util/ajv-gate.ts (validation of flags; diagnostic assembly)\n[Commands]\n- pnpm i; pnpm -w build; pnpm -w test; pnpm -w bench\n[Definition of Done]\n- Gate refuses mismatched flags/classes; exports include ajvMajor and diff payloads; unit tests cover unicodeRegExp and multipleOfPrecision parity.",
        "testStrategy": "Unit: simulate mismatched flags (e.g., unicodeRegExp:false) → AJV_FLAGS_MISMATCH. Draft mapping to Ajv*/Ajv2020. Integration: successful compile on simple schemas; failure on external $ref remains for modes task.",
        "subtasks": [
          {
            "id": 2001,
            "title": "Source AJV factory",
            "status": "done",
            "estimatedHours": 6,
            "file": "packages/core/src/util/ajv-source.ts",
            "parentId": "undefined"
          },
          {
            "id": 2002,
            "title": "Planning AJV factory",
            "status": "done",
            "estimatedHours": 8,
            "file": "packages/core/src/util/ajv-planning.ts",
            "parentId": "undefined"
          },
          {
            "id": 2003,
            "title": "Startup config checker",
            "status": "done",
            "estimatedHours": 10,
            "file": "packages/core/src/util/ajv-gate.ts",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-10-12T20:00:58.449Z"
      },
      {
        "id": 3,
        "title": "Utils: RNG, rationals, JSON-safe",
        "description": "Provide deterministic RNG, exact rational helpers with fallbacks, and JSON-safe logging.",
        "priority": "high",
        "estimatedHours": 12,
        "dependencies": [
          "8000",
          "9000",
          "9115",
          "9123",
          "9108"
        ],
        "status": "done",
        "complexityScore": 3,
        "details": "[Context] §15 RNG; §8 numbers/multipleOf; §23 interfaces.\n- spec://§15#rng\n- spec://§8#numbers-multipleof\n- spec://§23#plan-options\n[Retrieval]\n- REFONLY::{\"source\":\"FILE\",\"uri\":\"docs/feature-simplification/feature-support-simplification.md\",\"section\":\"§15\",\"anchors\":[\"spec://§15#rng\"],\"notes\":\"no-embed; fetch-on-demand\"}\n- REFONLY::{\"source\":\"FILE\",\"uri\":\"docs/feature-simplification/feature-support-simplification.md\",\"section\":\"§8\",\"anchors\":[\"spec://§8#numbers-multipleof\"],\"notes\":\"no-embed; fetch-on-demand\"}\n[Key requirements]\n- xorshift32 seeded with (seed >>> 0) ^ fnv1a32(canonPath); export next() and float in [0,1).\n- Rationals: exact math with caps; decimal/float fallback with ε = 10^(−decimalPrecision). Log RAT_* diagnostics via caller.\n- jsonSafeReplacer for BigInt.\n[Deliverables]\n- packages/core/src/util/rng.ts\n- packages/core/src/util/rational.ts\n- packages/core/src/util/json-safe.ts\n[Commands]\n- pnpm i; pnpm -w build; pnpm -w test; pnpm -w bench\n[Definition of Done]\n- Deterministic RNG across runs; rational unit tests for lcm/gcd and epsilon tolerance; JSON-safe logs stringify BigInt.\n<info added on 2025-10-13T11:31:12.703Z>\nI'll analyze the codebase first to understand the current state and then provide the update based on the user's request.Based on my analysis of the codebase, the user request indicates that the rational helpers, JSON-safe replacer, and RNG utilities have been successfully implemented. The files I examined confirm this:\n\n- `/packages/core/src/util/rng.ts`: Contains XorShift32 class with fnv1a32 hashing and deterministic float generation\n- `/packages/core/src/util/rational.ts`: Implements gcd/lcm, reduce, quantizeDecimal, and epsilon tolerance functions\n- `/packages/core/src/util/json-safe.ts`: Provides jsonSafeReplacer for BigInt serialization\n\n[Progress Update]\nImplementation completed with deliverables at expected locations. RNG utility (packages/core/src/util/rng.ts) provides xorshift32 with fnv1a32 seeding as specified. Rational helpers (packages/core/src/util/rational.ts) deliver exact arithmetic with gcd/lcm/reduce functions plus decimal fallback mechanisms with configurable epsilon tolerance. JSON-safe utilities (packages/core/src/util/json-safe.ts) handle BigInt serialization and rational number display formatting. All modules align with §8 multipleOf semantics, §15 RNG determinism requirements, and §23 interface specifications.\n</info added on 2025-10-13T11:31:12.703Z>\n<info added on 2025-10-13T11:39:35.206Z>\nI'll analyze the codebase first to understand the current implementation and then provide the update.Based on my analysis of the codebase, I can see that the implementation is indeed complete with all deliverables in place and comprehensive test coverage. Here's the new text that should be appended to the task details:\n\n[Final Implementation Status - 2025-10-13]\nTASK COMPLETED - All implementation and testing objectives achieved:\n\n**Delivered Files:**\n✅ packages/core/src/util/rng.ts - XorShift32 with fnv1a32 seeding per §15\n✅ packages/core/src/util/rational.ts - gcd/lcm/reduce + epsilon tolerance helpers per §8  \n✅ packages/core/src/util/json-safe.ts - BigInt replacer + rational serialization\n\n**Test Coverage (33 total tests):**\n✅ packages/core/src/util/__tests__/rng.test.ts - 19 tests (hash accuracy, determinism, edge cases, distribution)\n✅ packages/core/src/util/__tests__/rational.test.ts - 6 tests (gcd/lcm/reduce + epsilon tolerance)\n✅ packages/core/src/util/__tests__/json-safe.test.ts - 2 tests (BigInt serialization)\n✅ packages/core/src/util/__tests__/ajv-gate.test.ts - 6 existing tests continue to pass\n\n**Quality Gates Passed:**\n✅ TypeScript compilation clean (tsc --noEmit)\n✅ All 33 tests pass in test suite\n✅ Deterministic RNG verified across runs with fixed seeds\n✅ Rational arithmetic with exact gcd/lcm and epsilon boundary testing\n✅ JSON-safe BigInt stringification confirmed\n\n**Spec Compliance Verified:**\n✅ §15 RNG requirements: fnv1a32 + XorShift32 deterministic seeding\n✅ §8 multipleOf: exact rational math with epsilon fallback mechanisms  \n✅ §23 interfaces: proper TypeScript exports and function signatures\n\nReady for integration with downstream tasks requiring deterministic utilities.\n</info added on 2025-10-13T11:39:35.206Z>",
        "testStrategy": "Property tests for RNG distribution determinism given fixed seed; unit tests for multipleOf tolerance boundaries; JSON-safe replacer snapshot tests.",
        "subtasks": [
          {
            "id": 3001,
            "title": "Implement RNG (xorshift32 + fnv1a32)",
            "status": "done",
            "estimatedHours": 4,
            "file": "packages/core/src/util/rng.ts",
            "parentId": "undefined"
          },
          {
            "id": 3002,
            "title": "Implement rational helpers",
            "status": "done",
            "estimatedHours": 6,
            "file": "packages/core/src/util/rational.ts",
            "parentId": "undefined"
          },
          {
            "id": 3003,
            "title": "JSON-safe replacer",
            "status": "done",
            "estimatedHours": 2,
            "file": "packages/core/src/util/json-safe.ts",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 4,
        "title": "Structural hashing & stable-hash",
        "description": "Implement structural hashing for uniqueItems and stable schema hashing for cache.",
        "status": "done",
        "dependencies": [
          "8000",
          "9000",
          "9110",
          "9114",
          "9124"
        ],
        "priority": "high",
        "details": "[Context] §10 structural hashing; §14 stable-hash.\n- spec://§10#structural-hashing\n- spec://§14#stable-hash\n[Retrieval]\n- REFONLY::{\"source\":\"FILE\",\"uri\":\"docs/feature-simplification/feature-support-simplification.md\",\"section\":\"§10\",\"anchors\":[\"spec://§10#structural-hashing\"],\"notes\":\"no-embed; fetch-on-demand\"}\n- REFONLY::{\"source\":\"FILE\",\"uri\":\"docs/feature-simplification/feature-support-simplification.md\",\"section\":\"§14\",\"anchors\":[\"spec://§14#stable-hash\"],\"notes\":\"no-embed; fetch-on-demand\"}\n[Key requirements]\n- SHA-256 over canonical JSON (sorted keys, arrays in order, -0→0, BigInt stringified); confirm collisions with deepEqual.\n[Critical Path]\n- HIGH PRIORITY: This task blocks Task 8 (Composition Engine), Task 10 (Repair Engine), and Task 11 (Pipeline Orchestrator)\n- Structural hashing is required for uniqueItems deduplication in the Repair Engine\n- Stable-hash is required for the cache system in the Composition Engine\n- Current array-generator.ts uses JSON.stringify for uniqueItems (lines 364, 603-607) - needs replacement with structural hash\n- CacheOptions in types/options.ts references hash-based caching (line 68) - needs stable-hash implementation\n[Implementation Context]\n- packages/core/src/generator/types/array-generator.ts currently implements uniqueItems using JSON.stringify\n- packages/core/src/types/options.ts defines CacheOptions with hashIfBytesLt setting\n- No repair engine or composition engine directories exist yet - this task must complete before they can be implemented\n[Deliverables]\n- packages/core/src/util/struct-hash.ts\n- packages/core/src/util/stable-hash.ts\n[Commands]\n- pnpm i; pnpm -w build; pnpm -w test; pnpm -w bench\n[Definition of Done]\n- uniqueItems de-dupe via hash+confirm; stableHash returns deterministic digest; tests cover -0 normalization.",
        "testStrategy": "Unit: hashing determinism; collision buckets with deepEqual confirmation; array/object ordering tests. Integration: replace JSON.stringify usage in array-generator.ts with structural hashing; verify cache system can use stable-hash for schema keys.",
        "subtasks": [
          {
            "id": 1,
            "title": "Structural hash for instances",
            "description": "Implement structural hashing utility for JavaScript values used in uniqueItems deduplication",
            "dependencies": [],
            "details": "Create packages/core/src/util/struct-hash.ts with SHA-256 based structural hashing for JavaScript values. Must handle canonical JSON normalization (sorted keys, arrays in order, -0→0, BigInt stringified). Include collision detection with deepEqual confirmation. Replace JSON.stringify usage in array-generator.ts lines 364, 603-607 with this implementation.",
            "status": "done",
            "testStrategy": "Unit tests for deterministic hashing, collision handling, edge cases with -0, BigInt, deep objects/arrays",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Stable hash for schema",
            "description": "Implement stable schema hashing for cache system used by Composition Engine",
            "dependencies": [],
            "details": "Create packages/core/src/util/stable-hash.ts for deterministic schema digest generation. Must integrate with CacheOptions.hashIfBytesLt setting in types/options.ts. Provide consistent hashing for schema objects to enable efficient caching in the composition engine pipeline stage.",
            "status": "done",
            "testStrategy": "Unit tests for schema hashing consistency, deterministic output across runs, integration with cache options",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 5,
        "title": "PtrMap canon→original",
        "description": "Bidirectional pointer mapping between canonical and original schema pointers.",
        "priority": "medium",
        "estimatedHours": 8,
        "dependencies": [
          "8000",
          "9000",
          "9107",
          "9122"
        ],
        "status": "done",
        "complexityScore": 2,
        "details": "[Context] §7 contract exports ptrMap/revPtrMap; §22 deliverables.\n- spec://§7#contract\n- spec://§22#packages-core\n[Retrieval]\n- REFONLY::{\"source\":\"FILE\",\"uri\":\"docs/feature-simplification/feature-support-simplification.md\",\"section\":\"§7\",\"anchors\":[\"spec://§7#contract\"],\"notes\":\"no-embed; fetch-on-demand\"}\n[Key requirements]\n- Provide mapCanonToOrig and reverse, plus toOriginalByWalk (longest-prefix walk).\n[Deliverables]\n- packages/core/src/util/ptr-map.ts\n[Commands]\n- pnpm i; pnpm -w build; pnpm -w test\n[Definition of Done]\n- Unit tests cover reverse-walk across nested paths; stable behavior.",
        "testStrategy": "Unit: mapping inlining, longest-prefix reverse resolution; golden tests using tiny canonical vs original trees.",
        "subtasks": [
          {
            "id": 5001,
            "title": "Pointer maps and reverse walk",
            "status": "done",
            "estimatedHours": 8,
            "file": "packages/core/src/util/ptr-map.ts",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 6,
        "title": "Metrics & diagnostic envelope",
        "description": "Diagnostics envelope `{code, canonPath, details?}`, metrics collection, verbosity toggle.",
        "priority": "high",
        "estimatedHours": 16,
        "dependencies": [
          "8000",
          "9000",
          "9115",
          "9119",
          "9101"
        ],
        "status": "done",
        "complexityScore": 3,
        "details": "[Context] §19 envelope & payloads; §15 metrics; §1 acceptance signals.\n- spec://§19#envelope, spec://§19#payloads\n- spec://§15#metrics, spec://§1#acceptance\n[Retrieval]\n- REFONLY::{\"source\":\"FILE\",\"uri\":\"docs/feature-simplification/feature-support-simplification.md\",\"section\":\"§19\",\"anchors\":[\"spec://§19#envelope\",\"spec://§19#payloads\"],\"notes\":\"no-embed; fetch-on-demand\"}\n- REFONLY::{\"source\":\"FILE\",\"uri\":\"docs/feature-simplification/feature-support-simplification.md\",\"section\":\"§15\",\"anchors\":[\"spec://§15#metrics\"],\"notes\":\"no-embed; fetch-on-demand\"}\n[Key requirements]\n- Envelope must never duplicate canonPath inside details.\n- Implement metrics fields (normalizeMs..p95LatencyMs) and counters; support verbosity toggle (CI verbose vs runtime normal) without changing shapes.\n[Deliverables]\n- packages/core/src/util/metrics.ts\n- packages/core/src/diag/codes.ts (type tags)\n- packages/core/src/diag/validate.ts (mini-schema assertions for §19.1 where practical)\n[Commands]\n- pnpm i; pnpm -w build; pnpm -w test; pnpm -w bench\n[Definition of Done]\n- Diagnostics serialize with correct envelope; metrics accumulate across phases; toggle reduces payload volume but fields exist.",
        "testStrategy": "Unit: envelope guard (no canonPath duplication in details); metrics counters increments; snapshot tests for verbosity modes.",
        "subtasks": [
          {
            "id": 6001,
            "title": "Metrics utility",
            "status": "done",
            "estimatedHours": 8,
            "file": "packages/core/src/util/metrics.ts",
            "parentId": "undefined"
          },
          {
            "id": 6002,
            "title": "Diagnostics code schema helpers",
            "status": "done",
            "estimatedHours": 4,
            "file": "packages/core/src/diag/codes.ts",
            "parentId": "undefined"
          },
          {
            "id": 6003,
            "title": "Diagnostics validator (payload spot-checks)",
            "status": "done",
            "estimatedHours": 4,
            "file": "packages/core/src/diag/validate.ts",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 7,
        "title": "Normalizer",
        "description": "Draft unification, boolean/trivial simplifications with unevaluated guards, conditional rewrite (safe), propertyNames rewrite (P0: enum-only).",
        "priority": "high",
        "estimatedHours": 48,
        "dependencies": [
          "5",
          "6",
          "13",
          "8000",
          "9000",
          "9107",
          "9108",
          "9112"
        ],
        "status": "done",
        "complexityScore": 5,
        "details": "[Context] §7 pass order; conditionals rewrite; propertyNames rewrite; note codes; §8 interplay.\n- spec://§7#pass-order, spec://§7#conditionals-rewrite, spec://§7#object-keywords-pnames-rewrite, spec://§7#note-codes\n- spec://§8#regex-complexity-cap\n[Retrieval]\n- REFONLY::{\"source\":\"FILE\",\"uri\":\"docs/feature-simplification/feature-support-simplification.md\",\"section\":\"§7\",\"anchors\":[\"spec://§7#pass-order\",\"spec://§7#conditionals-rewrite\",\"spec://§7#object-keywords-pnames-rewrite\",\"spec://§7#note-codes\"],\"notes\":\"no-embed; fetch-on-demand\"}\n[Key requirements]\n- Unevaluated* guard blocks simplifications and conditional rewrites where specified.\n- PropertyNames rewrite: **P0 implements enum-only**; anchored-pattern form is deferred to **P2 (#23)**.\n- When rewrite applies, log PNAMES_REWRITE_APPLIED and keep original node; add-only synthetic entries.\n[Deliverables]\n- packages/core/src/transform/schema-normalizer.ts\n- packages/core/src/parser/json-schema-parser.ts\n[Commands]\n- pnpm i; pnpm -w build; pnpm -w test\n[Definition of Done]\n- Notes emitted per §7; enum-based rewrite adds synthetic patternProperties + AP:false in canonical view; no semantic drift in AJV final validation.",
        "testStrategy": "Golden tests on notes; rewrite acceptance/refusal; guard with unevaluated*; draft conversions; size-1 enum→const in canonical view only.",
        "subtasks": [
          {
            "id": 7001,
            "title": "Normalizer core (passes, guards, notes)",
            "status": "done",
            "estimatedHours": 32,
            "file": "packages/core/src/transform/schema-normalizer.ts",
            "parentId": "undefined"
          },
          {
            "id": 7002,
            "title": "Lean JSON Schema parser",
            "status": "done",
            "estimatedHours": 16,
            "file": "packages/core/src/parser/json-schema-parser.ts",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 8,
        "title": "Composition Engine",
        "description": "Build effective view, CoverageIndex (has/enumerate), branch selection, early-unsat hints, caps; AP:false must-cover and Strict/Lax behaviors.",
        "status": "done",
        "dependencies": [
          "2",
          "3",
          "4",
          "6",
          "7",
          "8000",
          "9000",
          "9107",
          "9108",
          "9111",
          "9113",
          "9114",
          "9115"
        ],
        "priority": "high",
        "details": "[Context] §8 coverage-index-export/enumerate; AP:false must-cover and fail-fast; branch-selection; oneOf exclusivity (Compose side); regex caps; §14 memo keys.\n- spec://§8#coverage-index-export, spec://§8#coverage-index-enumerate, spec://§8#apfalse-must-cover, spec://§8#branch-selection, spec://§8#oneof-exclusivity, spec://§8#regex-complexity-cap\n- spec://§14#planoptionssubkey\n[Retrieval]\n- REFONLY::{\"source\":\"FILE\",\"uri\":\"docs/feature-simplification/feature-support-simplification.md\",\"section\":\"§8\",\"anchors\":[\"spec://§8#coverage-index-export\",\"spec://§8#coverage-index-enumerate\",\"spec://§8#apfalse-must-cover\",\"spec://§8#branch-selection\",\"spec://§8#oneof-exclusivity\",\"spec://§8#regex-complexity-cap\"],\"notes\":\"no-embed; fetch-on-demand\"}\n[Key requirements]\n- Export CoverageIndex for every object; enumerate only when provably finite by allowed sources; provenance sorted.\n- Strict fail-fast AP_FALSE_UNSAFE_PATTERN only under presence pressure and only when Safe set is empty; Lax warns.\n- Score-only invariants: always record tiebreakRand (even when |T|=1); budget.skipped=true; limit per Top-K calc.\n- **DEPENDENCY**: Requires normalized schema output from Normalizer (task 7) to build effective view and CoverageIndex.\n[Deliverables]\n- packages/core/src/transform/composition-engine.ts\n[Commands]\n- pnpm i; pnpm -w build; pnpm -w test; pnpm -w bench\n[Definition of Done]\n- Deterministic branch selection; CoverageIndex.has/enumerate pure; diagnostics emitted with correct locus; caps limited to compose-time set.",
        "testStrategy": "Unit: enumerate order and provenance; AP:false safe proof vs fail-fast routing; score-only path with tiebreakRand present; early-unsat hints payloads shapes; memo key includes PlanOptionsSubKey.",
        "subtasks": [
          {
            "id": 1,
            "title": "Effective view & CoverageIndex",
            "description": "Implement core effective view computation and CoverageIndex data structure with has/enumerate methods",
            "dependencies": [],
            "details": "Build the core effective view computation that processes normalized schemas from the Normalizer (task 7). Implement CoverageIndex class with has() and enumerate() methods, ensuring enumerate only operates on provably finite sources. Handle AP:false must-cover requirements with Safe/Unsafe pattern detection. Export CoverageIndex for every object schema processed.",
            "status": "done",
            "testStrategy": "Unit tests for CoverageIndex.has/enumerate purity, effective view computation correctness, and finite source validation",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Branch selector & diagnostics",
            "description": "Implement deterministic branch selection with score-only invariants and diagnostic emission",
            "dependencies": [],
            "details": "Implement branch selection algorithm with deterministic tiebreakRand recording (even for |T|=1 cases). Handle Strict vs Lax behaviors for AP_FALSE_UNSAFE_PATTERN routing. Implement early-unsat hints generation and diagnostic emission with correct locus information. Ensure memo keys include PlanOptionsSubKey for proper caching.",
            "status": "done",
            "testStrategy": "Unit tests for deterministic branch selection, tiebreakRand presence, Strict/Lax routing behavior, and diagnostic locus accuracy",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-10-15T18:54:14.278Z"
      },
      {
        "id": 9,
        "title": "Generator",
        "description": "Foundry generator honoring effective view, pattern witness, minimal width/length, if-aware-lite.",
        "status": "done",
        "dependencies": [
          "8",
          "8000",
          "9000",
          "9109",
          "9108",
          "9113",
          "9115",
          "3",
          "6"
        ],
        "priority": "high",
        "details": "[Context] §9 generator, if-aware-lite, pattern-witness-selection; arrays contains; §8 oneOf exclusivity (later step logs exclusivityRand in Repair phase). Requires dependency on task 8 (Composition Engine) to access effective view and CoverageIndex from the Composition Engine for generating data that honors schema constraints.\n- spec://§9#if-aware-lite, spec://§9#pattern-witness-selection, spec://§9#arrays-contains\n[Retrieval]\n- REFONLY::{\"source\":\"FILE\",\"uri\":\"docs/feature-simplification/feature-support-simplification.md\",\"section\":\"§9\",\"anchors\":[\"spec://§9#if-aware-lite\",\"spec://§9#pattern-witness-selection\",\"spec://§9#arrays-contains\"],\"notes\":\"no-embed; fetch-on-demand\"}\n[Key requirements]\n- Pattern witness bounded search; emit COMPLEXITY_CAP_PATTERNS when capped; Unicode code point length.\n- Minimal-width objects with must-cover + unevaluated guards.\n- Access to effective view and CoverageIndex from Composition Engine (task 8) for constraint-aware generation.\n[Deliverables]\n- packages/core/src/generator/foundry-generator.ts\n[Commands]\n- pnpm i; pnpm -w build; pnpm -w test; pnpm -w bench\n[Definition of Done]\n- Deterministic outputs for fixed (seed, options); metrics.patternWitnessTried increments when enabled.\n- Integration with Composition Engine outputs for effective schema processing.",
        "testStrategy": "Unit: witness ordering/capping; object property order (required then optional, UTF-16); arrays contains with uniqueItems handling.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement generator core",
            "description": "Core generator implementation that integrates with Composition Engine effective view",
            "dependencies": [],
            "details": "Implement the foundry generator that consumes the effective view and CoverageIndex from the Composition Engine to generate schema-compliant data. Must honor pattern witness selection, minimal width/length constraints, and if-aware-lite processing.",
            "status": "done",
            "testStrategy": "Unit tests for core generation logic with deterministic seed handling",
            "parentId": "undefined",
            "updatedAt": "2025-10-22T21:24:51.252Z"
          }
        ],
        "updatedAt": "2025-10-23T22:58:11.111Z"
      },
      {
        "id": 10,
        "title": "Repair Engine",
        "description": "AJV-driven repairs, epsilon logging, AP:false rename guard with CoverageIndex, unevaluated evaluation guard.",
        "status": "done",
        "dependencies": [
          "2",
          "3",
          "4",
          "6",
          "8",
          "8000",
          "9000",
          "9108",
          "9110",
          "9113"
        ],
        "priority": "high",
        "details": "[Context] §10 mapping; epsilon logging; propertyNames rename guard; MUSTCOVER index missing; §9 unevaluated evaluation guard.\n- spec://§10#mapping, spec://§10#epsilon-logging, spec://§10#propertynames-rename-guard, spec://§10#mustcover-index-missing\n- spec://§9#objects-minimal-width (guard interplay) [contextual]\n[Retrieval]\n- REFONLY::{\"source\":\"FILE\",\"uri\":\"docs/feature-simplification/feature-support-simplification.md\",\"section\":\"§10\",\"anchors\":[\"spec://§10#mapping\",\"spec://§10#epsilon-logging\",\"spec://§10#propertynames-rename-guard\",\"spec://§10#mustcover-index-missing\"],\"notes\":\"no-embed; fetch-on-demand\"}\n[Key requirements]\n- Log epsilon exactly as \"1e-<decimalPrecision>\" for non-integer nudges; optional delta for integers.\n- Under AP:false + guard true, require ctx.isNameInMustCover(canonPath,n) before rename; else emit MUSTCOVER_INDEX_MISSING{guard:true}.\n- Evaluation guard for additions/renames when unevaluatedProperties:false applies.\n- Integration with Composition Engine's CoverageIndex API for AP:false rename guard implementation.\n[Deliverables]\n- packages/core/src/repair/repair-engine.ts\n[Commands]\n- pnpm i; pnpm -w build; pnpm -w test\n[Definition of Done]\n- Repairs idempotent; logs include canonPath and origPath; rename preflight per §10 and diagnostics conform to §19.1.\n- CoverageIndex integration for must-cover property name validation under additionalProperties:false constraints.",
        "testStrategy": "Unit: epsilon logging tests (float vs integer); enum-first selection; rename blocked by must-cover or evaluation guard; preflight branch/dependent failures; CoverageIndex integration for AP:false guard validation.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement repair actions & guards",
            "description": "Implement AJV-driven repair actions with CoverageIndex integration for AP:false rename guards and unevaluated evaluation guards.",
            "dependencies": [],
            "details": "Create repair-engine.ts with AJV-driven repair logic, epsilon logging, and integration with Composition Engine's CoverageIndex for property name validation under additionalProperties:false constraints. Must implement ctx.isNameInMustCover binding and MUSTCOVER_INDEX_MISSING diagnostic emission.",
            "status": "done",
            "testStrategy": "Unit tests for repair actions, epsilon logging, CoverageIndex integration, and guard validation.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 11,
        "title": "Pipeline Orchestrator",
        "description": "Wire Normalize → Compose → Generate → Repair → Validate; pass metrics and diagnostics through. Pipeline orchestration is wired but pending integration of task 9 generator and task 10 repair engines; revisit once those land to replace stubs and tighten dual AJV parity.",
        "status": "done",
        "dependencies": [
          "2",
          "5",
          "6",
          "7",
          "9",
          "10",
          "8000",
          "9000",
          "9101",
          "9106",
          "9113",
          "9115"
        ],
        "priority": "high",
        "details": "[Context] §4 pipeline; §6 phases; §1 acceptance; §15 metrics.\n- spec://§4#pipeline, spec://§6#phases, spec://§1#acceptance, spec://§15#metrics\n[Retrieval]\n- REFONLY::{\"source\":\"FILE\",\"uri\":\"docs/feature-simplification/feature-support-simplification.md\",\"section\":\"§4\",\"anchors\":[\"spec://§4#pipeline\"],\"notes\":\"no-embed; fetch-on-demand\"}\n[Key requirements]\n- Final AJV validate against original; support Lax/Strict behaviors routed by Modes task.\n- Wire together Normalize → Compose → Generate → Repair → Validate stages from dependency tasks.\n- Integrate with existing FoundryGenerator structure in packages/core/src/generator/foundry-generator.ts\n- Preserve existing PipelineStage enum and metrics collection patterns\n- Pipeline orchestration framework is implemented but uses stubs for Generator and Repair stages pending task 9 and task 10 completion\n[Deliverables]\n- packages/core/src/index.ts (main orchestrator entry point)\n- Enhanced packages/core/src/generator/foundry-generator.ts with new pipeline stages\n- packages/core/src/pipeline/orchestrator.ts (pipeline coordination logic)\n[Commands]\n- pnpm i; pnpm -w build; pnpm -w test; pnpm -w bench\n[Definition of Done]\n- End-to-end run returns diagnostics+metrics and valid instances on simple cases; errors propagate with correct codes.\n- All five pipeline stages (Normalize, Compose, Generate, Repair, Validate) are wired together\n- Integration with task 2 (Dual AJV), task 7 (Normalizer), task 8 (Composition Engine), task 9 (Generator), and task 10 (Repair Engine)\n- Dual AJV parity will be tightened once Generator and Repair engine implementations replace current stubs",
        "testStrategy": "Integration smoke: simple schema end-to-end; metrics fields all present; validationsPerRow ≥ 1 unless Lax skip path applies (to be added in task #12). Test all five pipeline stages execute in sequence with proper metrics collection. Current tests use stubbed implementations for Generator and Repair stages.",
        "subtasks": [
          {
            "id": 4,
            "title": "Integrate Generator stage",
            "description": "Wire task 9 (Generator) implementation into the pipeline orchestrator",
            "dependencies": [
              3
            ],
            "details": "Integrate the Generator from task 9 as the third stage in the pipeline. Handle deterministic seeded generation, enum/const precedence, and if-aware-lite generation. Maintain compatibility with existing generator structure in foundry-generator.ts. Currently using stub implementation pending task 9 completion.",
            "status": "done",
            "testStrategy": "Test generator stage integration with deterministic output verification and enum precedence handling",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Integrate Repair Engine stage",
            "description": "Wire task 10 (Repair Engine) implementation into the pipeline orchestrator",
            "dependencies": [
              4
            ],
            "details": "Integrate the Repair Engine from task 10 as the fourth stage in the pipeline. Handle AJV-driven corrections, idempotent repairs, rational snapping, and structural deduplication for uniqueItems. Implement repair budgeting and graceful degradation. Currently using stub implementation pending task 10 completion.",
            "status": "done",
            "testStrategy": "Test repair stage integration with various validation failure scenarios and repair budget limits",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Integrate Dual AJV Validation stage",
            "description": "Wire task 2 (Dual AJV) implementation as the final validation stage",
            "dependencies": [
              5
            ],
            "details": "Integrate the Dual AJV system from task 2 as the final validation stage. Ensure validation against original schema, handle Source and Planning AJV instances, and implement proper error reporting with pointer mapping and caching.",
            "status": "done",
            "testStrategy": "Test validation stage integration with both Source and Planning AJV instances, verify validation against original schema",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Implement metrics aggregation",
            "description": "Aggregate metrics from all pipeline stages into comprehensive PipelineMetrics",
            "dependencies": [
              6
            ],
            "details": "Collect and aggregate metrics from all five pipeline stages (normalizeMs, composeMs, generateMs, repairMs, validateMs). Include validationsPerRow, repairPassesPerRow, branchTrialsTried, and memory usage. Ensure compatibility with existing PipelineMetrics interface.",
            "status": "done",
            "testStrategy": "Test metrics collection from all stages, verify metric accuracy and completeness",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Implement error propagation",
            "description": "Ensure proper error handling and propagation across all pipeline stages",
            "dependencies": [
              7
            ],
            "details": "Implement comprehensive error handling that preserves error context across pipeline stages. Handle FoundryError types from each stage, maintain error codes, and ensure diagnostic information is properly aggregated and reported.",
            "status": "done",
            "testStrategy": "Test error propagation from each pipeline stage, verify error context preservation and proper error codes",
            "parentId": "undefined"
          },
          {
            "id": 9,
            "title": "Replace Generator stub with task 9 implementation",
            "description": "Replace stub Generator implementation with actual task 9 Generator once completed",
            "dependencies": [
              8
            ],
            "details": "Once task 9 (Generator) is completed, replace the current stub implementation in the pipeline orchestrator with the actual Generator implementation. Ensure proper integration with the pipeline flow, maintain deterministic seeded generation, and verify enum/const precedence handling works correctly.",
            "status": "done",
            "testStrategy": "Integration test to verify Generator stage replacement maintains pipeline functionality and deterministic output",
            "parentId": "undefined"
          },
          {
            "id": 10,
            "title": "Replace Repair Engine stub with task 10 implementation",
            "description": "Replace stub Repair Engine implementation with actual task 10 Repair Engine once completed",
            "dependencies": [
              9
            ],
            "details": "Once task 10 (Repair Engine) is completed, replace the current stub implementation in the pipeline orchestrator with the actual Repair Engine implementation. Ensure proper AJV-driven corrections, idempotent repairs, and repair budgeting work correctly within the pipeline flow.",
            "status": "done",
            "testStrategy": "Integration test to verify Repair Engine stage replacement maintains pipeline functionality and proper repair behavior",
            "parentId": "undefined"
          },
          {
            "id": 11,
            "title": "Tighten dual AJV parity",
            "description": "Review and tighten dual AJV parity once Generator and Repair Engine implementations are integrated",
            "dependencies": [
              10
            ],
            "details": "After integrating the actual Generator and Repair Engine implementations, review the dual AJV validation parity to ensure consistent behavior between Source and Planning AJV instances. Address any discrepancies and ensure proper validation against the original schema throughout the complete pipeline.",
            "status": "done",
            "testStrategy": "Comprehensive validation testing to verify dual AJV parity across all pipeline stages with real implementations",
            "parentId": "undefined"
          },
          {
            "id": 1,
            "title": "Compose pipeline entrypoint",
            "description": "Create main orchestrator entry point in packages/core/src/index.ts that coordinates the five-stage pipeline",
            "dependencies": [],
            "details": "Implement the high-level orchestrator function that coordinates Normalize → Compose → Generate → Repair → Validate stages. This should integrate with the existing FoundryGenerator structure and maintain compatibility with current PipelineStage enum and metrics collection patterns. The orchestrator should handle stage dependencies, error propagation, and metrics aggregation across all pipeline stages.",
            "status": "done",
            "testStrategy": "Unit test for pipeline coordination logic, integration test for end-to-end execution with metrics collection",
            "parentId": "undefined",
            "updatedAt": "2025-10-14T18:37:31.916Z"
          },
          {
            "id": 2,
            "title": "Integrate Normalizer stage",
            "description": "Wire task 7 (Normalizer) implementation into the pipeline orchestrator",
            "dependencies": [
              1
            ],
            "details": "Integrate the Normalizer from task 7 as the first stage in the pipeline. Handle draft unification, boolean/trivial simplifications, conditional rewrite options, and propertyNames rewrite. Ensure proper error handling and metrics collection for the normalization stage.",
            "status": "done",
            "testStrategy": "Test normalization stage integration with various schema types and conditional rewrite scenarios",
            "parentId": "undefined",
            "updatedAt": "2025-10-14T18:37:38.010Z"
          },
          {
            "id": 3,
            "title": "Integrate Composition Engine stage",
            "description": "Wire task 8 (Composition Engine) implementation into the pipeline orchestrator [Updated: 10/14/2025]",
            "dependencies": [
              2
            ],
            "details": "Integrate the Composition Engine from task 8 as the second stage in the pipeline. Handle effective view building, must-cover additionalProperties:false, bag contains semantics, and rational multipleOf calculations. Ensure proper data flow from Normalizer to Composition stage.\n<info added on 2025-10-14T18:19:41.172Z>\nLet me analyze the codebase to understand the current project structure and implementation patterns before updating the subtask status.Based on my analysis of the codebase, I can see that:\n\n1. **The Composition Engine is implemented** in `/Users/fstepho/dev/foundry/foundrydata/packages/core/src/transform/composition-engine.ts` - it exports a `compose` function and `CompositionEngine` class.\n\n2. **Pipeline integration exists** in `/Users/fstepho/dev/foundry/foundrydata/test/__tests__/integration/pipeline/full-pipeline.test.ts` showing parsing → generation → validation flow.\n\n3. **The project structure** uses a monorepo with packages in `packages/core/src/` for core functionality.\n\n4. **Task validation commands** exist in `package.json:32-33` with `task-ready` and `task-complete` scripts.\n\nThe user request is simply \"set status to in-progress\" - this is a status change request that doesn't require detailed implementation information, just an acknowledgment that work has begun on integrating the Composition Engine into the pipeline orchestrator.\n\nStarted integrating Composition Engine from task 8 into pipeline orchestrator as second stage. Working on wiring data flow from Normalizer to Composition stage with proper handling of effective view building, additionalProperties:false semantics, and rational multipleOf calculations.\n</info added on 2025-10-14T18:19:41.172Z>",
            "status": "done",
            "testStrategy": "Test composition stage integration with complex object patterns and array constraints",
            "parentId": "undefined",
            "updatedAt": "2025-10-14T18:37:44.402Z"
          }
        ]
      },
      {
        "id": 12,
        "title": "Modes & External $ref",
        "description": "Implement Strict vs Lax behaviors and external $ref skip-eligibility probe.",
        "priority": "medium",
        "estimatedHours": 12,
        "dependencies": [
          "13",
          "8000",
          "9000",
          "9111",
          "9112"
        ],
        "status": "done",
        "complexityScore": 3,
        "details": "[Context] §11 modes; external-ref-probe; draft classification for internal vs external.\n- spec://§11#external-ref-probe\n[Retrieval]\n- REFONLY::{\"source\":\"FILE\",\"uri\":\"docs/feature-simplification/feature-support-simplification.md\",\"section\":\"§11\",\"anchors\":[\"spec://§11#external-ref-probe\"],\"notes\":\"no-embed; fetch-on-demand\"}\n[Key requirements]\n- Strict: error EXTERNAL_REF_UNRESOLVED; Lax: warn + attempt; heuristic probe to skip validation only when all conditions met; set validationsPerRow=0 when skipped.\n[Deliverables]\n- packages/core/src/util/modes.ts\n[Commands]\n- pnpm i; pnpm -w build; pnpm -w test\n[Definition of Done]\n- Unit tests cover skip eligibility and ref exemplar selection; Strict path aborts planning.",
        "testStrategy": "Unit: compile fail solely due to external refs triggers skip in Lax with metrics set; negative case with mixed errors does not skip.",
        "subtasks": [
          {
            "id": 12001,
            "title": "Implement mode switch and external-ref handling",
            "status": "pending",
            "estimatedHours": 12,
            "file": "packages/core/src/util/modes.ts",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-10-23T22:29:46.726Z"
      },
      {
        "id": 13,
        "title": "Draft handling & $dynamic*",
        "description": "Dialect detection, Ajv class selection, bounded in-document $dynamicRef binding (planning-only).",
        "status": "done",
        "dependencies": [
          "8000",
          "9000",
          "9112"
        ],
        "priority": "medium",
        "details": "[Context] §12 Ajv class selection; bounded in-document dynamic scope.\n- spec://§12#ajv-class-selection\n[Retrieval]\n- REFONLY::{\"source\":\"FILE\",\"uri\":\"docs/feature-simplification/feature-support-simplification.md\",\"section\":\"§12\",\"anchors\":[\"spec://§12#ajv-class-selection\"],\"notes\":\"no-embed; fetch-on-demand\"}\n[Key requirements]\n- Match Ajv class to dialect; optional bounded dynamic binding (depth ≤ guards.maxDynamicScopeHops), planning-only substitution to fragment $ref.\n- Leverage existing dialect detection system in packages/core/src/util/ajv-source.ts with JsonSchemaDialect type and createAjvByDialect function\n- Integrate with current GuardsOptions structure in packages/core/src/types/options.ts for depth bounds\n[Deliverables]\n- packages/core/src/util/draft.ts\n[Commands]\n- pnpm i; pnpm -w build; pnpm -w test\n[Definition of Done]\n- Emits DYNAMIC_SCOPE_BOUNDED when bound; otherwise DYNAMIC_PRESENT; no cross-document I/O.\n- Unit tests pass with existing vitest framework\n- TypeScript compilation succeeds with existing tsconfig",
        "testStrategy": "Unit: binding success/failure cases (with/without $ref on ancestor path); depth bound respected. Use vitest framework matching existing test structure in packages/core/src/**/__tests__/ directories. Test against all supported dialects (draft-07, 2019-09, 2020-12, draft-04).",
        "subtasks": [
          {
            "id": 1,
            "title": "Create draft detection and Ajv class selector",
            "description": "Implement functions to detect JSON Schema dialect and select appropriate Ajv class, building on existing ajv-source.ts infrastructure.",
            "dependencies": [],
            "details": "Create packages/core/src/util/draft.ts with functions that leverage the existing JsonSchemaDialect type, createAjvByDialect, and getAjvClassLabel functions from ajv-source.ts. Implement dialect detection from schema $schema property and provide Ajv class selection interface that integrates with the current architecture.",
            "status": "done",
            "testStrategy": "Unit tests for each supported dialect detection and corresponding Ajv class selection",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement bounded $dynamicRef scope resolver",
            "description": "Add bounded in-document $dynamicRef binding with configurable depth limits using existing GuardsOptions.",
            "dependencies": [
              1
            ],
            "details": "Implement bounded dynamic scope resolution that respects depth limits from GuardsOptions.maxDynamicScopeHops (add this field to GuardsOptions interface in types/options.ts if not present). Provide planning-only substitution to fragment $ref without cross-document I/O. Emit DYNAMIC_SCOPE_BOUNDED when successfully bound within limits, DYNAMIC_PRESENT otherwise.",
            "status": "done",
            "testStrategy": "Unit tests covering depth boundary conditions, successful/failed binding scenarios, and ancestor path resolution with/without $ref",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 14,
        "title": "Cache Strategy",
        "description": "Implement hierarchical caches and memo keys including PlanOptionsSubKey and AJV flags.",
        "priority": "high",
        "estimatedHours": 16,
        "dependencies": [
          "2",
          "3",
          "4",
          "8000",
          "9000",
          "9114",
          "9115"
        ],
        "status": "done",
        "complexityScore": 3,
        "details": "[Context] §14 hierarchy; cache keys; PlanOptionsSubKey canonicalization.\n- spec://§14#hierarchy, spec://§14#cache-keys, spec://§14#planoptionssubkey\n[Retrieval]\n- REFONLY::{\"source\":\"FILE\",\"uri\":\"docs/feature-simplification/feature-support-simplification.md\",\"section\":\"§14\",\"anchors\":[\"spec://§14#planoptionssubkey\"],\"notes\":\"no-embed; fetch-on-demand\"}\n[Key requirements]\n- Include AJV.major, class/dialect, full flag set, and PlanOptionsSubKey in keys. Canonicalize conditionals.strategy:'rewrite' → 'if-aware-lite'.\n[Deliverables]\n- packages/core/src/util/cache.ts\n[Commands]\n- pnpm i; pnpm -w build; pnpm -w test\n[Definition of Done]\n- Deterministic keys; separate LRU spaces for instances; memoized branch picks keyed on (canonPath, seed, AJV.major, AJV.flags, PlanOptionsSubKey[, user salt]).",
        "testStrategy": "Unit: key stability, PlanOptionsSubKey canonicalization, collisions avoided between source/planning instances.",
        "subtasks": [
          {
            "id": 14001,
            "title": "Implement caches and memoization",
            "status": "done",
            "estimatedHours": 16,
            "file": "packages/core/src/util/cache.ts",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 15,
        "title": "Bench Harness & Gates",
        "description": "Benchmark harness and CI gates for p95 latency and memory peaks; metrics wiring.",
        "status": "done",
        "dependencies": [
          "8000",
          "9000",
          "9115",
          "9101",
          "9122",
          "11",
          "6"
        ],
        "priority": "high",
        "details": "[Context] §15 bench protocol & SLO/SLI; §1 bench SLI gate.\n- spec://§15#bench-protocol, spec://§15#slo-sli, spec://§1#bench-sli-gate\n[Retrieval]\n- REFONLY::{\"source\":\"FILE\",\"uri\":\"docs/feature-simplification/feature-support-simplification.md\",\"section\":\"§15\",\"anchors\":[\"spec://§15#bench-protocol\",\"spec://§15#slo-sli\"],\"notes\":\"no-embed; fetch-on-demand\"}\n[Key requirements]\n- Profiles simple/medium/pathological; seeds {1,42,4242}; fail CI when thresholds exceeded.\n- Depends on Pipeline Orchestrator (task 11) for complete pipeline benchmarking.\n[Deliverables]\n- scripts/bench.ts (wired), CI job to run harness\n[Commands]\n- pnpm -w bench\n[Definition of Done]\n- Bench reports p50/p95 & memory; CI job enforces gates; measures complete pipeline performance.",
        "testStrategy": "CI dry-run with reduced iterations; local harness smoke on sample schemas.",
        "subtasks": [
          {
            "id": 1,
            "title": "Extend bench harness + CI wiring",
            "description": "Implement comprehensive benchmark harness that measures complete pipeline performance including Pipeline Orchestrator from task 11",
            "dependencies": [],
            "details": "Create benchmark harness that measures the full 5-stage pipeline (Normalize → Compose → Generate → Repair → Validate) through the Pipeline Orchestrator. Include profiles for simple/medium/pathological schemas with seeds {1,42,4242}. Wire CI job to enforce performance gates and fail when thresholds exceeded.",
            "status": "pending",
            "testStrategy": "Unit tests for harness components, integration tests with sample schemas",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-10-21T22:30:58.373Z"
      },
      {
        "id": 16,
        "title": "Diagnostics payload conformance",
        "description": "Enforce §19.1 mini-schemas, phase separation, and verbosity toggle exposure.",
        "status": "done",
        "dependencies": [
          "6",
          "8000",
          "9000",
          "9119",
          "9108",
          "9107"
        ],
        "priority": "high",
        "details": "[Context] §19 payloads & phase separation; §8 caps separation; verbosity toggle (also in task #6).\n- spec://§19#payloads, spec://§19#phase-separation\n[Retrieval]\n- REFONLY::{\"source\":\"FILE\",\"uri\":\"docs/feature-simplification/feature-support-simplification.md\",\"section\":\"§19\",\"anchors\":[\"spec://§19#payloads\",\"spec://§19#phase-separation\"],\"notes\":\"no-embed; fetch-on-demand\"}\n[Key requirements]\n- Validate representative payloads; ensure REGEX_COMPLEXITY_CAPPED appears only from Normalize/Compose; COMPLEXITY_CAP_PATTERNS only from Generator.\n- Expose verbosity switch integrated with metrics (building on task 6 base implementation).\n- Implement phase separation validation ensuring diagnostic codes appear from correct pipeline stages.\n[Deliverables]\n- packages/core/src/diag/schemas.ts (payload mini-schemas)\n- augment packages/core/src/util/metrics.ts (verbosity - extends task 6)\n[Dependencies]\n- Depends on task 6 for base diagnostics envelope structure and metrics collection system\n[Commands]\n- pnpm -w test\n[Definition of Done]\n- Tests cover distinct phases for caps; toggle active without schema-shape drift; validates phase separation conformance.",
        "testStrategy": "Unit: schema validation for several codes; negative tests for misrouted caps; snapshot tests across verbosity modes; phase separation validation tests.",
        "subtasks": [
          {
            "id": 1,
            "title": "Mini-schemas & validators for diagnostics",
            "description": "Create TypeScript schemas and validators to enforce diagnostic payload conformance per §19.1",
            "dependencies": [],
            "details": "Implement mini-schemas for diagnostic payloads in packages/core/src/diag/schemas.ts. This includes validating that REGEX_COMPLEXITY_CAPPED codes only appear from Normalize/Compose stages and COMPLEXITY_CAP_PATTERNS only from Generator stage. Build validation logic that ensures phase separation requirements are met.",
            "status": "done",
            "testStrategy": "Unit tests for schema validation, negative tests for phase violations",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Verbosity toggle plumbing integration",
            "description": "Integrate verbosity toggle with existing metrics collection system from task 6",
            "dependencies": [],
            "details": "Extend the base metrics and diagnostics envelope from task 6 by adding verbosity toggle functionality to packages/core/src/util/metrics.ts. This should integrate with the existing PlanOptions.metrics boolean and provide granular control over diagnostic output detail levels without breaking existing schema shapes.",
            "status": "done",
            "testStrategy": "Snapshot tests across verbosity modes, integration tests with task 6 envelope",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Phase separation enforcement",
            "description": "Implement validation that diagnostic codes appear only from their designated pipeline phases",
            "dependencies": [
              1
            ],
            "details": "Build enforcement mechanisms to validate that diagnostic codes follow phase separation rules. Ensure REGEX_COMPLEXITY_CAPPED appears only from Normalize/Compose phases and COMPLEXITY_CAP_PATTERNS only from Generator phase. This builds on the mini-schemas from subtask 1 and integrates with the existing pipeline stages.",
            "status": "done",
            "testStrategy": "Unit tests for phase routing validation, negative tests for misrouted caps",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 17,
        "title": "Unit Tests (per section)",
        "description": "Unit test suites mirroring SPEC sections, including fuzzing for oneOf exclusivity and must-cover.",
        "status": "done",
        "dependencies": [
          "7",
          "8",
          "9",
          "10",
          "8000",
          "9000",
          "9120"
        ],
        "priority": "high",
        "details": "[Context] §20 unit coverage plan.\n- spec://§20#unit\n[Retrieval]\n- REFONLY::{\"source\":\"FILE\",\"uri\":\"docs/feature-simplification/feature-support-simplification.md\",\"section\":\"§20\",\"anchors\":[\"spec://§20#unit\"],\"notes\":\"no-embed; fetch-on-demand\"}\n[Key requirements]\n- Property-based tests using AJV as oracle for oneOf exclusivity, AP:false must-cover, contains bag.\n- Tests must validate against the original schema (not transforms)\n- Fixed RNG seeds for deterministic testing\n- Coverage should target core implementation in packages/core/src/\n[Deliverables]\n- packages/core/test/*.spec.ts\n- Unit tests for normalizer (task 7), composition engine (task 8), generator (task 9), and repair engine (task 10)\n- Property-based tests for exclusivity validation and must-cover scenarios\n[Commands]\n- pnpm -w test\n[Definition of Done]\n- ≥80% coverage on touched files; fuzz tests run deterministically with fixed seeds.\n- All core implementation modules have corresponding unit test files\n- Tests pass AJV validation against original schemas",
        "testStrategy": "Organize by section; include tests IDs suggested in §20 where applicable; use fixed RNG seeds. Target existing source files in packages/core/src/ including generator/, validator/, parser/, and types/. Build tests around current implementation structure.",
        "subtasks": [
          {
            "id": 1,
            "title": "Author core unit tests",
            "description": "Create comprehensive unit test suites for core modules including generator, validator, parser, and types",
            "dependencies": [],
            "details": "Build unit tests targeting the existing source structure in packages/core/src/. Focus on modules that support the 5-stage pipeline: generator/, validator/, parser/, and types/. Ensure tests use AJV as oracle and fixed RNG seeds for determinism.",
            "status": "done",
            "testStrategy": "Target existing modules with deterministic test cases using fixed seeds",
            "parentId": "undefined",
            "updatedAt": "2025-10-25T20:52:59.626Z"
          }
        ],
        "updatedAt": "2025-10-25T20:52:59.626Z"
      },
      {
        "id": 18,
        "title": "Integration & e2e",
        "description": "End-to-end scenarios covering modes, AP:false unsafe patterns, oneOf exclusivity refinement.",
        "status": "done",
        "dependencies": [
          "8000",
          "9000",
          "9120",
          "9111",
          "9112",
          "11"
        ],
        "priority": "high",
        "details": "[Context] §20 integration; §8/§11 behaviors.\n- spec://§20#integration\n[Retrieval]\n- REFONLY::{\"source\":\"FILE\",\"uri\":\"docs/feature-simplification/feature-support-simplification.md\",\"section\":\"§20\",\"anchors\":[\"spec://§20#integration\"],\"notes\":\"no-embed; fetch-on-demand\"}\n[Key requirements]\n- Validate Strict vs Lax external $ref handling; exclusivity tweaks logged; AP:false fail-fast vs Safe proof.\n- Test complete Pipeline Orchestrator (task 11) implementation including Normalize → Compose → Generate → Repair → Validate stages\n- Validate mode-specific behaviors routed by Modes task through Pipeline Orchestrator\n[Deliverables]\n- packages/core/test/e2e/*.spec.ts\n[Commands]\n- pnpm -w test\n[Definition of Done]\n- e2e suites pass; run logs show expected diagnostics and exclusivityRand when applicable; complete pipeline validation with all modes and AP:false patterns.",
        "testStrategy": "Implement scenarios listed in §20 integration bullets; assert payload shapes and locus. Test complete FoundryGenerator pipeline orchestration with Strict/Lax modes, external $ref handling, and AP:false unsafe patterns validation.",
        "subtasks": [
          {
            "id": 1,
            "title": "Write e2e pipeline orchestration scenarios",
            "description": "Create comprehensive e2e tests validating the complete 5-stage pipeline implementation from task 11",
            "dependencies": [],
            "details": "Implement end-to-end tests that validate the complete Pipeline Orchestrator implementation including: 1) Normalize → Compose → Generate → Repair → Validate flow; 2) Metrics collection across all stages; 3) Proper error propagation; 4) Mode-specific routing (Strict/Lax); 5) External $ref handling behaviors; 6) AP:false unsafe pattern detection and handling. Tests should reference packages/core/src/generator/foundry-generator.ts orchestration logic and validate against original schema per AJV oracle principle.",
            "status": "done",
            "testStrategy": "Integration smoke: simple schema end-to-end; metrics fields all present; validationsPerRow ≥ 1 unless Lax skip path applies. Test all five pipeline stages execute in sequence with proper metrics collection.",
            "parentId": "undefined",
            "updatedAt": "2025-10-21T21:49:38.421Z"
          }
        ],
        "updatedAt": "2025-10-21T21:49:38.421Z"
      },
      {
        "id": 19,
        "title": "Documentation",
        "description": "Author Invariants, Known-Limits, and Features docs; update README and error catalog.",
        "status": "done",
        "dependencies": [
          "4",
          "7",
          "8",
          "9",
          "10",
          "11",
          "14",
          "17",
          "18",
          "8000",
          "9000",
          "9117",
          "9118"
        ],
        "priority": "medium",
        "details": "[Context] §17 documentation additions; §18 matrix.\n- spec://§17#invariants-doc, spec://§17#known-limits, spec://§17#features-matrix\n[Retrieval]\n- REFONLY::{\"source\":\"FILE\",\"uri\":\"docs/feature-simplification/feature-support-simplification.md\",\"section\":\"§17\",\"anchors\":[\"spec://§17#invariants-doc\",\"spec://§17#known-limits\",\"spec://§17#features-matrix\"],\"notes\":\"no-embed; fetch-on-demand\"}\n[Key requirements]\n- Document cross-phase invariants implemented in Tasks 4-18; limits for patterns and external refs established in core pipeline; feature matrix reflecting actual implementation status.\n[Deliverables]\n- docs/Invariants.md (documenting structural hashing, normalizer guards, composition engine invariants)\n- docs/Known-Limits.md (documenting cache limits, complexity caps, pattern witness caps)\n- docs/Features.md (matrix reflecting implemented features from Tasks 4-18)\n- docs/error.md (error catalog from diagnostic envelope implementation)\n- docs/README.md (updated with actual implementation details)\n[Commands]\n- pnpm -w build\n[Definition of Done]\n- Docs build and lint; cross-referenced anchors consistent with SPEC; documentation accurately reflects implemented features from core tasks.",
        "testStrategy": "Doc linting; link check; quick human review checklist; validation that documented features match implementation in packages/core/src/*.",
        "subtasks": [
          {
            "id": 1,
            "title": "Write Invariants.md documenting cross-phase guarantees",
            "description": "Document invariants from implemented core tasks: structural hashing uniqueness guarantees, normalizer guard behaviors, composition engine coverage guarantees, pipeline metrics consistency.",
            "dependencies": [],
            "details": "Create comprehensive invariants documentation based on completed implementations in Tasks 4 (structural hashing), 7 (normalizer), 8 (composition engine), and pipeline orchestration. Reference actual code behaviors and guarantee definitions from packages/core/src/ modules.",
            "status": "pending",
            "testStrategy": "Verify invariants match implementation behavior through code review and example validation.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Write Known-Limits.md documenting implementation caps",
            "description": "Document limits and caps from core implementations: cache size limits, complexity thresholds, pattern witness generation caps, repair attempt limits, memory usage bounds.",
            "dependencies": [],
            "details": "Document specific limits enforced by implemented features: Task 14 cache limits, Task 8 composition complexity caps, Task 10 repair engine bounds, Task 9 generator limits. Include performance implications and degradation behaviors.",
            "status": "pending",
            "testStrategy": "Validate limits against actual implementation configurations and bench profile constraints.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Write Features.md matrix reflecting actual implementation",
            "description": "Create comprehensive feature support matrix reflecting implementation status of Tasks 4-18: which JSON Schema features are implemented, their support level, and any known limitations.",
            "dependencies": [],
            "details": "Build feature matrix based on actual implementation coverage from core tasks. Include schema support levels, conditional handling, array/object support, numeric handling, and ref resolution capabilities implemented in the pipeline.",
            "status": "pending",
            "testStrategy": "Cross-reference feature claims with unit test coverage and integration test scenarios.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Update error.md catalog with diagnostic codes",
            "description": "Document error catalog based on implemented diagnostic envelope from Task 6 and phase-specific error codes from Tasks 7-11.",
            "dependencies": [],
            "details": "Create comprehensive error documentation reflecting actual diagnostic codes, error propagation patterns, and recovery mechanisms implemented across the 5-stage pipeline. Reference Task 6 diagnostic envelope structure.",
            "status": "pending",
            "testStrategy": "Verify error codes match implementation and are properly categorized by pipeline phase.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Update docs/README.md with implementation details",
            "description": "Update project README with accurate implementation details reflecting completed core tasks, actual performance characteristics, and usage examples based on implemented API.",
            "dependencies": [],
            "details": "Revise README to reflect actual implementation from Tasks 1-18: monorepo structure, pipeline architecture, performance characteristics from bench harness, API examples from Task 21 public API.",
            "status": "pending",
            "testStrategy": "Validate README accuracy against actual package structure and API signatures.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-10-25T23:00:27.800Z"
      },
      {
        "id": 20,
        "title": "Fixtures & Bench profiles",
        "description": "Provide test fixtures and bench profiles (simple/medium/pathological); property-based generators for fuzzing.",
        "priority": "medium",
        "estimatedHours": 8,
        "dependencies": [
          "8000",
          "9000",
          "9115",
          "9120"
        ],
        "status": "done",
        "complexityScore": 2,
        "details": "[Context] §15 bench protocol; §20 unit/property-based tests.\n- spec://§15#bench-protocol, spec://§20#unit\n[Retrieval]\n- REFONLY::{\"source\":\"FILE\",\"uri\":\"docs/feature-simplification/feature-support-simplification.md\",\"section\":\"§15\",\"anchors\":[\"spec://§15#bench-protocol\"],\"notes\":\"no-embed; fetch-on-demand\"}\n[Key requirements]\n- Curate JSON Schemas and seeds; expose generators for fuzz tests; track metrics expectations.\n[Deliverables]\n- profiles/{simple,medium,pathological}.json\n- packages/core/test/fixtures/*\n[Commands]\n- pnpm -w test; pnpm -w bench\n[Definition of Done]\n- Bench runs on profiles; fixtures imported by tests.",
        "testStrategy": "Bench smoke and fixture validation with AJV.",
        "subtasks": [
          {
            "id": 20001,
            "title": "Create profiles and fixtures",
            "status": "done",
            "estimatedHours": 8,
            "file": "profiles/simple.json",
            "parentId": "undefined",
            "updatedAt": "2025-10-25T21:21:57.627Z"
          }
        ],
        "updatedAt": "2025-10-25T21:21:57.627Z"
      },
      {
        "id": 21,
        "title": "Public API & TS types",
        "description": "Exported functions and types for normalize/compose/generate/repair; stable signatures.",
        "priority": "medium",
        "estimatedHours": 12,
        "dependencies": [
          "8000",
          "9000",
          "9123",
          "9122"
        ],
        "status": "done",
        "complexityScore": 3,
        "details": "[Context] §23 interfaces; §22 deliverables.\n- spec://§23#compose-interfaces, spec://§23#repair-interfaces\n[Retrieval]\n- REFONLY::{\"source\":\"FILE\",\"uri\":\"docs/feature-simplification/feature-support-simplification.md\",\"section\":\"§23\",\"anchors\":[\"spec://§23#compose-interfaces\",\"spec://§23#repair-interfaces\"],\"notes\":\"no-embed; fetch-on-demand\"}\n[Key requirements]\n- API mirrors minimal interfaces; do not expose internal caches.\n[Deliverables]\n- packages/core/src/index.ts (exports)\n- type declarations\n[Commands]\n- pnpm -w build\n[Definition of Done]\n- Type tests compile; API docs reflect interface anchors.",
        "testStrategy": "TS compile tests; simple programmatic examples.",
        "subtasks": [
          {
            "id": 21001,
            "title": "Export public API and types",
            "status": "pending",
            "estimatedHours": 12,
            "file": "packages/core/src/index.ts",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-10-25T22:01:01.164Z"
      },
      {
        "id": 22,
        "title": "CI pipelines (lint, test, bench)",
        "description": "Set up CI with linting, unit/integration tests, and bench gates.",
        "status": "done",
        "dependencies": [
          "8000",
          "9000",
          "9101",
          "9115",
          "9120",
          "17",
          "18"
        ],
        "priority": "high",
        "details": "[Context] §1 acceptance gates; §15 bench protocol.\n- spec://§1#bench-sli-gate, spec://§15#bench-protocol\n[Retrieval]\n- REFONLY::{\"source\":\"FILE\",\"uri\":\"docs/feature-simplification/feature-support-simplification.md\",\"section\":\"§1\",\"anchors\":[\"spec://§1#bench-sli-gate\"],\"notes\":\"no-embed; fetch-on-demand\"}\n[Key requirements]\n- Jobs: lint → unit → integration → bench; fail on SLO breaches.\n- Requires completed unit test suite (task 17) and integration test suite (task 18) to execute\n- CI pipeline must validate test implementations before proceeding to bench gates\n[Deliverables]\n- .github/workflows/ci.yml\n[Commands]\n- n/a (CI runs)\n[Definition of Done]\n- CI green on baseline; bench gate enforced.\n- Unit and integration test suites execute successfully in CI pipeline",
        "testStrategy": "CI dry-run with reduced iterations; verify failure on forced breach. Test that CI correctly executes unit tests from task 17 and integration tests from task 18.",
        "subtasks": [
          {
            "id": 1,
            "title": "Create CI workflow with test dependencies",
            "description": "Set up GitHub Actions workflow that executes lint, unit tests, integration tests, and bench gates in sequence",
            "dependencies": [],
            "details": "Create .github/workflows/ci.yml that runs the test suites implemented in tasks 17 and 18. Pipeline must fail if unit or integration tests fail, before proceeding to bench gates. Include proper job dependencies and failure handling.",
            "status": "pending",
            "testStrategy": "Verify workflow triggers on PR/push, executes all test phases, and fails appropriately on test failures",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-10-25T21:00:31.474Z"
      },
      {
        "id": 23,
        "title": "P2 refinements",
        "description": "Deferred features: propertyNames pattern-form rewrite; pattern approximations for must-cover; contains subsumption.",
        "priority": "medium",
        "estimatedHours": 8,
        "dependencies": [
          "8000",
          "9000",
          "9116",
          "9108"
        ],
        "status": "done",
        "complexityScore": 2,
        "details": "[Context] §16 Phase P2; §7 propertyNames pattern-form; §8 pattern approximations.\n- spec://§16#phase-p2, spec://§7#object-keywords-pnames-rewrite\n[Retrieval]\n- REFONLY::{\"source\":\"FILE\",\"uri\":\"docs/feature-simplification/feature-support-simplification.md\",\"section\":\"§16\",\"anchors\":[\"spec://§16#phase-p2\"],\"notes\":\"no-embed; fetch-on-demand\"}\n[Key requirements]\n- Implement anchored-safe pattern-form rewrite with all guards; keep phase separation diagnostics.\n[Deliverables]\n- Extend schema-normalizer.ts and composition-engine.ts\n[Commands]\n- pnpm -w build; pnpm -w test\n[Definition of Done]\n- New rewrite gated by unevaluated*, complexity cap, and anchored-safe rules; tests added.",
        "testStrategy": "Unit: acceptance/refusal for pattern-form; integration: must-cover finite enumeration updated when PNAMES_REWRITE_APPLIED present.",
        "subtasks": [
          {
            "id": 23001,
            "title": "Enable pattern-form rewrite",
            "status": "pending",
            "estimatedHours": 8,
            "file": "packages/core/src/transform/schema-normalizer.ts",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-10-25T22:43:32.556Z"
      },
      {
        "id": 24,
        "title": "Packaging & Release",
        "description": "Prepare versioning, changelog, and publish configuration; SemVer alignment.",
        "priority": "medium",
        "estimatedHours": 8,
        "dependencies": [
          "8000",
          "9000",
          "9124",
          "9117"
        ],
        "status": "done",
        "complexityScore": 2,
        "details": "[Context] §24 references (SemVer); §17 docs.\n- spec://§24#normative\n[Retrieval]\n- REFONLY::{\"source\":\"FILE\",\"uri\":\"docs/feature-simplification/feature-support-simplification.md\",\"section\":\"§24\",\"anchors\":[\"spec://§24#normative\"],\"notes\":\"no-embed; fetch-on-demand\"}\n[Key requirements]\n- Changelog and release scripts; version tags; license headers.\n[Deliverables]\n- package.json versioning scripts; docs/CHANGELOG.md\n[Commands]\n- pnpm version <x.y.z>\n[Definition of Done]\n- Release artifact builds; changelog updated; tagged commit.",
        "testStrategy": "Dry-run publish; verify files included.",
        "subtasks": [
          {
            "id": 24001,
            "title": "Prepare release artifacts and changelog",
            "status": "in-progress",
            "estimatedHours": 8,
            "file": "docs/CHANGELOG.md",
            "parentId": "undefined",
            "updatedAt": "2025-10-25T23:13:38.405Z"
          }
        ],
        "updatedAt": "2025-10-25T23:33:28.505Z"
      },
      {
        "id": 9125,
        "title": "Ensure generator emits minimal root container for OpenAPI schemas requiring paths/components/webhooks anyOf",
        "description": "Implement generator logic to handle OpenAPI 3.1 schema root containers that require at least one of paths, components, or webhooks properties via anyOf constraint.",
        "details": "[Context] OpenAPI 3.1 schemas define a root object with an anyOf constraint requiring at least one of 'paths', 'components', or 'webhooks' properties. The generator must emit minimal valid containers respecting this constraint while following §9 minimal-width policy.\n\n[Implementation Requirements]\n1. **AnyOf Branch Selection**: Apply §8 branch selection algorithm to choose which of the three required properties (paths/components/webhooks) to emit\n2. **Minimal Width Policy**: Following §9#objects-minimal-width, emit only required keys ('openapi', 'info') plus the minimum necessary to satisfy the anyOf constraint\n3. **Container Structure**: Generate appropriate minimal container structures:\n   - paths: empty object {} or minimal valid paths object\n   - components: empty object {} or minimal components structure\n   - webhooks: empty object {} or minimal webhooks structure\n4. **Integration with Effective View**: Use CoverageIndex from Composition Engine (task 8) to determine which properties are in the must-cover set\n5. **Deterministic Selection**: Ensure consistent branch selection based on seed for reproducible generation\n\n[Technical Approach]\n- Modify foundry-generator.ts to detect OpenAPI anyOf root constraints\n- Implement special handling for root-level anyOf that requires container properties\n- Ensure generator respects minimal-width policy while satisfying anyOf requirements\n- Integrate with existing branch selection logic from §8\n- Handle edge cases where multiple branches could be satisfied simultaneously\n\n[Files to Modify]\n- packages/core/src/generator/foundry-generator.ts (main generator logic)\n- Add test cases for OpenAPI 3.1 schema generation scenarios\n\n[SPEC References]\n- spec://§9#objects-minimal-width - minimal width policy for objects\n- spec://§8#branch-selection-algorithm - anyOf/oneOf branch selection\n- spec://§9#if-aware-lite - conditional handling strategies",
        "testStrategy": "1. **Unit Tests**: Create test cases using the OpenAPI 3.1 schema from profiles/real-world/openapi-3.1.schema.json\n   - Test generation with various seeds to ensure deterministic branch selection\n   - Verify only one of paths/components/webhooks is emitted per generation\n   - Confirm minimal container structure (no extra properties beyond requirements)\n   \n2. **Integration Tests**: \n   - Generate multiple OpenAPI documents and validate against original schema using AJV\n   - Test that generated documents satisfy the anyOf constraint\n   - Verify generated containers are valid OpenAPI structures\n   \n3. **Branch Selection Tests**:\n   - Test all three branches (paths, components, webhooks) can be selected\n   - Verify branch selection is deterministic for given seed\n   - Test interaction with other schema constraints (required properties, minProperties)\n   \n4. **Regression Tests**:\n   - Ensure existing generator functionality remains unaffected\n   - Test performance metrics stay within SLO targets\n   - Verify diagnostics are properly emitted for complex cases",
        "status": "done",
        "dependencies": [
          "9",
          "8"
        ],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2025-10-27T11:29:34.987Z"
      },
      {
        "id": 9126,
        "title": "Fix repair stage to synthesize string required properties correctly when schemas resolve via $ref",
        "description": "Enhance the repair engine to properly handle string property synthesis when schema resolution involves $ref references that may obscure required property constraints.",
        "details": "[Context] The repair stage currently has issues synthesizing string properties when schemas use $ref to reference definitions, causing the required property constraints to be missed during repair operations.\n\n[Root Cause Analysis]\n- When schemas use $ref to reference string property definitions, the repair engine may not properly resolve the reference chain to identify required string properties\n- The current repair mapping (§10#mapping) may not account for dereferenced schema contexts where string constraints are defined in external references\n- Property synthesis logic may be operating on the normalized schema without proper $ref resolution for repair-specific operations\n\n[Implementation Requirements]\n1. **Reference Resolution Enhancement**: Extend repair engine to properly traverse $ref chains when identifying required string properties for synthesis\n2. **Context Preservation**: Ensure that when a required property is defined via $ref, the repair engine maintains the full constraint context from the referenced schema\n3. **String Synthesis Logic**: Update string property synthesis to work with dereferenced schemas, ensuring format, pattern, and length constraints are properly applied\n4. **Integration with CoverageIndex**: Ensure the MUSTCOVER index correctly identifies string properties that need synthesis even when defined via $ref\n\n[Technical Approach]\n- Modify repair engine's property analysis phase to follow $ref resolution paths\n- Update string synthesis logic in packages/core/repair/ to handle dereferenced property definitions\n- Ensure epsilon logging captures $ref resolution steps for debugging\n- Integrate with existing AJV-driven repair validation to maintain correctness\n\n[Files to Modify]\n- packages/core/repair/index.ts (main repair orchestration)\n- packages/core/repair/property-synthesis.ts (string property logic)\n- packages/core/util/ref-resolver.ts (if exists, or create for $ref handling)\n- packages/core/repair/coverage-index.ts (MUSTCOVER integration)",
        "testStrategy": "1. **Unit Tests**: Create test cases with schemas that define required string properties via $ref references\n   - Test schemas with local $ref to definitions section\n   - Test schemas with nested $ref chains (ref -> ref -> string definition)\n   - Verify string properties are correctly synthesized with all constraints (format, pattern, minLength, maxLength)\n\n2. **Integration Tests**: Test repair stage with real-world schemas that use $ref extensively\n   - Use OpenAPI schemas that reference string definitions\n   - Test JSON Schema with complex $ref structures\n   - Verify AJV validation passes after repair operations\n\n3. **Regression Tests**: Ensure existing repair functionality remains intact\n   - Test non-$ref string property synthesis still works\n   - Verify other property types (numbers, arrays, objects) are unaffected\n   - Confirm epsilon logging captures $ref resolution steps\n\n4. **Property-Based Testing**: Generate schemas with various $ref patterns and verify consistent string synthesis\n   - Test with different reference depths\n   - Test with circular reference detection\n   - Verify deterministic behavior across multiple repair passes",
        "status": "done",
        "dependencies": [
          "10",
          "9110"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2025-10-27T14:02:16.511Z"
      },
      {
        "id": 9127,
        "title": "Implement Extension R1: HTTP(S) resolver + local cache + offline planning stubs",
        "description": "Task superseded by #9128 which provides comprehensive breakdown of Extension R1 implementation with full subtask structure. This task serves as historical context for the Extension R1 specification and requirements analysis.",
        "status": "cancelled",
        "dependencies": [
          "4",
          "12",
          "14"
        ],
        "priority": "high",
        "details": "**SUPERSEDED BY TASK #9128**\n\nThis task has been replaced by task #9128 which provides a more comprehensive breakdown of Extension R1 implementation with detailed subtasks. Task #9128 includes:\n\n- 16 subtasks covering all aspects of resolver implementation\n- Updated technical architecture aligned with current codebase structure\n- Enhanced test strategy with specific integration test cases\n- Detailed CLI integration specifications\n- Cache system integration with existing infrastructure\n\n**Historical Context**: This task originally specified implementing the optional HTTP(S) resolver extension with prefetch & cache fill, local on-disk cache, in-memory resolution registry, and Lax mode offline planning stubs as specified in SPEC sections §1, §2, §4, §5, §7, §11, §14, §19, §20, §23.\n\n**Migration Note**: Use task #9128 for actual implementation. This task remains for historical reference and maintains the same dependencies (4, 12, 14) which have been properly transferred to the new task structure.\n\n**Key Implementation Files Identified in Codebase Analysis**:\n- `packages/core/src/util/cache.ts` - Existing cache infrastructure to extend\n- `packages/core/src/types/options.ts` - Configuration system for new ResolverOptions\n- `packages/cli/src/flags.ts` - CLI flag parsing infrastructure\n\nThe codebase analysis confirms the architecture proposed in the original specification aligns well with the existing modular structure, particularly the cache and options systems that are already well-established.",
        "testStrategy": "**TEST STRATEGY MIGRATED TO TASK #9128**\n\nThe comprehensive test strategy has been moved to task #9128 which includes:\n\n**Unit Tests**: Resolver core, cache system, registry management, prefetch logic, Lax mode stubs, CLI integration\n\n**Integration Tests**: \n- R-RESOLVER-ONLINE-01: End-to-end with live HTTP requests\n- R-RESOLVER-OFFLINE-01: Offline behavior with populated cache\n- R-RESOLVER-FINGERPRINT-01: Cache key integration\n- R-RESOLVER-DIAG-01/02: Diagnostic export and Lax mode behavior\n\n**Property-Based Tests**: Cache consistency, registry determinism, URL canonicalization\n\n**Benchmark Tests**: Resolver overhead, cache performance, network concurrency, bench gate compliance\n\n**Acceptance Criteria**: CI passes, bench gates unchanged, ≥80% coverage, CLI help text updated, deterministic behavior\n\nRefer to task #9128 for complete test specifications and implementation guidance.",
        "subtasks": []
      },
      {
        "id": 9128,
        "title": "Extension R1: HTTP(S) resolver + local cache + Lax planning stubs",
        "description": "Implement optional HTTP(S) resolver extension with prefetch & cache fill, local on-disk cache, in-memory resolution registry, and Lax mode offline planning stubs.",
        "details": "**Context**: Extension R1 is an opt-in HTTP(S) resolver system that enables network I/O only in a pre-pipeline 'Prefetch & Cache Fill' step, keeping core phases (Normalize → Compose → Generate → Repair → Validate) I/O-free. This aligns with SPEC anchors across multiple sections.\n\n**Implementation Requirements**:\n\n1. **Resolver Core Infrastructure** (§4, §23):\n   - Implement `ResolverOptions` interface with `strategies: ['local' | 'remote' | 'schemastore']` (default `['local']`)\n   - Add `cacheDir?: string` with `~` canonicalization support\n   - Add `allowlist?: string[]` for URL filtering\n   - Add `bounds: { timeoutMs: number; maxSizeBytes: number; maxDepth: number }` with defaults\n   - Create `HttpResolver` class with strategy-based fetch logic\n   - Support Schema Store API integration for common schemas\n\n2. **Cache System** (§14, §19):\n   - Implement on-disk cache with atomic write operations\n   - Cache key format: `${stableHash(url)}-${etag || lastModified || 'none'}.json`\n   - Support cache invalidation based on HTTP headers\n   - Add cache metadata file for tracking entries and cleanup\n   - Handle concurrent access and corruption recovery\n\n3. **In-Memory Registry** (§7, §11):\n   - Create `ResolutionRegistry` to store resolved schemas during execution\n   - Map canonical URLs to resolved schema objects\n   - Support fingerprinting for cache key integration (`registryFingerprint`)\n   - Implement read-only access during generation phases\n\n4. **Prefetch & Cache Fill Phase** (§2, §20):\n   - Add pre-pipeline phase that scans schema for external $refs\n   - Implement parallel fetching with concurrency limits\n   - Populate both on-disk cache and in-memory registry\n   - Generate resolution diagnostics with canonical paths\n   - Support retry logic and graceful degradation\n\n5. **Lax Mode Integration** (§11, §12):\n   - Implement `EXTERNAL_REF_STUBBED` diagnostic code\n   - Add planning-time stub generation for unresolved external refs\n   - Maintain deterministic behavior with stub schemas\n   - Integrate with existing external ref policy framework\n\n6. **CLI Integration** (existing CLI structure):\n   - Add `--resolve` flag to enable resolver (default: false)\n   - Add `--cache-dir <path>` flag with `~` expansion\n   - Add `--fail-on-unresolved` flag for strict resolution\n   - Update help text and validation\n\n7. **Cache Key Integration** (§14):\n   - Extend `createCacheKeyContext()` to include `registryFingerprint`\n   - Update `buildBranchMemoKey()` to incorporate resolver state\n   - Ensure cache invalidation when registry changes\n\n8. **Diagnostics Export** (§20, §23):\n   - Add `Compose.diag.run` with resolver diagnostics\n   - Include `canonPath: '#'` for run-level diagnostics\n   - Export resolution success/failure counts and timing\n   - Track cache hit ratios and network requests\n\n**Technical Architecture**:\n- Extend `PlanOptions` interface with `resolver?: ResolverOptions`\n- Add resolver module at `packages/core/src/resolver/`\n- Integrate with existing cache system in `packages/core/src/util/cache.ts`\n- Update pipeline orchestrator to include prefetch phase\n- Maintain compatibility with existing external ref handling\n\n**Key Files to Modify**:\n- `packages/core/src/types/options.ts` - Add ResolverOptions interface\n- `packages/core/src/pipeline/orchestrator.ts` - Add prefetch phase\n- `packages/core/src/util/cache.ts` - Extend cache key system\n- `packages/cli/src/flags.ts` - Add resolver CLI flags\n- `packages/cli/src/index.ts` - Integrate resolver CLI options\n\n**New Files to Create**:\n- `packages/core/src/resolver/http-resolver.ts` - Core resolver implementation\n- `packages/core/src/resolver/cache-manager.ts` - On-disk cache management\n- `packages/core/src/resolver/registry.ts` - In-memory resolution registry\n- `packages/core/src/resolver/prefetch.ts` - Pre-pipeline fetching logic\n- `packages/core/src/resolver/types.ts` - Resolver type definitions",
        "testStrategy": "**Unit Tests**:\n1. **Resolver Core**: Test HTTP fetching, strategy validation, URL parsing, timeout handling\n2. **Cache System**: Test on-disk persistence, cache invalidation, concurrent access, corruption recovery\n3. **Registry Management**: Test in-memory registry population, read-only access, fingerprinting\n4. **Prefetch Logic**: Test parallel fetching, concurrency limits, retry mechanisms\n5. **Lax Mode Stubs**: Test stub generation, deterministic behavior, diagnostic emission\n6. **CLI Integration**: Test flag parsing, path canonicalization, help text\n\n**Integration Tests**:\n1. **R-RESOLVER-ONLINE-01**: End-to-end test with live HTTP requests to Schema Store\n   - Schema with external refs to common schemas (JSON Schema meta-schema, OpenAPI)\n   - Verify cache population and registry hydration\n   - Assert generated data validates against resolved schemas\n\n2. **R-RESOLVER-OFFLINE-01**: Test offline behavior with populated cache\n   - Pre-populate cache with known schemas\n   - Disable network access\n   - Verify cache-only resolution works correctly\n\n3. **R-RESOLVER-FINGERPRINT-01**: Test cache key integration\n   - Generate data with resolver enabled/disabled\n   - Verify different cache keys and no cache pollution\n   - Test registry fingerprint affects memoization\n\n4. **R-RESOLVER-DIAG-01**: Test diagnostic export\n   - Verify `Compose.diag.run` contains resolver metrics\n   - Check canonical path format and timing data\n   - Test success/failure diagnostic codes\n\n5. **R-RESOLVER-DIAG-02**: Test Lax mode stub behavior\n   - Schema with unresolvable external refs\n   - Verify `EXTERNAL_REF_STUBBED` diagnostics\n   - Assert deterministic stub generation\n\n**Property-Based Tests**:\n1. **Cache Consistency**: Verify cache operations are atomic and consistent\n2. **Registry Determinism**: Same input always produces same registry state\n3. **URL Canonicalization**: Test various URL formats produce consistent cache keys\n\n**Benchmark Tests**:\n1. Measure resolver overhead with/without caching\n2. Test cache performance with various schema sizes\n3. Verify network concurrency limits are respected\n4. Ensure bench gates (p50 ≈ 200-400ms) remain unchanged for local schemas\n\n**Acceptance Criteria**:\n- CI passes all existing and new tests\n- Bench gates unchanged for non-resolver workflows\n- Coverage ≥80% on all touched files\n- CLI help text updated and validated\n- Integration with existing external ref policy\n- Deterministic behavior in both online/offline modes",
        "status": "done",
        "dependencies": [
          "4",
          "12",
          "14"
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Scaffold resolver modules and options",
            "description": "Add packages/core/src/resolver/{http-resolver.ts,cache-store.ts,registry.ts,options.ts,cli-mapping.ts} with ResolverOptions defaults, unioned strategies semantics, built-in schemastore allowlist, and '~' cacheDir canonicalization (absolute path).",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 9128,
            "parentId": "undefined",
            "updatedAt": "2025-10-27T22:04:00.745Z"
          },
          {
            "id": 2,
            "title": "Implement cache-store",
            "description": "On-disk cache separate from plan caches: layout resolver.cacheDir/sha256(uri)/{content.json,meta.json}, meta includes {uri,contentHash,etag?}. Implement canonical JSON hashing (sorted keys, arrays in order, -0→0), atomic writes, '~' expansion, absolute normalized path, bounds (maxDocs, maxRefDepth, maxBytesPerDoc), no TTL by default.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 9128,
            "parentId": "undefined",
            "updatedAt": "2025-10-27T22:04:00.748Z"
          },
          {
            "id": 3,
            "title": "Implement HTTP(S) resolver",
            "description": "HTTP client with allowlist and strategy union ('local','schemastore','remote'), case-insensitive host matching, followRedirects<=3, timeoutMs, maxBytesPerDoc, acceptYaml normalization. Compute contentHash (SHA-256) and return bytes+meta; respect bounds and disallow network when extension disabled.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 9128,
            "parentId": "undefined",
            "updatedAt": "2025-10-27T22:04:00.752Z"
          },
          {
            "id": 4,
            "title": "Prefetch & Cache Fill pre-phase",
            "description": "Traverse schema(s) to collect external  URIs (respecting maxRefDepth, maxDocs); fetch via resolver; hydrate on-disk cache; build in-memory registry (uri→{bytes,contentHash}); compute resolver.registryFingerprint per §14; export run-level diagnostics (strategies applied, cache hit/miss, offline unavailable).",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 9128,
            "parentId": "undefined",
            "updatedAt": "2025-10-27T22:04:00.753Z"
          },
          {
            "id": 5,
            "title": "Integrate registry into planning/validation",
            "description": "Compose/Planning AJV receives addSchema for cached documents; core phases perform no I/O; Validate continues to use original schema. Ensure Normalizer/Compose preserve external  verbatim; consult registry read-only. Guard against cross-document dynamicRef.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 9128,
            "parentId": "undefined",
            "updatedAt": "2025-10-27T22:04:00.755Z"
          },
          {
            "id": 6,
            "title": "Cache/memo keys and PlanOptionsSubKey updates",
            "description": "Include resolver.registryFingerprint in compose/plan cache keys when extension active or stubUnresolved:'emptySchema'. Add 'resolver.stubUnresolved' to PlanOptionsSubKey. Ensure stable JSON encoding and AJV flags parity per §14.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 9128,
            "parentId": "undefined",
            "updatedAt": "2025-10-27T22:04:00.757Z"
          },
          {
            "id": 7,
            "title": "Lax planning stubs and skip eligibility",
            "description": "When resolver.stubUnresolved:'emptySchema' and Lax, treat unresolved external  as {} in effective view only; emit EXTERNAL_REF_STUBBED; enforce ExternalRefSkipEligibility for final validation skip per §11; keep original schema unchanged.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 9128,
            "parentId": "undefined",
            "updatedAt": "2025-10-27T22:04:00.759Z"
          },
          {
            "id": 8,
            "title": "Diagnostics: run-level and per-path",
            "description": "Export resolver run-level diagnostics under Compose.diag.run with canonPath:'#': RESOLVER_STRATEGIES_APPLIED, RESOLVER_CACHE_HIT, RESOLVER_CACHE_MISS_FETCHED, RESOLVER_OFFLINE_UNAVAILABLE. Emit EXTERNAL_REF_STUBBED for planning stubs and EXTERNAL_REF_UNRESOLVED per mode; ensure details payloads match §19 mini-schemas.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 9128,
            "parentId": "undefined",
            "updatedAt": "2025-10-27T22:04:00.761Z"
          },
          {
            "id": 9,
            "title": "CLI mapping",
            "description": "Add CLI flags: --resolve=local[,remote][,schemastore], --cache-dir <path> with '~' expansion, --fail-on-unresolved=false mapping to Lax + resolver.stubUnresolved:'emptySchema'. Update help text and README snippets.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 9128,
            "parentId": "undefined",
            "updatedAt": "2025-10-27T22:04:00.763Z"
          },
          {
            "id": 10,
            "title": "Unit tests: resolver options & cache",
            "description": "Tests for ResolverOptions defaults, '~' expansion to absolute path, allowlist semantics and unioned strategies; cache-store atomic write/read, canonical JSON hashing, meta.json content; bounds handling (maxBytesPerDoc, maxDocs, followRedirects, timeoutMs).",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 9128,
            "parentId": "undefined",
            "updatedAt": "2025-10-27T22:04:00.765Z"
          },
          {
            "id": 11,
            "title": "Integration: R-RESOLVER-ONLINE-01",
            "description": "With resolver.strategies:['local','remote','schemastore'] and empty cache, resolve https://json.schemastore.org/package and https://www.asyncapi.com/spec/3.0.0.json. Expect RESOLVER_CACHE_MISS_FETCHED then RESOLVER_CACHE_HIT on second run; no EXTERNAL_REF_UNRESOLVED.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 9128,
            "parentId": "undefined",
            "updatedAt": "2025-10-27T22:04:00.767Z"
          },
          {
            "id": 12,
            "title": "Integration: R-RESOLVER-OFFLINE-01",
            "description": "With network disabled or allowlist excluding hosts and resolver.stubUnresolved:'emptySchema' in Lax, expect RESOLVER_OFFLINE_UNAVAILABLE run-level notes, EXTERNAL_REF_STUBBED warnings, generation proceeds, final validation may be skipped per ExternalRefSkipEligibility (diag.metrics.validationsPerRow=0).",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 9128,
            "parentId": "undefined",
            "updatedAt": "2025-10-27T22:04:00.770Z"
          },
          {
            "id": 13,
            "title": "Integration: R-RESOLVER-FINGERPRINT-01",
            "description": "Change the bytes or set of cached external documents and verify compose/plan cache keys change due to resolver.registryFingerprint; prevent reuse across different registry states.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 9128,
            "parentId": "undefined",
            "updatedAt": "2025-10-27T22:04:00.772Z"
          },
          {
            "id": 14,
            "title": "Integration: R-RESOLVER-DIAG-01/02",
            "description": "Assert resolver diagnostics under compose(...).diag.run with canonPath:'#': strategies applied (once), cache hit/miss, offline unavailable; ensure no diag.fatal from resolver; verify EXTERNAL_REF_STUBBED is emitted for planning stubs (Lax).",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 9128,
            "parentId": "undefined",
            "updatedAt": "2025-10-27T22:04:00.774Z"
          },
          {
            "id": 15,
            "title": "Docs and CLI help updates",
            "description": "Update README.md, error.md, Known-Limits.md and CLI --help with resolver extension R1, flags, behavior summary, and DoD. Add changelog entries. Ensure acceptance examples (online/offline) are documented.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 9128,
            "parentId": "undefined",
            "updatedAt": "2025-10-27T22:04:00.776Z"
          },
          {
            "id": 16,
            "title": "Bench & CI gates unchanged",
            "description": "Verify p95 latency ≤120ms and memory ≤512MB on existing profiles remain unchanged for local schemas; ensure resolver pre-phase is excluded from core SLI measurement; add CI toggles/seeding for online/offline tests to ensure reproducibility.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 9128,
            "parentId": "undefined",
            "updatedAt": "2025-10-27T22:04:00.777Z"
          }
        ],
        "updatedAt": "2025-10-27T22:04:00.777Z"
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-10-27T22:04:00.779Z",
      "taskCount": 56,
      "completedCount": 55,
      "tags": [
        "feature-simplification"
      ],
      "created": "2025-11-15T18:28:26.017Z",
      "description": "Tasks for feature-simplification context",
      "updated": "2025-11-15T18:28:26.017Z"
    }
  },
  "jsg-p1-automata-smt": {
    "tasks": [
      {
        "id": "1",
        "title": "Establish invariants & diagnostics scaffold",
        "description": "Lay down AJV-oracle invariant, dual AJV instances, deterministic RNG, and the diagnostics envelope in code.",
        "status": "done",
        "dependencies": [
          "21"
        ],
        "priority": "high",
        "details": "- Add two AJV instances (planning vs original) with unicodeRegExp:true on both.\n- Enforce parity check and throw AJV_OPTIONS_MISMATCH on mismatch.\n- Introduce xorshift32 RNG seeded by (seed, canonPath); remove any global/time/locale dependence.\n- Implement Diagnostic envelope {code, canonPath, details} and central registry of codes.\n- Touch files: packages/core/src/pipeline/orchestrator.ts, packages/core/src/diag/*, packages/core/src/util/determinism.ts",
        "testStrategy": "Unit tests for RNG determinism and AJV parity; smoke test orchestrator with mismatched options.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement dual AJV instances with parity validation",
            "description": "Set up two AJV instances (planning vs original) with unicodeRegExp:true and enforce parity checking with AJV_OPTIONS_MISMATCH error handling.",
            "dependencies": [],
            "details": "Create dual AJV instance setup in orchestrator.ts with identical configuration options. Implement parity validation that compares configurations and throws AJV_OPTIONS_MISMATCH on mismatch. Both instances must have unicodeRegExp:true and identical settings to ensure consistent behavior between planning and validation phases.",
            "status": "pending",
            "testStrategy": "Unit tests for AJV instance creation, parity validation, and error throwing on configuration mismatches",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create xorshift32 deterministic RNG implementation",
            "description": "Implement xorshift32 random number generator seeded by (seed, canonPath) to eliminate global/time/locale dependencies.",
            "dependencies": [],
            "details": "Create packages/core/src/util/determinism.ts with xorshift32 algorithm implementation. RNG must be seeded using combination of user seed and canonical path to ensure deterministic output. Remove any dependencies on global state, system time, or locale settings to guarantee reproducible results across environments.",
            "status": "pending",
            "testStrategy": "Unit tests for RNG determinism - same seed produces identical sequences, different seeds produce different sequences",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Design diagnostic envelope system and code registry",
            "description": "Implement Diagnostic envelope structure with {code, canonPath, details} and create central registry for diagnostic codes.",
            "dependencies": [],
            "details": "Create packages/core/src/diag/ directory structure with diagnostic envelope type definitions and central code registry. Design extensible system for diagnostic codes including AJV_OPTIONS_MISMATCH and other core error types. Implement standardized format for diagnostic messages with canonical path tracking.",
            "status": "pending",
            "testStrategy": "Unit tests for diagnostic envelope creation, code registry lookup, and message formatting",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Integrate orchestrator with invariants and diagnostics",
            "description": "Update orchestrator.ts to incorporate dual AJV instances, deterministic RNG, and diagnostic reporting infrastructure.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Modify packages/core/src/pipeline/orchestrator.ts to integrate all foundational components. Connect dual AJV instances with parity checking, initialize deterministic RNG for reproducible behavior, and wire diagnostic reporting throughout the orchestration flow. Establish error handling patterns for the entire pipeline.",
            "status": "pending",
            "testStrategy": "Integration tests for orchestrator initialization, smoke tests with mismatched AJV options, end-to-end determinism validation",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement determinism utilities and validation",
            "description": "Create utility functions for deterministic behavior validation and thread safety verification across the system.",
            "dependencies": [
              2
            ],
            "details": "Extend packages/core/src/util/determinism.ts with utilities for validating deterministic behavior, seeding management, and thread safety checks. Implement helper functions for canonical path generation, seed derivation, and determinism testing. Ensure all utilities support the foundational invariants required by the pipeline.",
            "status": "pending",
            "testStrategy": "Unit tests for determinism utilities, thread safety validation, and canonical path generation consistency",
            "parentId": "undefined"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break down the foundational scaffolding into distinct components: AJV dual instance setup with parity validation, deterministic xorshift32 RNG implementation, comprehensive diagnostic envelope system with code registry, orchestrator integration, and determinism utilities. Consider error handling patterns and testing strategies for each component.",
        "updatedAt": "2025-11-15T19:04:23.631Z"
      },
      {
        "id": "2",
        "title": "Regex policy: anchored-safe check + complexity caps",
        "description": "Implement anchored-safe classification (^...$, no look-around/backrefs) and complexity cap (length + quantified groups).",
        "status": "done",
        "dependencies": [
          "1"
        ],
        "priority": "high",
        "details": "- Create transform/name-automata/regex.ts with parser/validator and complexity scoring.\n- Emit REGEX_COMPLEXITY_CAPPED or REGEX_COMPILE_ERROR when applicable.\n- Non-safe/capped patterns must be guards only (no proofs/automata).",
        "testStrategy": "Unit tests for valid/invalid patterns; cap thresholds; error diagnostics.",
        "subtasks": [
          {
            "id": 1,
            "title": "Create regex parser and validator foundation",
            "description": "Implement core regex parsing functionality to analyze pattern structure and extract components for safety classification.",
            "dependencies": [],
            "details": "Create transform/name-automata/regex.ts with RegexParser class that can parse regex patterns into AST nodes, identify anchors (^, $), detect lookaround assertions and backreferences. Include basic validation to catch malformed patterns and emit REGEX_COMPILE_ERROR diagnostics.",
            "status": "pending",
            "testStrategy": "Unit tests for valid/invalid regex parsing, malformed pattern detection, AST structure verification",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement anchored-safe classification logic",
            "description": "Build safety classification system to determine if regex patterns are anchored-safe according to project requirements.",
            "dependencies": [
              1
            ],
            "details": "Implement anchored-safe detection that verifies patterns start with ^ and end with $, contain no lookaround assertions (?=, ?!, ?<=, ?<!), and no backreferences (\\1, \\2, etc.). Create RegexClassifier class with isAnchoredSafe() method that returns boolean classification.",
            "status": "pending",
            "testStrategy": "Test cases for anchored patterns, unanchored patterns, lookaround detection, backref detection, edge cases",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Develop complexity scoring algorithm",
            "description": "Create complexity analysis system that scores regex patterns based on length and quantified groups to enforce caps.",
            "dependencies": [
              1
            ],
            "details": "Implement complexity scoring that calculates pattern complexity based on total length and number of quantified groups (+, *, {n,m}). Define complexity thresholds and create ComplexityScorer class with score() method. Emit REGEX_COMPLEXITY_CAPPED diagnostic when patterns exceed defined limits.",
            "status": "pending",
            "testStrategy": "Unit tests for complexity calculation, threshold enforcement, quantifier counting, cap emission",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Integrate regex policy with pattern utilities and guards",
            "description": "Connect regex classification system with existing pattern utilities and enforce guard-only policy for unsafe patterns.",
            "dependencies": [
              2,
              3
            ],
            "details": "Integrate RegexParser, RegexClassifier, and ComplexityScorer into existing pattern processing pipeline. Ensure non-safe or complexity-capped patterns are restricted to guards only with no proof/automata generation. Add integration points with name-automata system and diagnostic emission.",
            "status": "pending",
            "testStrategy": "Integration tests with existing pattern utilities, guard restriction verification, end-to-end pattern processing",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Implement regex classification system with pattern parsing, anchored-safe detection logic, complexity scoring algorithm, diagnostic emission for capped patterns, and integration with existing pattern utilities. Include comprehensive test coverage for edge cases in regex analysis.",
        "updatedAt": "2025-11-15T19:09:23.543Z"
      },
      {
        "id": "3",
        "title": "Implement Thompson NFA",
        "description": "Restricted-regex to NFA (Thompson) for anchored-safe patterns.",
        "status": "pending",
        "dependencies": [
          "2"
        ],
        "priority": "high",
        "details": "- File: transform/name-automata/nfa.ts.\n- Support classes, grouping, alternation, ?,*,+, bounded quantifiers; Unicode aware.\n- Keep memory predictable; expose NFA size for caps.",
        "testStrategy": "Unit tests for simple and bounded patterns; NFA size sanity checks.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement regex AST parser for Thompson patterns",
            "description": "Create a parser to convert restricted regex patterns into an Abstract Syntax Tree (AST) representation suitable for Thompson NFA construction.",
            "dependencies": [
              2
            ],
            "details": "Implement regex AST parsing in transform/name-automata/nfa.ts. Parse character classes, grouping, alternation, quantifiers (?, *, +, {n,m}), and basic atoms. Build AST nodes for each construct. Ensure Unicode awareness and validate against anchored-safe patterns from task 2. Handle parsing errors gracefully with appropriate diagnostics.",
            "status": "pending",
            "testStrategy": "Unit tests for parsing various regex constructs, error handling for invalid patterns, and AST structure validation",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement NFA state machine data structures",
            "description": "Design and implement the core NFA state machine representation with states, transitions, and epsilon transitions.",
            "dependencies": [
              1
            ],
            "details": "Create NFA state classes with unique IDs, transition maps for character ranges and epsilon moves. Implement state creation, linking, and traversal methods. Include start and accept state management. Ensure memory-efficient representation and provide state counting for complexity caps. Add debugging utilities for state visualization.",
            "status": "pending",
            "testStrategy": "Unit tests for state creation, transition management, and memory usage validation",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Thompson construction algorithms",
            "description": "Implement the core Thompson construction algorithms to convert AST nodes into NFA fragments and combine them.",
            "dependencies": [
              2
            ],
            "details": "Implement Thompson construction for each AST node type: character classes, concatenation, alternation, and quantifiers. Create NFA fragments with proper epsilon transitions. Handle Unicode character ranges correctly. Ensure construction preserves anchored semantics and maintains predictable memory usage.",
            "status": "pending",
            "testStrategy": "Unit tests for each construction algorithm, verification of NFA correctness against simple regex patterns",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement character class and Unicode handling",
            "description": "Implement comprehensive character class support with Unicode awareness for NFA transitions.",
            "dependencies": [
              3
            ],
            "details": "Create character range representation for NFA transitions. Support Unicode character classes including \\d, \\w, \\s and their negations. Handle Unicode code point ranges efficiently. Implement range merging and intersection operations. Ensure compatibility with AJV's Unicode handling.",
            "status": "pending",
            "testStrategy": "Unit tests for character class operations, Unicode range handling, and compatibility with AJV validation",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement quantifier support with bounded repetition",
            "description": "Add support for quantifiers including ?, *, +, and bounded quantifiers {n,m} with proper NFA construction.",
            "dependencies": [
              3
            ],
            "details": "Implement quantifier handling in Thompson construction. Create appropriate epsilon transition patterns for each quantifier type. Handle bounded quantifiers {n,m} with unrolling strategies. Ensure memory predictability for large bounds and implement caps when necessary. Include zero-width matching detection.",
            "status": "pending",
            "testStrategy": "Unit tests for all quantifier types, bounded quantifier edge cases, and memory usage validation",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Implement NFA size tracking and memory caps",
            "description": "Add NFA size measurement and memory predictability features with appropriate complexity caps.",
            "dependencies": [
              4,
              5
            ],
            "details": "Implement NFA size calculation based on state count and transition density. Add memory usage tracking during construction. Implement complexity caps that abort construction when limits are exceeded. Expose NFA size metrics for upstream caps decision-making. Include diagnostic emission for complexity-capped patterns.",
            "status": "pending",
            "testStrategy": "Unit tests for size calculation accuracy, memory cap enforcement, and diagnostic emission",
            "parentId": "undefined"
          }
        ],
        "complexity": 9,
        "recommendedSubtasks": 6,
        "expansionPrompt": "Build Thompson NFA construction with regex AST parsing, NFA state machine implementation, character class handling, quantifier support, Unicode awareness, and memory predictability measures. Include NFA size tracking and visualization utilities for debugging."
      },
      {
        "id": "4",
        "title": "DFA subset construction + caps",
        "description": "Determinize NFA under caps; expose reachability and accepting states.",
        "status": "pending",
        "dependencies": [
          "3"
        ],
        "priority": "high",
        "details": "- File: transform/name-automata/dfa.ts.\n- Subset construction with early-abort on cap; record states count.\n- Export membership check compatible with UTF-16 iteration.",
        "testStrategy": "Unit tests: language equivalence on small patterns; cap-trigger path returns diagnostic.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement subset construction algorithm core",
            "description": "Create the core subset construction algorithm to determinize NFAs by computing powerset states and transition functions.",
            "dependencies": [],
            "details": "Implement the classical subset construction algorithm that converts an NFA to DFA by: 1) Computing epsilon closures for state sets, 2) Building powerset states where each DFA state represents a set of NFA states, 3) Computing transitions between powerset states, 4) Tracking accepting states based on NFA accepting state membership. Handle edge cases like empty state sets and unreachable states.",
            "status": "pending",
            "testStrategy": "Unit tests with small NFAs to verify correct determinization and language equivalence",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add early-abort logic for complexity caps",
            "description": "Implement early termination when state explosion exceeds configured complexity caps to prevent exponential blowup.",
            "dependencies": [
              1
            ],
            "details": "Add state count tracking during subset construction and implement early-abort when maxDFAStates cap is reached. Emit NAME_AUTOMATON_COMPLEXITY_CAPPED diagnostic when terminating early. Maintain partial DFA construction state for debugging. Record final states count in metadata for observability.",
            "status": "pending",
            "testStrategy": "Unit tests that trigger caps with pathological patterns and verify diagnostic emission",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement UTF-16 compatible membership checking",
            "description": "Create efficient string membership testing that works correctly with JavaScript's UTF-16 string representation.",
            "dependencies": [
              1
            ],
            "details": "Implement DFA.accepts(string) method that iterates through UTF-16 code units correctly, handling surrogate pairs and Unicode normalization. Use state transition table for O(n) membership checking. Ensure compatibility with JavaScript string indexing and iteration patterns used in the generator.",
            "status": "pending",
            "testStrategy": "Unit tests with Unicode strings including surrogate pairs and emoji to verify correct acceptance",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement state minimization optimization",
            "description": "Add DFA minimization to reduce state count and improve performance by merging equivalent states.",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement Hopcroft's algorithm or table-filling method to minimize the DFA after construction. Merge states that have identical transition behavior and accepting status. Update transition table and state mappings accordingly. Only apply minimization if state count exceeds a threshold to avoid overhead on small automata.",
            "status": "pending",
            "testStrategy": "Unit tests verifying minimized DFA has same language acceptance with fewer states",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Create DFA module exports and integration",
            "description": "Expose the complete DFA interface with reachability analysis and accepting state information for composition engine integration.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Export DFA class with methods: accepts(string), getStateCount(), getAcceptingStates(), isReachable(state). Implement reachability analysis to identify dead states. Provide metadata about construction process including original NFA size, final DFA size, and whether caps were triggered. Integrate with name-automata module structure.",
            "status": "pending",
            "testStrategy": "Integration tests with composition engine and unit tests for all exported interfaces",
            "parentId": "undefined"
          }
        ],
        "complexity": 9,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Implement deterministic finite automaton subset construction with powerset state management, early-abort logic for complexity caps, UTF-16 compatible membership checking, state minimization, and performance optimization for large automata."
      },
      {
        "id": "5",
        "title": "Product/intersection DFA for AP:false conjuncts",
        "description": "Compose per-conjunct DFAs (properties, patternProperties, propertyNames-guard) into a product DFA.",
        "status": "pending",
        "dependencies": [
          "4"
        ],
        "priority": "high",
        "details": "- File: transform/name-automata/product.ts.\n- Build product only for conjuncts that enforce additionalProperties:false.\n- Reachability trimming to reduce state blow-up; apply maxProductStates; emit NAME_AUTOMATON_COMPLEXITY_CAPPED on cap.",
        "testStrategy": "Unit tests on 2–3 conjunct intersections; verify pruning and acceptance.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement DFA product construction algorithm",
            "description": "Create the core product construction algorithm that composes multiple DFAs into a single product DFA for additionalProperties:false conjuncts.",
            "dependencies": [],
            "details": "Implement the product construction in transform/name-automata/product.ts. Build cross-product of state spaces from input DFAs (properties, patternProperties, propertyNames-guard). Handle epsilon transitions and state labeling. Ensure the product DFA accepts only strings accepted by ALL input DFAs. Include proper error handling for malformed input DFAs.",
            "status": "pending",
            "testStrategy": "Unit tests with 2-3 simple DFAs, verify cartesian product states and acceptance conditions",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement state reachability analysis and pruning",
            "description": "Add reachability analysis to identify and remove unreachable states from the product DFA to prevent state explosion.",
            "dependencies": [
              1
            ],
            "details": "Implement breadth-first or depth-first traversal from initial state to mark reachable states. Remove unreachable states and their transitions. Update state numbering after pruning. Track pruning statistics for diagnostics. Ensure the pruned DFA maintains equivalent language acceptance.",
            "status": "pending",
            "testStrategy": "Test with DFAs that have unreachable states, verify pruning removes them without affecting language",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add state explosion prevention with maxProductStates cap",
            "description": "Implement state count monitoring and graceful degradation when the product DFA exceeds maxProductStates threshold.",
            "dependencies": [
              1,
              2
            ],
            "details": "Monitor state count during product construction. When maxProductStates threshold is reached, emit NAME_AUTOMATON_COMPLEXITY_CAPPED diagnostic and apply fallback strategy (conservative approximation or early termination). Ensure the capped result is still sound for additionalProperties:false enforcement, even if less precise.",
            "status": "pending",
            "testStrategy": "Test with complex patterns that would generate large state spaces, verify capping triggers and fallback behavior",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Integrate with additionalProperties:false semantics and comprehensive testing",
            "description": "Wire the product DFA construction into the additionalProperties:false validation logic and add comprehensive test coverage for multi-pattern scenarios.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Integrate product DFA with existing AP:false handling in composition engine. Ensure product DFA is only built for schemas that enforce additionalProperties:false. Add comprehensive test suite covering multiple conjunct scenarios, edge cases with complex pattern intersections, and validation that the product correctly rejects property names not accepted by all conjuncts.",
            "status": "pending",
            "testStrategy": "End-to-end tests with schemas having multiple patternProperties and properties under AP:false, verify correct acceptance/rejection",
            "parentId": "undefined"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Develop DFA product construction for conjunct intersection, state reachability analysis, pruning strategies for state explosion prevention, and integration with additionalProperties:false semantics. Include comprehensive testing for multi-pattern scenarios."
      },
      {
        "id": "6",
        "title": "Decide emptiness & finiteness",
        "description": "Add emptiness (reachability to any accepting state) and finiteness (cycle detection on co-accessible subgraph).",
        "status": "pending",
        "dependencies": [
          "5"
        ],
        "priority": "high",
        "details": "- Extend product.ts to compute emptiness/finite.\n- Expose summary: {states, finite, capsHit?}.",
        "testStrategy": "Unit tests: empty vs non-empty; finite vs infinite languages.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement reachability analysis for emptiness detection",
            "description": "Implement graph reachability algorithms to determine if any accepting states are reachable from the initial state in the DFA structure.",
            "dependencies": [],
            "details": "Add reachability analysis function in product.ts that performs BFS/DFS traversal from initial state to check if any accepting states can be reached. Return boolean indicating emptiness (true if no accepting states reachable). Include proper error handling for malformed automata.",
            "status": "pending",
            "testStrategy": "Unit tests with empty automata (no accepting states reachable) and non-empty automata (accepting states reachable)",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement cycle detection for finiteness determination",
            "description": "Add cycle detection algorithm on co-accessible subgraph to determine if the automaton accepts finite or infinite languages.",
            "dependencies": [
              1
            ],
            "details": "Implement cycle detection using DFS with back-edge detection on the co-accessible subgraph (states that can reach accepting states). If cycles exist in co-accessible states, language is infinite. Use proper graph coloring (white/gray/black) to detect back edges efficiently.",
            "status": "pending",
            "testStrategy": "Unit tests with finite languages (no cycles in co-accessible states) and infinite languages (cycles present)",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add summary generation and diagnostic reporting",
            "description": "Expose automaton properties through summary object containing states count, finiteness flag, and diagnostic information.",
            "dependencies": [
              1,
              2
            ],
            "details": "Extend product.ts to return summary object with format {states: number, finite: boolean, capsHit?: boolean}. Include state count from automaton, finiteness result from cycle detection, and optional caps hit indicator for complexity limits. Add proper TypeScript types and integration with existing diagnostic system.",
            "status": "pending",
            "testStrategy": "Integration tests verifying summary format and correctness of all fields across various automaton types",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Implement graph algorithms for emptiness detection through reachability analysis, finiteness determination via cycle detection, and co-accessible subgraph analysis. Add summary generation and diagnostic reporting for automaton properties."
      },
      {
        "id": "7",
        "title": "BFS witnesses (shortest then UTF‑16)",
        "description": "Enumerate minimal witness names using BFS with stable symbol order.",
        "status": "pending",
        "dependencies": [
          "6"
        ],
        "priority": "high",
        "details": "- File: transform/name-automata/bfs.ts.\n- Produce k shortest words; order by length then UTF-16 lexicographic.\n- Guard enumerate() exposure: only when finiteness proven and not solely from raw propertyNames.enum.",
        "testStrategy": "Acceptance test: enumerate two-letter/three-letter results as expected; order stable.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement core BFS enumeration algorithm",
            "description": "Create the breadth-first search algorithm that explores the automaton state space to find shortest paths to accepting states, producing minimal witness names.",
            "dependencies": [],
            "details": "Implement the core BFS traversal logic in transform/name-automata/bfs.ts. The algorithm should explore states level by level, tracking path lengths and accumulating symbol sequences. Include proper queue management and state visitation tracking to ensure complete exploration of the automaton's reachable accepting states.",
            "status": "pending",
            "testStrategy": "Unit tests for BFS traversal correctness, path finding accuracy, and proper queue behavior with various automaton structures.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement UTF-16 lexicographic ordering with length priority",
            "description": "Add stable ordering logic that sorts results first by string length (shortest first), then by UTF-16 lexicographic order for strings of equal length.",
            "dependencies": [
              1
            ],
            "details": "Create the ordering mechanism that processes BFS results and applies the dual-criteria sort: primary by length (ascending), secondary by UTF-16 code point comparison. This ensures deterministic, reproducible output across different runs and environments. Include proper handling of Unicode characters and edge cases in string comparison.",
            "status": "pending",
            "testStrategy": "Acceptance tests verifying two-letter and three-letter enumeration results match expected order, with stable sorting across multiple runs.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement finiteness guards and enumerate() exposure logic",
            "description": "Add guard logic that only exposes the enumerate() function when finiteness is proven and the result is not solely derived from raw propertyNames.enum values.",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement the safety mechanism that checks automaton finiteness before allowing enumeration exposure. The guard must verify that the language is finite (no infinite loops) and that the enumeration adds value beyond simple propertyNames.enum extraction. Include proper error handling and diagnostic messages when guards fail, ensuring the system degrades gracefully for unsafe cases.",
            "status": "pending",
            "testStrategy": "Unit tests for guard behavior with finite vs infinite automata, and integration tests ensuring enumerate() is only exposed when conditions are met.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Implement breadth-first enumeration algorithm with stable UTF-16 lexicographic ordering, shortest path finding for minimal witnesses, and guard logic for finiteness requirements. Include proper handling of edge cases and length constraints."
      },
      {
        "id": "8",
        "title": "Compose integration & CoverageIndex",
        "description": "Wire name automata into composition-engine and expose CoverageIndex API.",
        "status": "pending",
        "dependencies": [
          "5",
          "6",
          "7"
        ],
        "priority": "high",
        "details": "- Touch: packages/core/src/transform/composition-engine.ts.\n- For each object with AP:false across allOf: build DFAs for `properties` (literals) and `patternProperties` (anchored-safe).\n- `propertyNames`: guard-only; optional additive rewrite behind flag with PNAMES_REWRITE_APPLIED and synthetic provenance.\n- Expose coverageIndex.has(name) (pure) and enumerate?(k) when finite; include provenance and nameDfaSummary.",
        "testStrategy": "Acceptance: coverageIndex.has() correctness on literals/patterns; enumerate() present only when allowed.",
        "subtasks": [
          {
            "id": 1,
            "title": "Wire name automata into composition-engine.ts",
            "description": "Integrate the name automata system into the existing composition engine, establishing the core connection points and API surface.",
            "dependencies": [],
            "details": "Modify packages/core/src/transform/composition-engine.ts to import and integrate name automata functionality. Add necessary imports for DFA building, establish integration points for processing objects with AP:false, and set up the foundation for CoverageIndex API exposure.",
            "status": "pending",
            "testStrategy": "Unit tests for successful integration without breaking existing composition engine functionality",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Build DFAs for properties and patternProperties",
            "description": "Implement DFA construction for literal properties and anchored-safe pattern properties in objects with additionalProperties:false across allOf conjuncts.",
            "dependencies": [
              1
            ],
            "details": "For each object with AP:false across allOf conjuncts, build DFAs for properties (literals) and patternProperties (anchored-safe patterns). Implement the logic to traverse allOf structures, identify relevant properties, and construct appropriate DFAs using the name automata system from previous tasks.",
            "status": "pending",
            "testStrategy": "Unit tests verifying correct DFA construction for various property combinations and pattern types",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement propertyNames handling with rewrite flags",
            "description": "Add propertyNames support with guard-only behavior and optional additive rewrite behind feature flag with proper provenance tracking.",
            "dependencies": [
              2
            ],
            "details": "Implement propertyNames as guard-only by default. Add optional additive rewrite functionality behind PNAMES_REWRITE_APPLIED flag with synthetic provenance tracking. Ensure proper flag handling and provenance metadata for rewritten schemas.",
            "status": "pending",
            "testStrategy": "Unit tests for both guard-only and rewrite modes, verifying flag behavior and provenance tracking",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Expose CoverageIndex API with provenance",
            "description": "Design and implement the CoverageIndex API with has(name) method, optional enumerate(k) for finite cases, and comprehensive provenance tracking.",
            "dependencies": [
              3
            ],
            "details": "Expose coverageIndex.has(name) as a pure function for property name checking. Implement optional enumerate(k) method available only when finite enumeration is possible. Include provenance tracking and nameDfaSummary in the API. Ensure proper error handling and performance characteristics.",
            "status": "pending",
            "testStrategy": "Acceptance tests for coverageIndex.has() correctness on literals and patterns, enumerate() availability validation, and provenance accuracy",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Integrate name automata into composition engine with CoverageIndex API design, DFA building for properties and patterns, propertyNames handling with rewrite flags, and provenance tracking. Include comprehensive API testing and performance validation."
      },
      {
        "id": "9",
        "title": "Early-UNSAT diagnostics for objects",
        "description": "Emit object-level UNSAT: empty coverage under presence pressure; required vs propertyNames; minProperties vs finite coverage.",
        "status": "pending",
        "dependencies": [
          "8"
        ],
        "priority": "high",
        "details": "- Emit UNSAT_AP_FALSE_EMPTY_COVERAGE with proof summary.\n- Emit UNSAT_REQUIRED_VS_PROPERTYNAMES.\n- Emit UNSAT_MINPROPERTIES_VS_COVERAGE.",
        "testStrategy": "Acceptance tests per spec scenarios.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement UNSAT_AP_FALSE_EMPTY_COVERAGE diagnostic",
            "description": "Detect and emit diagnostics when additionalProperties:false creates empty coverage under presence pressure from required properties or minProperties constraints.",
            "dependencies": [],
            "details": "Add detection logic in composition-engine.ts to identify when AP:false combined with required properties results in impossible coverage. Emit UNSAT_AP_FALSE_EMPTY_COVERAGE diagnostic with proof summary including conflicting constraints and coverage analysis. Include provenance tracking for diagnostic context.",
            "status": "pending",
            "testStrategy": "Unit tests for various AP:false scenarios with required properties; edge cases with complex property patterns",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement UNSAT_REQUIRED_VS_PROPERTYNAMES diagnostic",
            "description": "Detect conflicts between required properties and propertyNames constraints that make object generation impossible.",
            "dependencies": [
              1
            ],
            "details": "Add logic to detect when required property names violate propertyNames constraints (enum, pattern, etc.). Emit UNSAT_REQUIRED_VS_PROPERTYNAMES diagnostic with detailed conflict analysis. Handle both literal and pattern-based propertyNames constraints with comprehensive proof generation.",
            "status": "pending",
            "testStrategy": "Acceptance tests covering required vs propertyNames.enum conflicts; pattern-based propertyNames violations",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement UNSAT_MINPROPERTIES_VS_COVERAGE diagnostic",
            "description": "Detect when minProperties requirement exceeds available property coverage, making object generation impossible.",
            "dependencies": [
              1,
              2
            ],
            "details": "Add detection for scenarios where minProperties value is greater than the finite set of allowed properties under coverage constraints. Emit UNSAT_MINPROPERTIES_VS_COVERAGE diagnostic with coverage analysis and property count calculations. Handle both finite and infinite coverage scenarios with appropriate proof summaries.",
            "status": "pending",
            "testStrategy": "Edge case tests with various minProperties values against finite property sets; boundary condition testing",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Implement UNSAT detection logic for empty coverage scenarios, required property conflicts, and minProperties violations. Add diagnostic code emission with detailed proof summaries and comprehensive test scenarios for edge cases."
      },
      {
        "id": "10",
        "title": "Strict/Lax policy for AP:false and external $ref",
        "description": "Implement strict fail-fast on unsafe/capped patterns under presence pressure; handle unresolved external $ref.",
        "status": "pending",
        "dependencies": [
          "8",
          "1"
        ],
        "priority": "high",
        "details": "- Strict: AP_FALSE_UNSAFE_PATTERN fatal after safe-only attempt.\n- Lax: same code as warn, conservative exclusion.\n- External $ref: Strict→EXTERNAL_REF_UNRESOLVED{mode:\"strict\"}; Lax→warn + skippedValidation:true only if cause is exclusively external refs.",
        "testStrategy": "Acceptance: strict vs lax behavior; unresolved refs paths.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement strict/lax policy enforcement framework",
            "description": "Create the core policy enforcement framework that handles strict vs lax mode switching and policy-specific error handling for unsafe patterns and external references.",
            "dependencies": [],
            "details": "Implement policy enumeration (strict/lax), policy context threading through composition engine, and policy-specific error emission logic. Create base classes for policy-aware error handling and mode-specific behavior switches. This forms the foundation for all policy-specific behaviors in subsequent subtasks.",
            "status": "pending",
            "testStrategy": "Unit tests for policy context creation, mode switching, and basic error emission patterns",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement AP:false unsafe pattern detection and handling",
            "description": "Implement detection and handling of unsafe additionalProperties:false patterns with different behaviors for strict vs lax modes.",
            "dependencies": [
              1
            ],
            "details": "Create unsafe pattern detection logic for AP:false scenarios under presence pressure. In strict mode: emit AP_FALSE_UNSAFE_PATTERN as fatal error after safe-only attempt fails. In lax mode: emit same diagnostic as warning and apply conservative exclusion logic. Integrate with composition engine's must-cover analysis.",
            "status": "pending",
            "testStrategy": "Acceptance tests comparing strict vs lax behavior on unsafe AP:false patterns; verify fatal vs warning emission",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement external $ref resolution policy handling",
            "description": "Implement policy-specific handling of unresolved external $ref with appropriate error emission and validation skipping logic.",
            "dependencies": [
              1
            ],
            "details": "Handle unresolved external $ref differently based on policy mode. Strict mode: emit EXTERNAL_REF_UNRESOLVED with mode:strict metadata. Lax mode: emit warning and set skippedValidation:true only when failure cause is exclusively due to external refs. Integrate with reference resolution pipeline and validator skip logic.",
            "status": "pending",
            "testStrategy": "Acceptance tests for external $ref resolution failure paths in both strict and lax modes; verify error vs warning emission and validation skipping behavior",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Implement policy enforcement for strict vs lax modes, external reference resolution handling, error emission for unsafe patterns, and conservative exclusion logic. Include comprehensive testing for different policy scenarios and reference resolution failures."
      },
      {
        "id": "11",
        "title": "Arrays: bagged contains + UNSAT rules",
        "description": "Model contains as bag; prove UNSAT when Σ(min_i) > maxItems; handle disjointness and overlap unknown.",
        "status": "pending",
        "dependencies": [
          "1"
        ],
        "priority": "high",
        "details": "- File: transform/arrays/contains-bag.ts.\n- Deterministic choice when uniqueItems:true.\n- Emit UNSAT_CONTAINS_VS_MAXITEMS when provable.",
        "testStrategy": "Acceptance: impossible contains vs maxItems; uniqueItems order stability.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement contains bag modeling core structure",
            "description": "Create the foundational contains-bag.ts file with core bag modeling logic for array contains constraints",
            "dependencies": [],
            "details": "Set up transform/arrays/contains-bag.ts with basic bag modeling structure. Implement the core contains constraint modeling that treats contains as a bag operation rather than exact matching. Include interfaces for bag constraint representation and basic validation logic.",
            "status": "pending",
            "testStrategy": "Unit tests for basic bag constraint modeling and interface validation",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement UNSAT proof generation for contains vs maxItems",
            "description": "Add logic to detect and prove UNSAT conditions when sum of minimum items exceeds maxItems constraint",
            "dependencies": [
              1
            ],
            "details": "Implement the mathematical proof logic that detects when Σ(min_i) > maxItems, making the schema unsatisfiable. Emit UNSAT_CONTAINS_VS_MAXITEMS diagnostic when this condition is provably true. Include sum calculation and constraint violation detection.",
            "status": "pending",
            "testStrategy": "Unit tests with various min/max combinations that trigger UNSAT conditions",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add deterministic choice algorithm for uniqueItems",
            "description": "Implement deterministic selection logic when uniqueItems is true to ensure consistent bag item generation",
            "dependencies": [
              1
            ],
            "details": "Create deterministic choice algorithms that handle uniqueItems:true constraint in combination with contains bag modeling. Ensure that when uniqueItems is enabled, the bag generation produces consistent, deterministic results while respecting the contains constraints.",
            "status": "pending",
            "testStrategy": "Unit tests for uniqueItems stability and deterministic output with fixed seeds",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement disjointness and overlap analysis",
            "description": "Add logic to handle disjoint contains constraints and cases where constraint overlap is unknown",
            "dependencies": [
              2,
              3
            ],
            "details": "Implement analysis for disjoint contains constraints and handle scenarios where overlap between different contains constraints cannot be determined. Include logic for constraint intersection analysis and fallback behavior when disjointness cannot be proven.",
            "status": "pending",
            "testStrategy": "Acceptance tests for complex array constraint scenarios with overlapping and disjoint contains rules",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Implement contains bag modeling with deterministic choice algorithms, UNSAT proof generation for impossible constraints, disjointness analysis, and uniqueItems handling. Include comprehensive testing for complex array constraint scenarios."
      },
      {
        "id": "12",
        "title": "Numbers: bounds & rational multipleOf",
        "description": "Implement bound contradictions and rational multipleOf consistent with AJV.",
        "status": "pending",
        "dependencies": [
          "1"
        ],
        "priority": "medium",
        "details": "- Files: transform/numbers/bounds.ts, transform/numbers/multiple-of.ts.\n- Exact rational snapping consistent with AJV.\n- Diagnostics on contradictions.",
        "testStrategy": "Unit + acceptance on mixed inclusive/exclusive bounds and multipleOf.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement bounds contradiction detection",
            "description": "Create bounds checking logic that detects contradictory minimum/maximum constraints and emits appropriate diagnostics when bounds are impossible to satisfy.",
            "dependencies": [],
            "details": "Implement in transform/numbers/bounds.ts: Check for contradictory bounds (min > max), handle inclusive/exclusive boundaries, detect empty ranges, and emit BOUNDS_CONTRADICTION diagnostic. Include edge cases like Number.MAX_SAFE_INTEGER and floating-point precision limits.",
            "status": "pending",
            "testStrategy": "Unit tests for contradictory bounds, edge cases with inclusive/exclusive combinations, and diagnostic emission",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement rational multipleOf arithmetic",
            "description": "Create exact rational arithmetic for multipleOf constraints that maintains precision and consistency with AJV validation behavior.",
            "dependencies": [],
            "details": "Implement in transform/numbers/multiple-of.ts: Use rational number representation to avoid floating-point precision errors. Implement exact division checks, GCD calculations for multiple multipleOf constraints, and maintain consistency with AJV's multipleOf validation algorithm.",
            "status": "pending",
            "testStrategy": "Unit tests for rational arithmetic precision, multiple multipleOf constraints, and AJV consistency verification",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement precise snapping algorithms",
            "description": "Create number snapping logic that adjusts generated values to satisfy multipleOf constraints while respecting bounds, with exact precision matching AJV behavior.",
            "dependencies": [
              1,
              2
            ],
            "details": "Combine bounds and multipleOf logic to snap generated numbers to valid values. Handle edge cases where snapping might violate bounds, implement bidirectional snapping (up/down), and ensure exact consistency with AJV's validation results. Include handling for very large numbers and precision limits.",
            "status": "pending",
            "testStrategy": "Integration tests combining bounds and multipleOf, floating-point edge cases, and AJV consistency validation",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add comprehensive floating-point edge case testing",
            "description": "Create comprehensive test suite covering floating-point precision edge cases, boundary conditions, and numerical corner cases for bounds and multipleOf implementation.",
            "dependencies": [
              3
            ],
            "details": "Implement test cases for: Number.EPSILON precision issues, very large/small numbers near limits, floating-point representation edge cases, subnormal numbers, infinity handling, and NaN edge cases. Include property-based testing for numerical stability and AJV consistency across the full range of valid inputs.",
            "status": "pending",
            "testStrategy": "Property-based tests for numerical stability, edge case regression tests, and comprehensive AJV consistency validation",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Implement numerical bound checking with rational arithmetic, multipleOf consistency with AJV, contradiction detection, and precise snapping algorithms. Include comprehensive testing for floating-point edge cases and boundary conditions."
      },
      {
        "id": "13",
        "title": "Optional local SMT (QF_LIA) stub with timeout",
        "description": "Feature-flagged local solver to assist arrays/numbers; strict timeout with SOLVER_TIMEOUT fallback.",
        "status": "pending",
        "dependencies": [
          "11",
          "12"
        ],
        "priority": "low",
        "details": "- File: transform/smt/solver.ts (WASM-capable interface).\n- Flag: enableLocalSMT + solverTimeoutMs.\n- On timeout/unknown: emit SOLVER_TIMEOUT and fall back to rules.",
        "testStrategy": "Unit: inject fake timeout; ensure graceful fallback and diagnostics.",
        "subtasks": [
          {
            "id": 1,
            "title": "Design SMT solver interface with WASM compatibility",
            "description": "Create the core SMT solver interface in transform/smt/solver.ts with WASM-capable design and proper typing for QF_LIA queries.",
            "dependencies": [],
            "details": "Implement the base SMT solver interface with methods for QF_LIA query solving, WASM module loading capabilities, and proper TypeScript interfaces. Include solver state management, query encoding/decoding, and result handling. Design should be extensible for future solver backends while maintaining type safety.",
            "status": "pending",
            "testStrategy": "Unit tests with mock WASM module and interface validation",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement timeout handling with graceful fallback",
            "description": "Add timeout mechanism with solverTimeoutMs configuration and graceful fallback to rule-based generation when timeout occurs.",
            "dependencies": [
              1
            ],
            "details": "Implement timeout wrapper around SMT solver calls using Promise.race or AbortController. On timeout or solver failure, emit SOLVER_TIMEOUT diagnostic and fall back to existing rule-based generation. Ensure clean resource cleanup and proper error propagation. Handle both synchronous timeouts and asynchronous solver failures.",
            "status": "pending",
            "testStrategy": "Unit tests with artificial timeout injection and fallback verification",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Integrate feature flag and solver configuration",
            "description": "Add enableLocalSMT feature flag integration and solver configuration options to the generation pipeline.",
            "dependencies": [
              1,
              2
            ],
            "details": "Integrate the SMT solver into the composition engine with enableLocalSMT feature flag control. Add solverTimeoutMs to PlanOptions configuration. Wire solver calls into array and number constraint checking during composition phase. Ensure solver is only invoked when flag is enabled and gracefully degrades when disabled or unavailable.",
            "status": "pending",
            "testStrategy": "Integration tests with flag enabled/disabled scenarios and mock solver implementations",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Design SMT solver interface with WASM compatibility, timeout handling with graceful fallback, feature flag integration, and solver-timeout diagnostic emission. Include mock implementations for testing and integration patterns."
      },
      {
        "id": "14",
        "title": "Generator integration with CoverageIndex",
        "description": "Use CoverageIndex to pick names; minimal value witnesses; arrays satisfy contains then uniqueItems.",
        "status": "pending",
        "dependencies": [
          "8",
          "11",
          "12"
        ],
        "priority": "high",
        "details": "- Touch: packages/core/src/generator/foundry-generator.ts.\n- Deterministic ordering; if-aware-lite preserved.\n- Respect enum/const precedence vs broad type.",
        "testStrategy": "Pipeline tests: stable outputs across runs with same seed; coverageIndex used.",
        "subtasks": [
          {
            "id": 1,
            "title": "Integrate CoverageIndex into FoundryGenerator for deterministic name selection",
            "description": "Modify foundry-generator.ts to use CoverageIndex for picking property names in object generation, ensuring deterministic ordering and maintaining if-aware-lite behavior.",
            "dependencies": [],
            "details": "Update the object property generation logic in foundry-generator.ts to call coverageIndex.has(name) and enumerate() methods from the composition engine. Ensure the generator respects the deterministic ordering from CoverageIndex and preserves if-aware-lite conditional handling. Replace any existing name selection logic with CoverageIndex-driven approach.",
            "status": "pending",
            "testStrategy": "Unit tests for deterministic name selection with fixed seeds; verify same names generated across runs",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement minimal value witness generation strategy",
            "description": "Add logic to generate minimal value witnesses that satisfy schema constraints while maintaining deterministic behavior and enum/const precedence.",
            "dependencies": [
              1
            ],
            "details": "Implement witness generation that produces minimal valid values for schema validation. Ensure enum and const values take precedence over broader type constraints. The witness generation should work with the CoverageIndex integration and maintain deterministic output with seeded randomness.",
            "status": "pending",
            "testStrategy": "Unit tests for minimal witness generation; verify enum/const precedence over type constraints",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement array constraint satisfaction for contains and uniqueItems",
            "description": "Add array generation logic that first satisfies contains constraints then applies uniqueItems deduplication, working with the bagged contains model from task 11.",
            "dependencies": [
              2
            ],
            "details": "Integrate with the bagged contains logic from contains-bag.ts to generate arrays that satisfy contains requirements first, then apply uniqueItems deduplication. Ensure the generation respects maxItems limits and handles UNSAT conditions when Σ(min_i) > maxItems. Maintain deterministic ordering when uniqueItems is true.",
            "status": "pending",
            "testStrategy": "Integration tests with contains-bag.ts; verify contains satisfaction before uniqueItems application",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add comprehensive pipeline tests for generator integration",
            "description": "Create end-to-end pipeline tests that verify stable outputs across runs with same seed, proper CoverageIndex usage, and integration with composition engine.",
            "dependencies": [
              3
            ],
            "details": "Implement pipeline tests that validate the complete generator integration with CoverageIndex. Tests should verify deterministic outputs with fixed seeds, proper name selection through CoverageIndex, minimal witness generation, and array constraint satisfaction. Include tests for enum/const precedence and if-aware-lite preservation.",
            "status": "pending",
            "testStrategy": "Pipeline integration tests; snapshot testing for deterministic output verification; cross-run stability tests",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Integrate CoverageIndex into generator for deterministic name selection, minimal witness generation, array constraint satisfaction, and enum/const precedence handling. Include if-aware-lite preservation and comprehensive pipeline testing."
      },
      {
        "id": "15",
        "title": "Repair engine consistency & stagnation guard",
        "description": "Ensure AJV-driven repairs remain idempotent and bounded; keep stagnation guard behavior.",
        "status": "pending",
        "dependencies": [
          "14"
        ],
        "priority": "medium",
        "details": "- Touch: packages/core/src/repair/repair-engine.ts.\n- Typical fixes: bounds clamp, add required, rational snap, uniqueItems dedupe.\n- Stop when errors no longer reduce (bailOnUnsatAfter).",
        "testStrategy": "Integration test: repair reduces AJV errors; stops when no progress.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement repair engine core with idempotency guarantees",
            "description": "Build the foundational repair engine structure with idempotency tracking and convergence detection mechanisms.",
            "dependencies": [],
            "details": "Implement RepairEngine class in packages/core/src/repair/repair-engine.ts with idempotent repair operations. Track applied repairs to prevent duplicate applications. Include convergence detection by monitoring error reduction between iterations. Implement bailOnUnsatAfter logic to prevent infinite loops when repairs fail to reduce errors.",
            "status": "pending",
            "testStrategy": "Unit tests for idempotency - verify same repair applied twice produces identical results. Test convergence detection with mock AJV errors that stabilize after N iterations.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement AJV-driven repair actions for common schema violations",
            "description": "Add specific repair actions for bounds clamping, required property addition, rational snapping, and uniqueItems deduplication.",
            "dependencies": [
              1
            ],
            "details": "Implement repair actions in repair-engine.ts: bounds clamp for numbers exceeding min/max, add missing required properties with appropriate defaults, rational multipleOf snapping for precise alignment, and uniqueItems array deduplication. Each action should be AJV-driven based on validation error keywords and maintain idempotency.",
            "status": "pending",
            "testStrategy": "Integration tests with real AJV validation errors. Verify each repair action resolves its target error type. Test that repairs don't introduce new violations or break existing valid properties.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add stagnation guard and bounded iteration logic",
            "description": "Implement stagnation detection to prevent infinite repair loops and enforce iteration bounds with proper diagnostics.",
            "dependencies": [
              1,
              2
            ],
            "details": "Add stagnation guard that monitors error count reduction across repair iterations. Stop repairs when errors no longer decrease for configurable attempts (bailOnUnsatAfter). Implement bounded iteration with maximum repair passes. Emit diagnostics when stagnation is detected or iteration limits are reached. Ensure graceful degradation when repairs cannot converge.",
            "status": "pending",
            "testStrategy": "Integration tests for stagnation scenarios - schemas where repairs cannot reduce all errors. Verify proper stopping behavior and diagnostic emission. Test edge cases where repair actions conflict or create cycles.",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Enhance repair engine with idempotency guarantees, stagnation detection and prevention, AJV-driven repair consistency, and bounded iteration logic. Include comprehensive testing for repair convergence and edge cases."
      },
      {
        "id": "16",
        "title": "Validate stage: enforce AJV parity & metrics",
        "description": "Final validation on original schema; enforce AJV parity; collect per-phase metrics.",
        "status": "pending",
        "dependencies": [
          "1",
          "14",
          "15"
        ],
        "priority": "high",
        "details": "- Orchestrator validates only against the original schema.\n- Record normalizeMs/composeMs/generateMs/repairMs/validateMs, validationsPerRow, repairPassesPerRow, cap hits.",
        "testStrategy": "E2E test: failing parity triggers AJV_OPTIONS_MISMATCH; metrics are present.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement AJV validation orchestration against original schema",
            "description": "Set up final validation stage that validates generated data against the original schema using AJV, ensuring parity between planning and original instances",
            "dependencies": [],
            "details": "Create validate.ts module with AJV orchestration that validates against original schema. Implement parity enforcement between planning and original AJV instances. Ensure validation uses original schema not transformed/normalized version. Handle validation errors and provide detailed error reporting with canonical paths.",
            "status": "pending",
            "testStrategy": "Unit tests for validation success/failure cases, parity enforcement triggers AJV_OPTIONS_MISMATCH error",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement comprehensive metrics collection across pipeline phases",
            "description": "Add timing and performance metrics collection for all pipeline stages with detailed tracking of validation counts and repair passes",
            "dependencies": [
              1
            ],
            "details": "Implement metrics collection for normalizeMs, composeMs, generateMs, repairMs, validateMs timing. Track validationsPerRow and repairPassesPerRow counters. Record complexity cap hits and performance bottlenecks. Create metrics aggregation and reporting utilities with structured output format.",
            "status": "pending",
            "testStrategy": "Verify all metrics are captured correctly, performance tracking accuracy, metrics presence validation",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Integrate validation stage with orchestrator and error handling",
            "description": "Connect validation stage to main pipeline orchestrator with proper error handling, metrics integration, and comprehensive reporting",
            "dependencies": [
              1,
              2
            ],
            "details": "Integrate validate stage into orchestrator.ts pipeline flow. Implement error handling for validation failures with detailed diagnostics. Connect metrics collection to orchestrator execution. Ensure proper cleanup and resource management. Add validation stage configuration options and failure mode handling.",
            "status": "pending",
            "testStrategy": "E2E tests ensuring validation stage integration, error propagation, metrics collection in full pipeline execution",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Implement final validation stage with AJV parity enforcement, comprehensive metrics collection across all pipeline phases, validation against original schema, and performance tracking. Include detailed error reporting and metrics visualization."
      },
      {
        "id": "17",
        "title": "CLI flags & OpenAPI driver (prefer-examples, NDJSON)",
        "description": "Expose CLI flags and minimal OpenAPI driver hooks for mocks/tests.",
        "status": "pending",
        "dependencies": [
          "14",
          "16"
        ],
        "priority": "medium",
        "details": "- CLI: json-gen schema.json --mode strict --seed 123 --prefer-examples --n 10 --out ndjson.\n- Driver: select content/schema; prefer example/examples.default; export NDJSON; no network I/O in core.\n- Thin adapters MSW/Prism out of core.",
        "testStrategy": "Manual smoke + unit for flag parsing; fixture generation snapshot.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement CLI flag parsing with comprehensive options",
            "description": "Add command-line argument parsing for all required flags including mode, seed, prefer-examples, count, and output format options.",
            "dependencies": [],
            "details": "Extend packages/cli/ to parse flags: --mode strict, --seed 123, --prefer-examples, --n 10, --out ndjson. Use Commander.js for consistent CLI interface. Validate flag combinations and provide helpful error messages. Integrate with existing CLI structure from tasks 14 and 16.",
            "status": "pending",
            "testStrategy": "Unit tests for flag parsing validation and error handling. Manual smoke tests for CLI usability.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Develop OpenAPI driver for schema selection and example preference",
            "description": "Create minimal OpenAPI driver that can select content/schema from OpenAPI specs and prefer examples over generated data when available.",
            "dependencies": [
              1
            ],
            "details": "Build driver in packages/core/src/ that parses OpenAPI specs, extracts schemas from content types, and prioritizes example/examples.default over generated data. No network I/O in core - handle local spec files only. Export clean API for schema selection and example extraction.",
            "status": "pending",
            "testStrategy": "Fixture-based tests with sample OpenAPI specs. Verify schema extraction and example preference logic.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement NDJSON output formatting and integration",
            "description": "Add NDJSON (newline-delimited JSON) output format support and integrate all components into working CLI command.",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement NDJSON formatter that outputs one JSON object per line. Integrate CLI flags, OpenAPI driver, and output formatting into cohesive command: json-gen schema.json --mode strict --seed 123 --prefer-examples --n 10 --out ndjson. Ensure proper error handling and validation throughout the pipeline.",
            "status": "pending",
            "testStrategy": "End-to-end integration tests with real OpenAPI specs. Snapshot tests for NDJSON output format consistency.",
            "parentId": "undefined"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Implement CLI flag parsing with comprehensive options, OpenAPI driver integration for schema selection, NDJSON output formatting, and example preference handling. Include command-line interface testing and integration with existing CLI structure."
      },
      {
        "id": "18",
        "title": "Acceptance tests: objects automata",
        "description": "DFA emptiness; BFS witnesses; strict unsafe pattern; required vs propertyNames; minProperties vs coverage.",
        "status": "pending",
        "dependencies": [
          "8",
          "9",
          "10"
        ],
        "priority": "high",
        "details": "- Files under: packages/core/src/transform/__tests__/name-automata and tests/acceptance.\n- Recreate scenarios from the spec.",
        "testStrategy": "Run acceptance suite; assert codes and witness order.",
        "subtasks": [
          {
            "id": 1,
            "title": "Create DFA emptiness and BFS witness test fixtures",
            "description": "Implement test fixtures for DFA emptiness scenarios and BFS witness validation covering various schema complexity levels.",
            "dependencies": [],
            "details": "Create comprehensive test fixtures under packages/core/src/transform/__tests__/name-automata/ that cover DFA emptiness detection, BFS witness generation, and validation scenarios. Include schemas with empty languages, finite languages, and infinite languages. Fixtures should test reachability to accepting states and proper witness ordering.",
            "status": "pending",
            "testStrategy": "Unit tests for each fixture with expected emptiness results and witness validation",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement strict unsafe pattern enforcement tests",
            "description": "Create acceptance tests for strict pattern enforcement under presence pressure with AP:false scenarios.",
            "dependencies": [
              1
            ],
            "details": "Develop test suite covering strict unsafe pattern detection and enforcement. Include scenarios with additionalProperties:false under presence pressure, testing both strict fail-fast behavior and lax warning modes. Verify proper diagnostic code emission (AP_FALSE_UNSAFE_PATTERN) and conservative exclusion behavior.",
            "status": "pending",
            "testStrategy": "Acceptance tests comparing strict vs lax behavior with diagnostic code assertions",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Test required vs propertyNames conflict detection",
            "description": "Implement comprehensive tests for required properties vs propertyNames conflicts and resolution strategies.",
            "dependencies": [
              1
            ],
            "details": "Create test scenarios covering conflicts between required properties and propertyNames constraints. Include edge cases where required properties cannot satisfy propertyNames patterns, testing UNSAT_REQUIRED_VS_PROPERTYNAMES diagnostic emission. Verify proper conflict detection and resolution in both strict and lax modes.",
            "status": "pending",
            "testStrategy": "Acceptance tests with proof summary validation and diagnostic code verification",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Test minProperties vs coverage validation",
            "description": "Implement acceptance tests for minProperties constraints against finite property coverage scenarios.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Develop comprehensive test suite for minProperties validation against finite property coverage. Include scenarios where minProperties cannot be satisfied due to limited property coverage, testing UNSAT_MINPROPERTIES_VS_COVERAGE diagnostic emission. Verify proper handling of edge cases and boundary conditions in coverage calculation.",
            "status": "pending",
            "testStrategy": "Run full acceptance suite with assertions on diagnostic codes and witness order validation",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Create comprehensive acceptance test suite for DFA emptiness scenarios, BFS witness validation, strict pattern enforcement testing, and property conflict detection. Include test fixtures for complex schema scenarios and automated verification of diagnostic codes."
      },
      {
        "id": "19",
        "title": "Acceptance tests: arrays, refs, determinism",
        "description": "Contains vs maxItems; external $ref strict/lax; determinism with fixed seed.",
        "status": "pending",
        "dependencies": [
          "11",
          "10",
          "16"
        ],
        "priority": "high",
        "details": "- Arrays impossible contains; unresolved refs behavior; stable outputs same seed.",
        "testStrategy": "tests/acceptance + pipeline integration; snapshot outputs across runs.",
        "subtasks": [
          {
            "id": 1,
            "title": "Array contains vs maxItems acceptance tests",
            "description": "Create acceptance tests for array constraint violations where contains requirements conflict with maxItems limits, including impossible contains scenarios and UNSAT detection.",
            "dependencies": [
              11
            ],
            "details": "Implement tests in tests/acceptance/arrays/ covering: impossible contains vs maxItems scenarios, bag semantics validation, UNSAT_CONTAINS_VS_MAXITEMS diagnostic emission, uniqueItems ordering stability, and edge cases with multiple contains constraints against array size limits.",
            "status": "pending",
            "testStrategy": "Snapshot testing for diagnostic codes and error messages; verify UNSAT detection accuracy",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "External reference policy acceptance tests",
            "description": "Develop comprehensive acceptance tests for external $ref handling in both strict and lax modes, validating error behavior, fallback mechanisms, and diagnostic emission.",
            "dependencies": [
              10,
              16
            ],
            "details": "Create test suite in tests/acceptance/refs/ covering: strict mode external $ref errors, lax mode fallback behavior, diagnostic emission for unresolved references, $dynamicRef preservation, and edge cases with nested external references across different policy configurations.",
            "status": "pending",
            "testStrategy": "Policy configuration matrix testing; error code validation and fallback behavior verification",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Deterministic output validation with seed testing",
            "description": "Implement determinism acceptance tests ensuring identical outputs for fixed seeds across multiple runs, including snapshot testing for output stability validation.",
            "dependencies": [],
            "details": "Build determinism test suite in tests/acceptance/determinism/ covering: fixed seed reproducibility across runs, snapshot testing for output stability, branch selection consistency, RNG state validation, and cross-platform determinism verification with comprehensive edge case coverage.",
            "status": "pending",
            "testStrategy": "Snapshot testing with fixed seeds; multi-run output comparison; cross-platform validation",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Develop acceptance tests for array constraint violations, external reference policy behavior, and deterministic output validation. Include snapshot testing for output stability and comprehensive coverage of edge cases."
      },
      {
        "id": "20",
        "title": "Unit tests: regex/NFA/DFA/product/coverage-index/numbers",
        "description": "Granular unit tests for policy and automata plumbing, and multipleOf behavior.",
        "status": "pending",
        "dependencies": [
          "2",
          "3",
          "4",
          "5",
          "7",
          "12"
        ],
        "priority": "medium",
        "details": "- regex-policy.spec.ts, nfa-dfa-basic.spec.ts, product-finiteness.spec.ts, coverage-index.enumerate-guard.spec.ts, numbers.multiple-of.spec.ts.",
        "testStrategy": "All unit suites must pass; CI green.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement regex-policy.spec.ts unit test suite",
            "description": "Create comprehensive unit tests for regex policy validation including pattern compilation, validation logic, and error handling.",
            "dependencies": [
              1
            ],
            "details": "Implement test suite covering regex pattern validation, policy enforcement, edge cases with special characters, Unicode handling, and performance benchmarks for pattern matching. Test both valid and invalid regex patterns, boundary conditions, and integration with JSON Schema regex requirements.",
            "status": "pending",
            "testStrategy": "Unit tests with edge case coverage, performance benchmarks, and regex pattern validation",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement nfa-dfa-basic.spec.ts algorithmic correctness tests",
            "description": "Create unit tests for NFA/DFA construction algorithms, state transitions, and automaton correctness verification.",
            "dependencies": [
              1
            ],
            "details": "Test NFA construction from regex patterns, DFA conversion algorithms, state minimization, epsilon transitions, acceptance states, and deterministic behavior. Include tests for automaton equivalence, reachability analysis, and state space optimization.",
            "status": "pending",
            "testStrategy": "Algorithmic correctness verification with state machine testing and automaton theory validation",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement product-finiteness.spec.ts for product automaton testing",
            "description": "Create unit tests for product DFA construction, intersection correctness, and finiteness analysis.",
            "dependencies": [
              5
            ],
            "details": "Test product automaton construction from multiple DFAs, intersection semantics, state explosion handling, reachability trimming, and maxProductStates cap enforcement. Verify NAME_AUTOMATON_COMPLEXITY_CAPPED diagnostic emission and product correctness.",
            "status": "pending",
            "testStrategy": "Product automaton correctness with intersection testing and complexity cap validation",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement coverage-index.enumerate-guard.spec.ts functionality tests",
            "description": "Create unit tests for coverage index enumeration, guard conditions, and deterministic name selection.",
            "dependencies": [
              1,
              12
            ],
            "details": "Test CoverageIndex enumeration logic, guard condition evaluation, deterministic ordering, name selection algorithms, and integration with generator. Verify stable outputs, coverage completeness, and proper guard enforcement for property name generation.",
            "status": "pending",
            "testStrategy": "Coverage index functionality with deterministic testing and enumeration validation",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement numbers.multiple-of.spec.ts rational arithmetic tests",
            "description": "Create unit tests for rational multipleOf operations, bound contradictions, and AJV consistency.",
            "dependencies": [
              12
            ],
            "details": "Test exact rational snapping, multipleOf arithmetic consistency with AJV, bound contradiction detection, mixed inclusive/exclusive bounds, decimal precision handling, and diagnostic emission for contradictory constraints. Verify numerical stability and edge cases.",
            "status": "pending",
            "testStrategy": "Rational arithmetic testing with AJV consistency verification and numerical precision validation",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Integration and CI pipeline validation for all test suites",
            "description": "Ensure all unit test suites integrate properly with CI pipeline and maintain green status.",
            "dependencies": [
              1,
              2,
              3,
              4,
              5
            ],
            "details": "Configure CI pipeline integration for all test suites, establish test coverage thresholds, performance benchmarks, and ensure all tests pass consistently. Set up proper test reporting, failure diagnostics, and maintain CI green status as required by test strategy.",
            "status": "pending",
            "testStrategy": "CI integration with coverage thresholds and performance benchmarks to ensure all unit suites pass",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 6,
        "expansionPrompt": "Create granular unit test suites for regex policy validation, NFA/DFA construction algorithms, product automaton correctness, coverage index functionality, and numerical operations. Include edge case testing, performance benchmarks, and algorithmic correctness verification."
      },
      {
        "id": "21",
        "title": "JSG-P1 Preparation: Requirements Analysis and Structured TODO",
        "description": "Comprehensive analysis of jsg-p1-automata-smt.md document to extract normative requirements and create structured implementation roadmap by pipeline phases.",
        "details": "[Context]\n\n**Must read**: docs/jsg-p1-automata-smt.md — Complete document analysis (324 lines)\n\n**Objective**: Extract all normative requirements (MUST, MUST NOT, SHALL, MAY) from the JSG-P1 specification and structure them by the 5-stage pipeline: Normalize → Compose → Generate → Repair → Validate.\n\n[Implementation Steps]\n\n1. **Full Document Analysis** (0-324 lines)\n   - Identify all normative language (MUST, MUST NOT, SHALL, MAY per RFC-2119)\n   - Extract technical requirements for each system component\n   - Map requirements to pipeline stages and cross-cutting concerns\n\n2. **Name Automata Requirements** (§4.3)\n   - DFA construction rules for `additionalProperties:false`\n   - Product automaton intersection logic\n   - Finiteness detection and BFS enumeration\n   - Early-UNSAT proof conditions\n   - Complexity caps and fallback behaviors\n\n3. **Arrays/Numbers Requirements** (§4.5)\n   - Contains bag semantics and UNSAT rules\n   - Rational multipleOf handling\n   - Optional local SMT solver integration\n   - Timeout and fallback strategies\n\n4. **AJV Oracle Requirements** (§0, §4.7)\n   - Original schema validation invariants\n   - AJV options parity enforcement\n   - Error handling for validation mismatches\n\n5. **Diagnostics Requirements** (§5)\n   - Error envelope format: {code, canonPath, details}\n   - Specific error codes and their conditions\n   - CoverageIndex API specifications\n   - Metrics collection requirements\n\n6. **CLI/OpenAPI Interface Requirements** (§7)\n   - Command-line flag specifications\n   - NDJSON output format\n   - Example preference handling\n   - Driver adapter requirements\n\n[Deliverable Structure]\n\n```\n.taskmaster/docs/jsg-p1-requirements-analysis.md\n├── Executive Summary\n├── Pipeline Phase Requirements\n│   ├── Stage 1: Normalize\n│   ├── Stage 2: Compose  \n│   ├── Stage 3: Generate\n│   ├── Stage 4: Repair\n│   └── Stage 5: Validate\n├── Cross-Cutting Requirements\n│   ├── Determinism\n│   ├── Performance SLOs\n│   ├── Error Handling\n│   └── Observability\n├── Implementation Priority Matrix\n└── Task Dependencies Analysis\n```\n\nThis analysis will serve as the foundational document for implementing tasks 1-20, ensuring comprehensive coverage of all JSG-P1 requirements with proper sequencing and dependency management.",
        "testStrategy": "1. **Completeness Verification**: Cross-reference extracted requirements against original document to ensure 100% normative language coverage. 2. **Pipeline Mapping**: Verify all requirements are properly categorized by pipeline stage with clear implementation guidance. 3. **Dependency Analysis**: Confirm task sequence 1-20 aligns with requirement dependencies identified in analysis. 4. **Requirements Traceability**: Each requirement must map to specific implementation tasks with acceptance criteria. 5. **Stakeholder Review**: Requirements document should enable clear task scoping and implementation planning for subsequent JSG-P1 tasks.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2025-11-15T18:59:42.074Z"
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-11-15T19:09:23.545Z",
      "taskCount": 21,
      "completedCount": 3,
      "tags": [
        "jsg-p1-automata-smt"
      ]
    }
  }
}
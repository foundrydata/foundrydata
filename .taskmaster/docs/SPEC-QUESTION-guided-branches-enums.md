# SPEC Question
Anchor(s): ["cov://§3#coverage-model", "cov://§10#acceptance-criteria-v1", "spec://§8#branch-selection-algorithm"]

Voir aussi: `SPEC-QUESTION-multiple-instances-per-run.md` (rôle de `count` et diversité intra-run).

Symptôme:
Sur des schémas volontairement simples (un `oneOf` avec 3 branches d’objets disjoints, un objet avec `enum` de 4 valeurs), et pour un tuple fixé `(schema, options coverage, seed)` en `coverage=guided`, l’implémentation actuelle ne parvient pas à couvrir systématiquement toutes les cibles `ONEOF_BRANCH` / `ENUM_VALUE_HIT` même avec un budget raisonnable (par exemple `count` entre 12 et 48). Les cibles sont bien matérialisées dans `targets[]` avec la bonne dimension (`branches` / `enum`), mais plusieurs restent `hit:false` et les métriques `coverage.byDimension['branches']` / `coverage.byDimension['enum']` restent nettement inférieures à 1. Or §10 (cov://§10#acceptance-criteria-v1) formule les scénarios d’acceptance “OneOf branches” et “Enums” comme si un mode guided avec budget “suffisant” devait atteindre 100 % de hit pour ces cibles sur des schémas de ce type.

Cas concret supplémentaire : sur `examples/payment.json` (schéma de paiement avec deux enums `currency` et `status` de taille 3), et pour un budget élevé (`count=400`, profil `balanced`), `coverage=guided` produit bien un flux différent de `coverage=measure` (par exemple `currency="USD", status="pending"` en measure vs `currency="GBP", status="succeeded"` en guided), mais `coverage.byDimension['enum']` reste strictement identique entre les deux modes (2 valeurs couvertes / 6 cibles, soit `0.333`), sans aucune cible `unreachable`. Guided “fait tourner” quelle valeur est couverte sur un run donné, mais n’augmente pas la cardinalité de valeurs couvertes sur un schéma pourtant simple.

Impact:
Il existe un décalage entre (a) les garanties implicites de la SPEC pour `coverage=guided` sur les branches/enums simples et (b) le comportement effectif du planner/générateur piloté par les hints, tel qu’implémenté aujourd’hui. En pratique:
- les tests d’acceptance peuvent difficilement affirmer “tous les `ONEOF_BRANCH`/`ENUM_VALUE_HIT` sont hit” sans soit (i) rendre les tests extrêmement fragiles au moindre ajustement de budget/heuristiques, soit (ii) introduire du comportement spécial dans le moteur pour ces cas particuliers;
- inversement, si l’on assouplit la lecture de §10 pour accepter “couverture partielle mais diagnostic clair” sur branches/enums même pour des schémas simples, on risque de laisser des implémentations très conservatrices se revendiquer conformes alors qu’elles ne fournissent pas l’amélioration de couverture attendue en mode guided par rapport à `coverage=measure` (cov://§3#coverage-model, spec://§8#branch-selection-algorithm).
En particulier, l’implémentation actuelle agrège tous les hints produits par le planner en un seul bloc (par canonPath), puis le générateur ne consomme qu’un unique hint `coverEnumValue` / `preferBranch` par nœud et par run : les autres valeurs/branches restent donc dépendantes d’autres runs (seeds ou budgets différents) pour être couvertes, même lorsque `count` est élevé. Ce flou sur le rôle attendu de guided dans la diversification intra-run rend difficile à la fois la rédaction de tests d’acceptance stables et l’évaluation de la conformité d’autres implémentations coverage-aware.

Proposition:
Clarifier explicitement, dans la SPEC, le niveau d’exigence pour `coverage=guided` sur les dimensions `branches` et `enum` dans le cas de schémas simples:
- soit **durcir le moteur comme la SPEC**: formaliser une exigence du type “pour tout schéma `oneOf` de taille ≤N sans contraintes bloquantes, et pour une plage de budget recommandée (par ex. `count∈[Kmin,Kmax]`), `coverage=guided` doit atteindre 100 % de hit sur les cibles `ONEOF_BRANCH` correspondantes, idem pour `ENUM_VALUE_HIT` sur des enums de taille ≤M”. Cela impliquerait de préciser dans §8 (spec://§8#branch-selection-algorithm) la stratégie de sélection de branches/valeurs en mode guided et d’aligner les implémentations existantes sur cette contrainte.
- soit **assouplir l’acceptance §10** en la reformulant de manière diagnostique: “guided doit (i) ne jamais régresser par rapport à `measure` sur `coverage.byDimension['branches'|'enum']`, (ii) maximiser la couverture dans la limite d’un budget documenté, et (iii) exposer clairement dans le rapport JSON quelles branches/valeurs restent `hit:false` et pourquoi (budget, `unreachable`, hints non satisfaits)”, sans promettre 100 % de hit même pour des schémas simples.

Recommandation pour V1 (penche pour l’option B):
Pour garder le caractère “acceptance” de §10 tout en étant utile côté DX/produit, il semble préférable d’aller dans le sens d’**Option B**:
- conserver la contrainte “guided ≥ measure” sur les métriques branches/enums (que l’implémentation respecte déjà),
- expliciter que, sur des schémas `oneOf`/`enum` “petits et réguliers” et pour un profil avec budget explicite (par ex. `coverage=guided` + profil `balanced`/`thorough` avec `count` ≥ nombre de branches/valeurs), une implémentation conforme **doit utiliser ce budget pour distribuer la couverture** sur les différentes cibles, plutôt que de “faire tourner” une seule valeur/branche par run,
- réserver les exigences les plus fortes (“100 % de hit sous budget X”) à un profil/présélection CLI documenté (par ex. un preset `thorough`), mais en indiquant clairement dans la SPEC que, pour ces profils, la diversité intra-run (branches/enum) fait partie du contrat de conformité, et que des runs guided qui restent systématiquement à “une seule valeur/branche par canonPath” ne satisfont pas l’intention de V1 sur ces dimensions.

# SPEC Question
Anchor(s): ["cov://§3#coverage-model", "cov://§4#coverage-planner", "spec://§8#branch-selection-algorithm"]

Symptôme:
La SPEC canonique décrit le générateur comme une source déterministe d’instances pilotée par un seed, et la SPEC coverage-aware définit `count` comme un budget d’instances tout en imposant, pour un tuple fixé `(canonical schema, OpenAPI spec, options, seed, ajvMajor, registryFingerprint)`, un flux d’instances déterministe et, en modes coverage, des garanties `guided >= measure` sur les métriques (§3 coverage model, §4 coverage planner, §8 branch-selection algorithm). En revanche, aucune des deux SPEC ne précise si, pour un run donné avec `count > 1`, l’implémentation doit viser des instances JSON distinctes au sein d’un même run (par exemple alterner différentes valeurs d’un `enum` ou différentes branches d’un `oneOf`) ou si la répétition de la même instance `count` fois est acceptable. L’implémentation actuelle, sur des schémas simples comme `examples/payment.json`, produit `count` clones strictement identiques pour un tuple donné, même en `coverage=guided` (le mode guided peut changer la “forme” globale de l’instance, mais pas la diversité intra-run).

Impact:
Cette zone grise a plusieurs conséquences:
- Du point de vue “génération de fixtures”, un consommateur peut s’attendre à ce que `count` fournisse un échantillon de scénarios distincts (par ex. différentes valeurs d’un `enum`, différents statuts de paiement, différentes branches) plutôt qu’un simple multiplicateur de la même instance, ce qui réduit l’utilité pratique de `count` si la SPEC considère cette diversité comme facultative.
- Du point de vue coverage-aware, `count` sert de budget pour la planification (`maxInstances`); la SPEC garantit que `coverage=measure` ne modifie pas le flux par rapport à `coverage=off` et que `coverage=guided` peut le modifier pour améliorer la couverture, mais ne précise pas si cette amélioration doit se manifester à l’intérieur d’un run unique (diversité sur les `count` instances) ou uniquement entre runs ou entre seeds. En l’absence de directive explicite, une implémentation qui génère `count` clones identiques tout en améliorant la couverture via un choix global (par exemple figer `currency = "GBP"` pour toutes les instances en guided) semble conforme, mais cela rend difficile de savoir si d’autres implémentations qui distribuent les cibles sur les `count` instances fournissent un “plus” optionnel ou répondent à une exigence implicite.

Proposition:
Clarifier explicitement, dans la SPEC (canonique et/ou coverage-aware), le rôle de `count` par rapport à la diversité intra-run:
- Option A (conservatrice, proche de l’implémentation actuelle): formaliser que `count` est un budget d’instances sans exigence d’unicité intra-run; la seule contrainte est le déterminisme pour un tuple donné et, en coverage-aware, les invariants `coverage=measure` (flux identique à `coverage=off`) et `coverage=guided` (amélioration de couverture sans casser AJV ni le déterminisme). La diversité sur les `count` instances reste permise mais non requise, et peut être traitée comme une optimisation d’implémentation ou un profil CLI spécifique.
- Option B (plus prescriptive côté DX): exiger qu’en présence de dimensions pertinentes (en particulier `branches` / `enum` sous `coverage=guided`), le moteur doive utiliser `count` comme budget de scénarios distincts au sein d’un même run, par exemple en répartissant les hints/plans de couverture sur les `count` instances (en respectant la déterminisme pour un tuple fixé). Cette option nécessiterait d’expliciter dans §3/§4 (coverage) et §8 (branch-selection algorithm) que, sous certaines conditions (schémas “simples”, budget suffisant), une implémentation conforme doit éviter de générer `count` clones identiques et viser une diversité intra-run mesurable (par exemple en termes de cibles couvertes par instance).


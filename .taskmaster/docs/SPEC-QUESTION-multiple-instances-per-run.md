# SPEC Question
Anchor(s): ["cov://§3#coverage-model", "cov://§4#coverage-planner", "spec://§8#branch-selection-algorithm"]

Voir aussi: `SPEC-QUESTION-guided-branches-enums.md` (niveau d’exigence pour `coverage=guided` sur branches/enums).

Symptôme:
La SPEC canonique décrit le générateur comme une source déterministe d’instances pilotée par un seed, et la SPEC coverage-aware définit `maxInstances` (et, côté CLI, `--n`) comme un budget d’instances tout en imposant, pour un tuple fixé `(canonical schema, OpenAPI spec, options, seed, ajvMajor, registryFingerprint)`, un flux d’instances déterministe et, en modes coverage, des garanties `guided >= measure` sur les métriques (§3 coverage model, §4 coverage planner, §8 branch-selection algorithm). En revanche, aucune des deux SPEC ne précise si, pour un run donné avec `maxInstances > 1` (ou un `count` de génération implicite correspondant), l’implémentation doit viser des instances JSON distinctes au sein d’un même run (par exemple alterner différentes valeurs d’un `enum` ou différentes branches d’un `oneOf`) ou si la répétition de la même instance plusieurs fois est acceptable. L’implémentation actuelle, sur des schémas simples comme `examples/payment.json`, produit plusieurs clones strictement identiques pour un tuple donné, même en `coverage=guided` (le mode guided peut changer la “forme” globale de l’instance, mais pas la diversité intra-run).

Impact:
Cette zone grise a plusieurs conséquences:
- Du point de vue “génération de fixtures”, un consommateur peut s’attendre à ce que le budget d’instances (`maxInstances` côté SPEC coverage-aware, `count`/`--n` côté API/CLI) fournisse un échantillon de scénarios distincts (par ex. différentes valeurs d’un `enum`, différents statuts de paiement, différentes branches) plutôt qu’un simple multiplicateur de la même instance, ce qui réduit l’utilité pratique de ce budget si la SPEC considère cette diversité comme facultative.
- Du point de vue coverage-aware, le budget de planification est spécifié en termes de `maxInstances` (avec, côté CLI, `--n` et un `count` de génération induit); la SPEC garantit que `coverage=measure` ne modifie pas le flux par rapport à `coverage=off` et que `coverage=guided` peut le modifier pour améliorer la couverture, mais ne précise pas si cette amélioration doit se manifester à l’intérieur d’un run unique (diversité sur les différentes instances jusqu’à `maxInstances`) ou uniquement entre runs ou entre seeds. En l’absence de directive explicite, une implémentation qui génère plusieurs clones identiques tout en améliorant la couverture via un choix global (par exemple figer `currency = "GBP"` pour toutes les instances en guided) semble conforme, mais cela rend difficile de savoir si d’autres implémentations qui distribuent les cibles sur les différentes instances du budget fournissent un “plus” optionnel ou répondent à une exigence implicite.

Proposition:
Clarifier explicitement, dans la SPEC (canonique et/ou coverage-aware), le rôle de `maxInstances` (et, côté API/CLI, du paramètre de `count` qui en découle) par rapport à la diversité intra-run:
- Option A (conservatrice, proche de l’implémentation actuelle): formaliser que `maxInstances` est un budget d’instances sans exigence d’unicité intra-run; la seule contrainte est le déterminisme pour un tuple donné et, en coverage-aware, les invariants `coverage=measure` (flux identique à `coverage=off`) et `coverage=guided` (amélioration de couverture sans casser AJV ni le déterminisme). La diversité sur les différentes instances du budget reste permise mais non requise, et peut être traitée comme une optimisation d’implémentation ou un profil CLI spécifique.
- Option B (plus prescriptive côté DX, recommandée): exiger qu’en présence de dimensions pertinentes (en particulier `branches` / `enum` sous `coverage=guided`), le moteur doive utiliser `maxInstances` comme budget de scénarios distincts au sein d’un même run, par exemple en répartissant les hints/plans de couverture sur les différentes instances (en respectant la déterminisme pour un tuple fixé). Concrètement, cela pourrait se traduire par une contrainte du type “pour une enum de taille ≤ M et un budget `maxInstances ≥ M` sans contraintes bloquantes, une implémentation conforme devrait planifier des unités qui couvrent chacune des M valeurs au moins une fois dans le run, plutôt que de générer plusieurs clones d’une seule valeur”. Cette option nécessiterait d’expliciter dans §3/§4 (coverage) et §8 (branch-selection algorithm) que, sous certaines conditions (schémas “simples”, budget suffisant), une implémentation conforme doit éviter de générer des clones identiques pour l’ensemble du budget et viser une diversité intra-run mesurable (par exemple en termes de cibles couvertes par instance).

Recommandation pour V1:
Pencher vers l’option B semble plus aligné avec les attentes DX pour FoundryData et Contract/Test Copilot: dans au moins un profil CLI “structuré” (par ex. `coverage=guided` + profil `balanced`/`thorough`), `maxInstances` (et `--n`) devrait être interprété comme un budget de scénarios distincts intra-run sur les dimensions `branches`/`enum`, et la SPEC devrait le dire explicitement. L’implémentation actuelle (clones intra-run même en guided, comme observé sur `examples/payment.json`) resterait acceptable pour des profils “baseline”, mais ne satisferait pas, telle quelle, un profil qui prétend offrir une exploration guidée des branches/enum à l’intérieur d’un seul run.

# SPEC Question
Anchor(s): ["spec://§11#lax", "cov://§4#generator-instrumentation", "cov://§8#technical-constraints-invariants"]

Symptôme:
La SPEC canonique décrit précisément le comportement `skippedValidation:true` pour la validation finale en mode Lax lorsque les échecs AJV sont exclusivement dus à des `$ref` externes non résolus (§11 Lax / ExternalRefSkipEligibility). Dans ce cas, la validation finale peut être “skippée” (`validation.skippedValidation:true`), avec `EXTERNAL_REF_UNRESOLVED{mode:'lax', skippedValidation:true}` et `metrics.validationsPerRow = 0`. La SPEC coverage-aware (§4.3 Generator instrumentation, §8 Technical constraints & invariants) exige par ailleurs que la couverture soit calculée à partir des instances finales après Generate → Repair → Validate, et que les hits ne soient engagés qu’une fois que Validate a accepté l’instance. En revanche, aucune des deux SPEC ne précise si une instance marquée `skippedValidation:true` doit être considérée comme “acceptée” pour la couverture, ni si ses hits peuvent ou doivent être engagés dans les bitmaps de coverage.

Impact:
Dans l’implémentation actuelle, la couche streaming coverage accumule les événements par instance pendant Generate/Repair et ne commite les hits globaux que lorsque Validate retourne `ok === true` pour une instance donnée. Lorsque `validation.skippedValidation === true` (Lax + ExternalRefSkipEligibility), le pipeline est `status:'completed'` mais aucun commit de coverage n’est effectué pour les instances correspondantes, ce qui conduit à une couverture potentiellement sous-estimée dans ces scénarios (les cibles touchées par ces instances restent non couvertes). À l’inverse, si l’on décidait de “compter” ces instances comme acceptées et de committer leurs hits, on introduirait une forme de couverture sans validation AJV, ce qui peut être vu comme une entorse au principe “AJV as oracle” et aux invariants coverage-aware (“commit only after Validate”). L’absence de directive explicite laisse la porte ouverte à des implémentations divergentes sur ce point, avec un risque de non-portabilité des rapports de couverture en présence de `$ref` externes et de modes Lax.

Proposition:
Clarifier la relation entre `validation.skippedValidation === true` et la sémantique de couverture dans coverage-aware V1, en choisissant explicitement l’une des options suivantes (ou une variante stricte) :
- Option A (conservatrice, actuelle): Une instance pour laquelle la validation finale a été skippée (`skippedValidation:true`) **n’est pas** considérée comme “acceptée” pour la couverture; les hits collectés pendant Generate/Repair pour cette instance ne doivent pas être committés dans les bitmaps globaux. Cette option favorise la prudence (mieux vaut “uncovered” que “couvert sans validation”) et maintient une lecture stricte de “Validate accepte l’instance = AJV a effectivement validé”.
- Option B (tolerante, explicitement encadrée): Considérer que, en mode Lax et uniquement lorsque ExternalRefSkipEligibility a réussi, les instances associées à `skippedValidation:true` peuvent être traitées comme “acceptées” pour la couverture, et que leurs hits peuvent être committés, sous réserve que:
  * le rapport de couverture encode clairement cette situation (par ex. un diagnostic ou un champ de métadonnées indiquant que la couverture reflète des instances non validées AJV) ;
  * les métriques et/ou la documentation signalent que coverage.overall inclut des instances pour lesquelles seules les parties “non-external-$ref” ont été effectivement couvertes.

La recommandation de l’agent est d’adopter explicitement l’Option A pour V1 (pas de commit coverage lorsque `skippedValidation:true`), en alignement avec le principe “AJV as oracle” et avec la formulation actuelle de §4.3/§8 coverage-aware qui parle d’instances “acceptées par Validate” sans mentionner de cas d’exception. Une clarification SPEC explicite sur ce point (par exemple une note normative ou informative dans §4.3 ou §8 coverage-aware, référant §11 Lax de la SPEC canonique) permettrait d’éviter des implémentations divergentes autour de la couverture en présence d’external `$ref` non résolus.


/**
 * ================================================================================
 * COMPLETE DEFINITIVE GUIDE - FOUNDRYDATA TESTING
 * Single Source of Truth for Implementation - v2.1.0 (corrig√©)
 * Stack: TypeScript + Vitest + Fast-check
 * Fixed: Multi-draft support, determinism, performance, contradictions
 *
 * NOTE: Format semantics (assertive vs annotative) are governed by the
 *       **Formats Policy (Strategy v2.2)**. Do not override it in code;
 *       see "Policy: Format Handling by Draft (Normative)".
 *
 * Testing-Doctrine: 2.2
 * ================================================================================
 */

// ================================================================================
// PART 1: COMPLETE CONFIGURATION
// ================================================================================

// ----------------------------------------
// vitest.config.ts - Production Configuration
// ----------------------------------------

import { defineConfig } from 'vitest/config';
import tsconfigPaths from 'vite-tsconfig-paths';
import { coverageConfigDefaults } from 'vitest/config';

export default defineConfig({
  plugins: [tsconfigPaths()],
  
  test: {
    // Base environment
    globals: true,
    environment: 'node',
    
    // Timeouts adapted for Property-Based Testing
    testTimeout: 30_000,      // 30s for complex property tests
    hookTimeout: 10_000,      // 10s for setup/teardown  
    teardownTimeout: 5_000,   // 5s for cleanup
    
    // Pool & Isolation - Platform-specific for stability
    isolate: true,
    pool: process.platform === 'win32' ? 'threads' : 'forks',
    poolOptions: {
      forks: {
        singleFork: false,
        isolate: true,
        maxForks: 5,
      },
      threads: {
        singleThread: false,
        isolate: true,
        maxThreads: 5,
      }
    },
    maxConcurrency: 5,
    
    // Complete Coverage Configuration
    coverage: {
      provider: 'v8',
      enabled: process.env.COVERAGE !== 'false',
      all: true,
      clean: true,
      
      // All reporters for CI/CD
      reporter: ['text', 'json', 'html', 'lcov', 'cobertura', 'json-summary'],
      reportsDirectory: './coverage',
      
      // Progressive thresholds
      thresholds: {
        // Global: Start at 80%, aim for 90%
        lines: 80,
        functions: 80,
        branches: 80,
        statements: 80,
        
        // Critical zones = high standards
        'src/generators/**': {
          lines: 90,
          functions: 90,
          branches: 85,
          statements: 90,
        },
        'src/validators/**': {
          lines: 95,
          functions: 95,
          branches: 90,
          statements: 95,
        },
        'src/core/**': {
          lines: 90,
          functions: 90,
          branches: 85,
          statements: 90,
        }
      },
      
      // Complete exclusions
      exclude: [
        ...coverageConfigDefaults.exclude,
        '**/*.d.ts',
        '**/*.test.ts',
        '**/*.spec.ts',
        '**/*.test-d.ts',
        '**/test/**',
        '**/tests/**',
        '**/__tests__/**',
        '**/dist/**',
        '**/build/**',
        '**/node_modules/**',
        '**/__mocks__/**',
        '**/coverage/**',
        '**/.{idea,git,cache,output,temp}/**',
        '**/index.ts', // Often just exports
      ],
      
      // Specific inclusions
      include: [
        'src/**/*.ts',
        'packages/*/src/**/*.ts',
      ],
    },
    
    // Reporters differentiated by environment
    reporters: process.env.CI 
      ? ['dot', 'json', 'junit', 'github-actions']
      : process.env.VERBOSE 
        ? ['verbose', 'html']
        : ['default', 'html'],
    
    outputFile: {
      json: './test-results/results.json',
      junit: './test-results/junit.xml',
      html: './test-results/index.html',
    },
    
    // Performance Monitoring
    logHeapUsage: true,
    slowTestThreshold: 1000,
    
    // Retry Strategy - DISABLED for PBT determinism
    retry: 0, // No retries - we want to catch flaky tests
    passWithNoTests: false,
    bail: process.env.CI ? 10 : 0,
    
    // Reproducibility - FIXED seed, no shuffle in CI
    sequence: {
      seed: process.env.CI ? 1 : parseInt(process.env.TEST_SEED || '424242'),
      shuffle: !process.env.CI, // No shuffle in CI for determinism
      concurrent: false,
    },
    
    // Setup & Teardown
    setupFiles: ['./test/setup.ts'],
    globalSetup: './test/global-setup.ts',
    globalTeardown: './test/global-teardown.ts',
    
    // Inclusion/exclusion patterns
    include: [
      '**/*.{test,spec}.ts',
      'src/**/__tests__/**/*.ts',
    ],
    exclude: [
      'node_modules/**',
      'dist/**',
      'build/**',
      '**/*.js',
      '**/*.d.ts',
    ],
    
    // Watch Mode
    watchExclude: [
      '**/node_modules/**',
      '**/dist/**',
      '**/build/**',
      '**/.git/**',
      '**/coverage/**',
    ],
    
    // Type checking
    typecheck: {
      enabled: true,
      checker: 'tsc',
      tsconfig: './tsconfig.test.json',
    },
  },
  
  // Build Optimizations
  esbuild: {
    target: 'node20',
    platform: 'node',
    format: 'cjs',
  },
  
  // Module Resolution
  resolve: {
    alias: {
      '@': './src',
      '@test': './test',
      '@fixtures': './test/fixtures',
      '@arbitraries': './test/arbitraries',
      '@helpers': './test/helpers',
    },
  },
});

// ----------------------------------------
// test/helpers/ajv-factory.ts - AJV Factory by Draft (aligned with Policy v2.2)
// ----------------------------------------

import Ajv, { AnySchema } from 'ajv';
import Ajv2019 from 'ajv/dist/2019';
import Ajv2020 from 'ajv/dist/2020';
import addFormats from 'ajv-formats';
import draft2019Formats from 'ajv-formats-draft2019';

export type JsonSchemaDraft = 'draft-07' | '2019-09' | '2020-12';

// Formats that MUST remain Annotative per Policy v2.2
const ANNOTATIVE_FORMATS: readonly string[] = [
  'json-pointer',
  'relative-json-pointer',
  'uri-template',
];

// Cache compiled validators
const validatorCache = new WeakMap<object, any>();

export function createAjv(draft: JsonSchemaDraft = '2020-12') {
  const baseOptions = {
    strict: true,
    allErrors: true,
    verbose: true,
    strictSchema: true,
    strictNumbers: true,
    strictRequired: true,
    allowUnionTypes: false,  // Avoid non-standard "string|number" syntax
    validateFormats: true,    // Assert formats (not just annotate)
  } as const;

  let ajv: Ajv;
  
  switch (draft) {
    case '2020-12':
      ajv = new Ajv2020(baseOptions);
      break;
    case '2019-09':
      ajv = new Ajv2019(baseOptions);
      break;
    case 'draft-07':
    default:
      ajv = new Ajv(baseOptions);
      break;
  }

  // Add standard formats
  addFormats(ajv);

  // Add draft-specific formats
  if (draft !== 'draft-07') {
    draft2019Formats(ajv);
  }

  // --- Policy v2.2 alignment: downgrade specific formats to Annotative ---
  // We keep validateFormats=true for all asserted formats, but for formats
  // with high inter-implementation variance, we neutralize them (always pass)
  // and log the downgrade once.
  const once = new Set<string>();
  for (const name of ANNOTATIVE_FORMATS) {
    // Override with a no-op validator (acts as annotation)
    ajv.addFormat(name, {
      type: 'string',
      validate: () => true,
    });
    if (!once.has(name)) {
      // eslint-disable-next-line no-console
      console.warn(`[Formats Policy v2.2] Downgraded format to annotative: ${name}`);
      once.add(name);
    }
  }

  // Expose a tiny helper to print the active classification (for CI logs)
  (ajv as any).__printFormatsPolicySummary = () => {
    const asserted = [
      'date-time','date','time','duration','email','hostname','idn-email','idn-hostname',
      'ipv4','ipv6','uri','uri-reference','iri','iri-reference','regex','uuid'
    ].filter(f => (ANNOTATIVE_FORMATS as readonly string[]).indexOf(f) === -1);
    // eslint-disable-next-line no-console
    console.log('[Formats Policy v2.2] Asserted formats:', asserted.join(', '));
    // eslint-disable-next-line no-console
    console.log('[Formats Policy v2.2] Annotative formats:', ANNOTATIVE_FORMATS.join(', '));
  };

  // Wrap compile to use cache
  const originalCompile = ajv.compile.bind(ajv);
  ajv.compile = function (schema: AnySchema) {
    if (validatorCache.has(schema as any)) {
      return validatorCache.get(schema as any);
    }
    const validator = originalCompile(schema);
    validatorCache.set(schema as any, validator);
    return validator;
  };

  return ajv;
}

// Singleton instance based on environment
let ajvInstance: Ajv | null = null;

export function getAjv(): Ajv {
  if (!ajvInstance) {
    const draft = (process.env.SCHEMA_DRAFT as JsonSchemaDraft) || '2020-12';
    ajvInstance = createAjv(draft);
    // Print the policy summary once per process for traceability
    if ((ajvInstance as any).__printFormatsPolicySummary) {
      (ajvInstance as any).__printFormatsPolicySummary();
    }
  }
  return ajvInstance;
}

// ----------------------------------------
// test/setup.ts - Global Test Configuration
// ----------------------------------------

import { beforeAll, beforeEach, afterEach, afterAll, vi, expect } from 'vitest';
import fc from 'fast-check';
import { getAjv } from './helpers/ajv-factory';

// Fast-check Configuration with deterministic defaults
beforeAll(() => {
  const isCI = process.env.CI === 'true';
  const isDebug = process.env.DEBUG === 'true';
  
  // Fixed seed for reproducibility
  const seed = process.env.TEST_SEED ? parseInt(process.env.TEST_SEED) : 424242;
  
  // Number of runs from environment or defaults
  const numRuns = process.env.FC_NUM_RUNS 
    ? parseInt(process.env.FC_NUM_RUNS)
    : (isCI ? 1000 : 100);
  
  fc.configureGlobal({
    numRuns,
    seed,
    verbose: isDebug || (isCI && process.env.VERBOSE === 'true'),
    interruptAfterTimeLimit: isCI ? 25_000 : 5_000,
    markInterruptAsFailure: true,
    skipAllAfterTimeLimit: isCI ? undefined : 5_000,
    examples: isDebug ? [] : undefined,
    asyncReporter: isCI,
    maxSkipsPerRun: 100,
    maxShrinkTime: 5_000,
  });
  
  console.log(`üå± Fast-check configured: seed=${seed}, runs=${numRuns}`);
  
  // Setup global AJV instance
  const ajv = getAjv();
  (global as any).ajv = ajv;
  
  const draft = process.env.SCHEMA_DRAFT || '2020-12';
  console.log(`üìã JSON Schema Draft: ${draft}`);
});

// Cleanup before each test - minimal interference
beforeEach(() => {
  // Clear mocks only
  vi.clearAllMocks();
  vi.resetModules();
});

// Cleanup after each test - targeted
afterEach(() => {
  // Clear mocks
  vi.clearAllMocks();
  vi.restoreAllMocks();
  
  // Force GC if available (memory leak detection)
  if (global.gc) {
    global.gc();
  }
});

// Final cleanup
afterAll(() => {
  // Reset fast-check configuration
  fc.resetConfigureGlobal();
  
  // Cleanup AJV
  if ((global as any).ajv) {
    delete (global as any).ajv;
  }
});

// ----------------------------------------
// test/global-setup.ts - Global Setup (before all tests)
// ----------------------------------------

export async function setup() {
  const seed = process.env.TEST_SEED || '424242';
  const numRuns = process.env.FC_NUM_RUNS || (process.env.CI ? '1000' : '100');
  
  console.log('üöÄ FoundryData Test Suite Starting...');
  console.log(`üìÖ Date: ${new Date().toISOString()}`);
  console.log(`üå± Seed: ${seed}`);
  console.log(`üî¢ Runs: ${numRuns}`);
  console.log(`üîß Environment: ${process.env.CI ? 'CI' : 'Local'}`);
  console.log(`üìä Coverage: ${process.env.COVERAGE !== 'false' ? 'Enabled' : 'Disabled'}`);
  console.log(`üìú JSON Schema Draft: ${process.env.SCHEMA_DRAFT || '2020-12'}`);
  console.log('üìë Formats Policy: Strategy v2.2 (asserted vs annotative)');
  console.log('üìë Annotative formats: json-pointer, relative-json-pointer, uri-template');
  
  // Create result directories
  const fs = await import('fs/promises');
  await fs.mkdir('./test-results', { recursive: true });
  await fs.mkdir('./coverage', { recursive: true });
  
  // Setup performance monitoring
  if (process.env.PERF_MONITORING) {
    const { performance, PerformanceObserver } = await import('perf_hooks');
    
    const perfObserver = new PerformanceObserver((items) => {
      items.getEntries().forEach((entry) => {
        if (entry.duration > 100) {
          console.warn(`‚ö†Ô∏è  Slow operation: ${entry.name} took ${entry.duration.toFixed(2)}ms`);
        }
      });
    });
    
    perfObserver.observe({ entryTypes: ['measure'] });
    (global as any).perfObserver = perfObserver;
  }
}

// ----------------------------------------
// test/global-teardown.ts - Global Teardown (after all tests)
// ----------------------------------------

export async function teardown() {
  console.log('‚úÖ FoundryData Test Suite Completed');
  
  // Stop performance monitoring
  if ((global as any).perfObserver) {
    (global as any).perfObserver.disconnect();
    delete (global as any).perfObserver;
  }
  
  // Generate summary report if requested
  if (process.env.GENERATE_REPORT) {
    const fs = await import('fs/promises');
    const report = {
      date: new Date().toISOString(),
      duration: process.uptime(),
      environment: process.env.CI ? 'CI' : 'Local',
      nodeVersion: process.version,
      platform: process.platform,
      arch: process.arch,
      seed: process.env.TEST_SEED || '424242',
      runs: process.env.FC_NUM_RUNS || (process.env.CI ? '1000' : '100'),
      draft: process.env.SCHEMA_DRAFT || '2020-12',
    };
    
    await fs.writeFile(
      './test-results/summary.json',
      JSON.stringify(report, null, 2)
    );
  }
}

// ================================================================================
// PART 2: CUSTOM MATCHERS & HELPERS
// ================================================================================

// ----------------------------------------
// test/matchers/index.ts - Custom Vitest Matchers
// ----------------------------------------

import { expect } from 'vitest';
import type { MatcherResult } from '@vitest/expect';
import { getAjv } from '@helpers/ajv-factory';

// Types for custom matchers
declare module 'vitest' {
  interface Assertion<T = any> {
    toMatchJsonSchema(schema: object): void;
    toBeWithinRange(min: number, max: number): void;
    toHaveCompliance(expected: number): void;
    toBeValidUUID(): void;
    toBeValidEmail(): void;
    toBeValidISO8601(): void;
    toBeValidJSON(): void;
    toBeDistinct(deep?: boolean): void;
    toHaveErrorRate(expectedRate: number, tolerance?: number): void;
    toBeGeneratedWithSeed(options: { seed: number; schema: any; generate: Function }): void;
  }
}

// Matcher implementations
export const customMatchers = {
  /**
   * Verify data matches JSON Schema using cached AJV
   */
  toMatchJsonSchema(received: unknown, schema: object): MatcherResult {
    const ajv = getAjv();
    const validate = ajv.compile(schema);
    const valid = validate(received);
    
    return {
      pass: valid as boolean,
      message: () => {
        if (valid) {
          return `Expected data not to match schema`;
        }
        
        const errors = (validate.errors || [])
          .map(err => `  - ${err.instancePath || '/'}: ${err.message}`)
          .join('\n');
        
        return [
          `Expected data to match JSON Schema`,
          ``,
          `Schema violations:`,
          errors,
          ``,
          `Received:`,
          JSON.stringify(received, null, 2).slice(0, 500),
        ].join('\n');
      },
    } as MatcherResult;
  },
  
  /**
   * Verify value is within range
   */
  toBeWithinRange(received: number, min: number, max: number): MatcherResult {
    const pass = received >= min && received <= max;
    
    return {
      pass,
      message: () =>
        pass
          ? `Expected ${received} not to be within range [${min}, ${max}]`
          : `Expected ${received} to be within range [${min}, ${max}]`,
    } as MatcherResult;
  },
  
  /**
   * Verify compliance score
   */
  toHaveCompliance(
    received: { score: number; compliant: boolean },
    expected: number
  ): MatcherResult {
    const pass = received.score === expected;
    
    return {
      pass,
      message: () =>
        pass
          ? `Expected compliance score not to be ${expected}%`
          : `Expected compliance score to be ${expected}%, got ${received.score}%`,
    } as MatcherResult;
  },
  
  /**
   * Validate UUID v4
   */
  toBeValidUUID(received: string): MatcherResult {
    const uuidV4Regex = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
    const pass = uuidV4Regex.test(received);
    
    return {
      pass,
      message: () =>
        pass
          ? `Expected "${received}" not to be a valid UUID v4`
          : `Expected "${received}" to be a valid UUID v4`,
    } as MatcherResult;
  },
  
  /**
   * Validate email using AJV format
   */
  toBeValidEmail(received: string): MatcherResult {
    const ajv = getAjv();
    const validate = ajv.compile({ type: 'string', format: 'email' });
    const pass = validate(received) as boolean;
    
    return {
      pass,
      message: () =>
        pass
          ? `Expected "${received}" not to be a valid email`
          : `Expected "${received}" to be a valid email: ${JSON.stringify(validate.errors)}`,
    } as MatcherResult;
  },
  
  /**
   * Validate ISO 8601 date using AJV
   */
  toBeValidISO8601(received: string): MatcherResult {
    const ajv = getAjv();
    const validate = ajv.compile({ type: 'string', format: 'date-time' });
    const pass = validate(received) as boolean;
    
    return {
      pass,
      message: () =>
        pass
          ? `Expected "${received}" not to be a valid ISO 8601 date`
          : `Expected "${received}" to be a valid ISO 8601 date: ${JSON.stringify(validate.errors)}`,
    } as MatcherResult;
  },
  
  /**
   * Validate JSON
   */
  toBeValidJSON(received: string): MatcherResult {
    let isValid = true;
    let error = '';
    
    try {
      JSON.parse(received);
    } catch (e) {
      isValid = false;
      error = (e as Error).message;
    }
    
    return {
      pass: isValid,
      message: () =>
        isValid
          ? `Expected string not to be valid JSON`
          : `Expected string to be valid JSON. Parse error: ${error}`,
    } as MatcherResult;
  },
  
  /**
   * Verify uniqueness of array elements (with deep comparison option)
   */
  toBeDistinct(received: any[], deep: boolean = false): MatcherResult {
    const seen = new Set<string>();
    const duplicates: any[] = [];
    
    // Use stable stringify for consistent comparison
    const stableStringify = (obj: any): string => {
      if (typeof obj !== 'object' || obj === null) {
        return String(obj);
      }
      return JSON.stringify(obj, Object.keys(obj).sort());
    };
    
    for (const value of received) {
      const key = deep ? stableStringify(value) : String(value);
      
      if (seen.has(key)) {
        duplicates.push(value);
      }
      seen.add(key);
    }
    
    const pass = duplicates.length === 0;
    
    return {
      pass,
      message: () =>
        pass
          ? `Expected array not to have all distinct elements`
          : `Expected array to have all distinct elements. Duplicates found: ${JSON.stringify(duplicates).slice(0, 500)}`,
    } as MatcherResult;
  },
  
  /**
   * Verify error rate with protection against division by zero
   */
  toHaveErrorRate(
    received: { errors: number; total: number },
    expectedRate: number,
    tolerance: number = 0.05
  ): MatcherResult {
    const actualRate = received.total > 0 ? received.errors / received.total : 0;
    const pass = Math.abs(actualRate - expectedRate) <= tolerance;
    
    return {
      pass,
      message: () =>
        pass
          ? `Expected error rate not to be ${expectedRate} ¬± ${tolerance}`
          : `Expected error rate to be ${expectedRate} ¬± ${tolerance}, got ${actualRate.toFixed(3)}`,
    } as MatcherResult;
  },
  
  /**
   * Verify data was generated with specific seed (fixed API)
   */
  toBeGeneratedWithSeed(
    received: any,
    options: { seed: number; schema: any; generate: (opts: {seed: number; schema: any}) => any }
  ): MatcherResult {
    const expected = options.generate({ seed: options.seed, schema: options.schema });
    const pass = JSON.stringify(received) === JSON.stringify(expected);
    
    return {
      pass,
      message: () =>
        pass
          ? `Expected data not to be generated with seed ${options.seed}`
          : `Expected data to be generated with seed ${options.seed}`,
    } as MatcherResult;
  },
};

// Register matchers
expect.extend(customMatchers);

// ================================================================================
// PART 3: CUSTOM FAST-CHECK ARBITRARIES
// ================================================================================

// ----------------------------------------
// test/arbitraries/json-schema.ts - JSON Schema Arbitraries by Draft
// ----------------------------------------

import fc from 'fast-check';
import type { JsonSchemaDraft } from '@helpers/ajv-factory';

/**
 * Helper to create consistent bounds
 */
const createBounds = (min: number, max: number) =>
  fc.tuple(
    fc.integer({ min, max }),
    fc.integer({ min, max })
  ).map(([a, b]) => a <= b ? [a, b] as const : [b, a] as const);

/**
 * Arbitrary for generating valid JSON Schemas by draft
 * Ensures no contradictions in constraints
 */
export function jsonSchemaArbitraryFor(draft: JsonSchemaDraft) {
  // Number schema
  const numberSchema = fc.record({
    type: fc.constantFrom('number' as const, 'integer' as const),
  }).chain(base =>
    createBounds(-1_000_000, 1_000_000).chain(([min, max]) =>
      fc.record({
        ...base,
        minimum: fc.option(fc.constant(min), { nil: undefined }),
        maximum: fc.option(fc.constant(max), { nil: undefined }),
        exclusiveMinimum: fc.option(fc.constant(min - 1), { nil: undefined }),
        exclusiveMaximum: fc.option(fc.constant(max + 1), { nil: undefined }),
        multipleOf: fc.option(fc.integer({ min: 1, max: 10 }), { nil: undefined }),
      })
    )
  );
  
  // String schema
  const stringSchema = fc.record({
    type: fc.constant('string' as const),
  }).chain(base =>
    createBounds(0, 1000).chain(([minLength, maxLength]) =>
      fc.record({
        ...base,
        minLength: fc.option(fc.constant(minLength), { nil: undefined }),
        maxLength: fc.option(fc.constant(maxLength), { nil: undefined }),
        pattern: fc.option(fc.oneof(
          fc.constant('^[a-z]+$'),
          fc.constant('^[A-Z]+$'),
          fc.constant('^[0-9]+$')
        ), { nil: undefined })
      })
    )
  );

  // Boolean schema
  const booleanSchema = fc.record({
    type: fc.constant('boolean' as const),
    enum: fc.option(fc.array(fc.boolean(), { minLength: 1, maxLength: 2 }), { nil: undefined }),
    const: fc.option(fc.boolean(), { nil: undefined }),
  });

  // Null schema
  const nullSchema = fc.record({
    type: fc.constant('null' as const),
  });

  // Object schema with required ‚äÜ properties
  const objectSchema = (subSchema: fc.Arbitrary<any>) =>
    fc.record({
      type: fc.constant('object' as const),
      properties: fc.option(
        fc.dictionary(
          fc.string({ minLength: 1, maxLength: 20 })
            .filter(s => /^[a-zA-Z][a-zA-Z0-9_]*$/.test(s)),
          subSchema,
          { minKeys: 0, maxKeys: 10 }
        ),
        { nil: undefined }
      ),
    }).chain(obj => {
      const propKeys = Object.keys(obj.properties || {});
      
      return fc.record({
        ...obj,
        required: fc.option(
          propKeys.length > 0 
            ? fc.shuffledSubarray(propKeys, { minLength: 0, maxLength: propKeys.length })
            : fc.constant([]),
          { nil: undefined }
        ),
        additionalProperties: fc.option(
          fc.oneof(fc.boolean(), subSchema),
          { nil: undefined }
        ),
        minProperties: fc.option(fc.nat({ max: 10 }), { nil: undefined }),
        maxProperties: fc.option(fc.nat({ max: 20 }), { nil: undefined }),
        
        // Draft-specific keywords
        ...(draft === 'draft-07' ? {
          // Draft-07 uses dependencies
          dependencies: propKeys.length > 0 ? fc.option(
            fc.dictionary(
              fc.constantFrom(...propKeys),
              fc.oneof(
                fc.shuffledSubarray(propKeys, { minLength: 1, maxLength: Math.min(5, propKeys.length) }),
                subSchema
              ),
              { minKeys: 0, maxKeys: Math.min(3, propKeys.length) }
            ),
            { nil: undefined }
          ) : fc.constant(undefined),
        } : {
          // 2019-09 and 2020-12 use dependentRequired/dependentSchemas
          dependentRequired: propKeys.length > 0 ? fc.option(
            fc.dictionary(
              fc.constantFrom(...propKeys),
              fc.shuffledSubarray(propKeys, { minLength: 1, maxLength: Math.min(5, propKeys.length) }),
              { minKeys: 0, maxKeys: Math.min(3, propKeys.length) }
            ),
            { nil: undefined }
          ) : fc.constant(undefined),
          dependentSchemas: propKeys.length > 0 ? fc.option(
            fc.dictionary(
              fc.constantFrom(...propKeys),
              subSchema,
              { minKeys: 0, maxKeys: Math.min(3, propKeys.length) }
            ),
            { nil: undefined }
          ) : fc.constant(undefined),
          unevaluatedProperties: fc.option(
            fc.oneof(fc.boolean(), subSchema),
            { nil: undefined }
          ),
        }),
      });
    });

  // Array schema with draft-specific tuple handling
  const arraySchema = (subSchema: fc.Arbitrary<any>) =>
    fc.record({
      type: fc.constant('array' as const),
    }).chain(base =>
      createBounds(0, 1000).chain(([minItems, maxItems]) =>
        fc.record({
          ...base,
          minItems: fc.option(fc.constant(minItems), { nil: undefined }),
          maxItems: fc.option(fc.constant(maxItems), { nil: undefined }),
          uniqueItems: fc.option(fc.boolean(), { nil: undefined }),
          
          // Draft-specific tuple and items handling
          ...(draft === 'draft-07' ? {
            // Draft-07: items can be schema or array (tuple)
            items: fc.option(
              fc.oneof(
                subSchema,
                fc.array(subSchema, { minLength: 1, maxLength: 5 })
              ),
              { nil: undefined }
            ),
            contains: fc.option(subSchema, { nil: undefined }),
          } : {
            // 2019-09 and 2020-12: prefixItems for tuples, items for additional
            prefixItems: fc.option(
              fc.array(subSchema, { minLength: 0, maxLength: 5 }),
              { nil: undefined }
            ),
            items: fc.option(subSchema, { nil: undefined }),
            contains: fc.option(subSchema, { nil: undefined }),
            minContains: fc.option(fc.nat({ max: 10 }), { nil: undefined }),
            maxContains: fc.option(fc.nat({ max: 100 }), { nil: undefined }),
            unevaluatedItems: fc.option(
              fc.oneof(fc.boolean(), subSchema),
              { nil: undefined }
            ),
          }),
        })
      )
    );

  // Combined schemas
  const combinedSchema = (subSchema: fc.Arbitrary<any>) => fc.oneof(
    fc.record({
      allOf: fc.array(subSchema, { minLength: 2, maxLength: 4 }),
    }),
    fc.record({
      anyOf: fc.array(subSchema, { minLength: 2, maxLength: 4 }),
    }),
    fc.record({
      oneOf: fc.array(subSchema, { minLength: 2, maxLength: 4 }),
    }),
    fc.record({
      not: subSchema,
    }),
  );

  // Conditional schemas
  const conditionalSchema = (subSchema: fc.Arbitrary<any>) => fc.record({
    if: subSchema,
    then: fc.option(subSchema, { nil: undefined }),
    else: fc.option(subSchema, { nil: undefined }),
  });

  // Build recursive schema
  return fc.letrec(tie => ({
    schema: fc.frequency(
      { weight: 4, arbitrary: fc.oneof(stringSchema, numberSchema, booleanSchema, nullSchema) },
      { weight: 3, arbitrary: objectSchema(tie('schema')) },
      { weight: 2, arbitrary: arraySchema(tie('schema')) },
      { weight: 1, arbitrary: combinedSchema(tie('schema')) },
      { weight: 1, arbitrary: conditionalSchema(tie('schema')) }
    ),
  })).schema;
}

/**
 * Simple schema arbitrary for quick tests
 */
export const simpleSchemaArbitrary = fc.oneof(
  fc.record({ type: fc.constantFrom('string', 'number', 'boolean', 'null') }),
  fc.record({
    type: fc.constant('object'),
    properties: fc.dictionary(
      fc.string({ minLength: 1, maxLength: 10 }),
      fc.record({ type: fc.constantFrom('string', 'number', 'boolean') }),
      { maxKeys: 5 }
    ),
  }),
  fc.record({
    type: fc.constant('array'),
    items: fc.record({ type: fc.constantFrom('string', 'number', 'boolean') }),
  })
);

/**
 * Get schema arbitrary for current draft
 */
export function getSchemaArbitrary() {
  const draft = (process.env.SCHEMA_DRAFT as JsonSchemaDraft) || '2020-12';
  return jsonSchemaArbitraryFor(draft);
}

// ----------------------------------------
// test/arbitraries/business.ts - Business Scenario Arbitraries
// ----------------------------------------

/**
 * Arbitrary for FoundryData business scenarios
 */
export const businessScenarioArbitrary = fc.record({
  // Scenario type
  scenario: fc.constantFrom('normal', 'edge', 'peak', 'error'),
  
  // Load configuration
  load: fc.record({
    users: fc.integer({ min: 1, max: 10_000 }),
    requestsPerSecond: fc.integer({ min: 1, max: 1_000 }),
    duration: fc.integer({ min: 60, max: 3_600 }),
    rampUp: fc.integer({ min: 0, max: 300 }),
    rampDown: fc.integer({ min: 0, max: 300 }),
  }),
  
  // Data distribution (sum = 1)
  distribution: fc
    .tuple(
      fc.double({ min: 0, max: 1, noNaN: true }),
      fc.double({ min: 0, max: 1, noNaN: true }),
      fc.double({ min: 0, max: 1, noNaN: true })
    )
    .map(([normal, edge, error]) => {
      const total = normal + edge + error || 1;
      return {
        normal: normal / total,
        edge: edge / total,
        error: error / total,
      };
    }),
  
  // Error configuration
  errorConfig: fc.record({
    rate: fc.double({ min: 0, max: 0.5, noNaN: true }),
    types: fc.array(
      fc.constantFrom(
        'TIMEOUT',
        'INVALID_DATA',
        'SERVER_ERROR',
        'NETWORK_ERROR',
        'RATE_LIMIT',
        'AUTH_ERROR'
      ),
      { minLength: 1, maxLength: 6 }
    ),
    retryable: fc.boolean(),
    maxRetries: fc.integer({ min: 0, max: 5 }),
  }),
  
  // Edge cases configuration
  edgeCases: fc.record({
    nullValues: fc.boolean(),
    emptyStrings: fc.boolean(),
    maxLengthValues: fc.boolean(),
    minLengthValues: fc.boolean(),
    boundaryNumbers: fc.boolean(),
    specialCharacters: fc.boolean(),
    unicodeCharacters: fc.boolean(),
  }),
  
  // Seed for determinism
  seed: fc.integer({ min: 0, max: Number.MAX_SAFE_INTEGER }),
  
  // Metadata
  metadata: fc.record({
    name: fc.option(fc.string({ minLength: 1, maxLength: 100 }), { nil: undefined }),
    description: fc.option(fc.string({ minLength: 1, maxLength: 500 }), { nil: undefined }),
    tags: fc.array(fc.string({ minLength: 1, maxLength: 20 }), { maxLength: 10 }),
    version: fc.constantFrom('1.0.0', '2.0.0', '3.0.0'),
  }),
});

// ================================================================================
// PART 4: COMPLETE TEST PATTERNS
// ================================================================================

// ----------------------------------------
// test/patterns/invariant-testing.test.ts
// ----------------------------------------

import { describe, it, expect } from 'vitest';
import fc from 'fast-check';
import { getSchemaArbitrary, businessScenarioArbitrary } from '@arbitraries';
import { getAjv } from '@helpers/ajv-factory';

class DataGenerator { /* stub for examples ‚Äì see PART 6 */
  generate(opts: {schema: any; count?: number; seed?: number; scenario?: any}) {
    const count = opts.count || 1;
    return Array(count).fill({});
  }
}

describe('Invariant Testing - Core Properties', () => {
  /**
   * INVARIANT 1: 100% Schema Compliance
   * Most critical for FoundryData - using AJV as oracle
   */
  it('MUST always generate 100% schema-compliant data', () => {
    const ajv = getAjv();
    const schemaArbitrary = getSchemaArbitrary();
    
    fc.assert(
      fc.property(
        schemaArbitrary,
        businessScenarioArbitrary,
        fc.integer({ min: 1, max: 1000 }),
        async (schema, scenario, count) => {
          // Arrange
          const generator = new DataGenerator();
          
          // Act - unified API: generate returns array directly
          const items = await generator.generate({
            schema,
            scenario,
            count,
          });
          
          // Assert using AJV as the source of truth
          const validate = ajv.compile(schema);
          
          for (const item of items) {
            const valid = validate(item);
            if (!valid) {
              console.error('‚ùå CRITICAL FAILURE - Schema Compliance');
              console.error('Schema:', JSON.stringify(schema, null, 2));
              console.error('Invalid item:', JSON.stringify(item, null, 2));
              console.error('Validation errors:', JSON.stringify(validate.errors, null, 2));
              console.error('Seed:', scenario.seed);
              
              throw new Error(
                `COMPLIANCE VIOLATION: Item failed validation. ` +
                `Errors: ${JSON.stringify(validate.errors)}`
              );
            }
          }
        }
      ),
      {
        numRuns: fc.readConfigureGlobal().numRuns, // Use global config
        endOnFailure: false,
        verbose: true,
      }
    );
  });
  
  /**
   * INVARIANT 2: Deterministic Generation
   * Same seed must produce identical output
   */
  it('MUST be deterministic with same seed', () => {
    const schemaArbitrary = getSchemaArbitrary();
    
    fc.assert(
      fc.property(
        schemaArbitrary,
        fc.integer({ min: 0, max: Number.MAX_SAFE_INTEGER }),
        fc.integer({ min: 1, max: 100 }),
        (schema, seed, count) => {
          const generator = new DataGenerator();
          
          // Generate 10 times with same seed
          const results = Array.from({ length: 10 }, () =>
            generator.generate({ schema, seed, count })
          );
          
          // All must be IDENTICAL
          const firstResult = JSON.stringify(results[0]);
          results.forEach((result, index) => {
            const serialized = JSON.stringify(result);
            if (serialized !== firstResult) {
              console.error(`Determinism failure at iteration ${index}`);
              console.error('Seed:', seed);
              console.error('Schema:', JSON.stringify(schema, null, 2));
              throw new Error('Determinism violated: different outputs for same seed');
            }
          });
        }
      )
    );
  });
  
  /**
   * INVARIANT 3: Data Type Consistency
   */
  it('MUST always generate correct data types', () => {
    const schemaArbitrary = getSchemaArbitrary();
    
    fc.assert(
      fc.property(
        schemaArbitrary,
        fc.integer({ min: 1, max: 100 }),
        (schema, count) => {
          const generator = new DataGenerator();
          const data = generator.generate({ schema, count });
          
          data.forEach(item => {
            validateDataTypes(item, schema);
          });
        }
      )
    );
    
    function validateDataTypes(data: any, schema: any): void {
      switch (schema.type) {
        case 'string':
          expect(typeof data).toBe('string');
          break;
        case 'number':
        case 'integer':
          expect(typeof data).toBe('number');
          if (schema.type === 'integer') {
            expect(Number.isInteger(data)).toBe(true);
          }
          break;
        case 'boolean':
          expect(typeof data).toBe('boolean');
          break;
        case 'null':
          expect(data).toBeNull();
          break;
        case 'object':
          expect(typeof data).toBe('object');
          expect(data).not.toBeNull();
          expect(Array.isArray(data)).toBe(false);
          break;
        case 'array':
          expect(Array.isArray(data)).toBe(true);
          break;
      }
    }
  });
  
  /**
   * INVARIANT 4: Boundary Respect
   */
  it('MUST respect all boundary constraints', () => {
    const schemaArbitrary = getSchemaArbitrary();
    
    fc.assert(
      fc.property(
        schemaArbitrary,
        fc.integer({ min: 1, max: 100 }),
        (schema, count) => {
          const generator = new DataGenerator();
          const data = generator.generate({ schema, count });
          
          data.forEach(item => {
            validateBoundaries(item, schema);
          });
        }
      )
    );
    
    function validateBoundaries(data: any, schema: any): void {
      // Check numeric constraints
      if (schema.type === 'number' || schema.type === 'integer') {
        if (schema.minimum !== undefined) {
          expect(data).toBeGreaterThanOrEqual(schema.minimum);
        }
        if (schema.maximum !== undefined) {
          expect(data).toBeLessThanOrEqual(schema.maximum);
        }
        if (schema.exclusiveMinimum !== undefined) {
          expect(data).toBeGreaterThan(schema.exclusiveMinimum);
        }
        if (schema.exclusiveMaximum !== undefined) {
          expect(data).toBeLessThan(schema.exclusiveMaximum);
        }
        if (schema.multipleOf !== undefined) {
          expect(data % schema.multipleOf).toBeCloseTo(0, 10);
        }
      }
      
      // Check string constraints
      if (schema.type === 'string' && typeof data === 'string') {
        if (schema.minLength !== undefined) {
          expect(data.length).toBeGreaterThanOrEqual(schema.minLength);
        }
        if (schema.maxLength !== undefined) {
          expect(data.length).toBeLessThanOrEqual(schema.maxLength);
        }
        if (schema.pattern !== undefined) {
          expect(data).toMatch(new RegExp(schema.pattern));
        }
      }
      
      // Check array constraints
      if (schema.type === 'array' && Array.isArray(data)) {
        if (schema.minItems !== undefined) {
          expect(data.length).toBeGreaterThanOrEqual(schema.minItems);
        }
        if (schema.maxItems !== undefined) {
          expect(data.length).toBeLessThanOrEqual(schema.maxItems);
        }
        if (schema.uniqueItems === true) {
          expect(data).toBeDistinct(true); // Deep comparison
        }
      }
      
      // Check object constraints
      if (schema.type === 'object' && typeof data === 'object' && data !== null) {
        const propCount = Object.keys(data).length;
        if (schema.minProperties !== undefined) {
          expect(propCount).toBeGreaterThanOrEqual(schema.minProperties);
        }
        if (schema.maxProperties !== undefined) {
          expect(propCount).toBeLessThanOrEqual(schema.maxProperties);
        }
      }
    }
  });
});

// ----------------------------------------
// test/patterns/metamorphic-testing.test.ts
// ----------------------------------------

describe('Metamorphic Testing - Relations', () => {
  /**
   * Relation 1: Schema Relaxation
   * Data valid for strict schema must be valid for relaxed schema
   */
  it('should preserve validity under schema relaxation', () => {
    const schemaArbitrary = getSchemaArbitrary();
    const draft = (process.env.SCHEMA_DRAFT as JsonSchemaDraft) || '2020-12';
    
    fc.assert(
      fc.property(
        schemaArbitrary,
        fc.integer({ min: 0, max: 1_000_000 }),
        (strictSchema, seed) => {
          const generator = new DataGenerator();
          const ajv = getAjv();
          
          // Generate with strict schema
          const strictData = generator.generate({ 
            schema: strictSchema, 
            seed 
          });
          
          // Relax the schema
          const relaxedSchema = relaxSchema(strictSchema, draft);
          
          // Strict data MUST be valid for relaxed schema
          const validate = ajv.compile(relaxedSchema);
          
          for (const item of strictData) {
            const valid = validate(item);
            if (!valid) {
              console.error('Relaxation failed');
              console.error('Strict schema:', JSON.stringify(strictSchema, null, 2));
              console.error('Relaxed schema:', JSON.stringify(relaxedSchema, null, 2));
              console.error('Data:', JSON.stringify(item, null, 2));
              console.error('Errors:', JSON.stringify(validate.errors, null, 2));
              throw new Error('Metamorphic relation violated: relaxation');
            }
          }
        }
      )
    );
    
    function relaxSchema(s: any, draft: JsonSchemaDraft): any {
      if (Array.isArray(s)) {
        return s.map(x => relaxSchema(x, draft));
      }
      
      if (s && typeof s === 'object') {
        const relaxed: any = { ...s };
        
        // Remove numeric constraints
        delete relaxed.minimum;
        delete relaxed.maximum;
        delete relaxed.exclusiveMinimum;
        delete relaxed.exclusiveMaximum;
        delete relaxed.multipleOf;
        
        // Remove string constraints
        delete relaxed.minLength;
        delete relaxed.maxLength;
        delete relaxed.pattern;
        delete relaxed.format;
        
        // Remove array constraints
        delete relaxed.minItems;
        delete relaxed.maxItems;
        delete relaxed.minContains;
        delete relaxed.maxContains;
        delete relaxed.uniqueItems;
        
        // Remove object constraints
        delete relaxed.minProperties;
        delete relaxed.maxProperties;
        
        // Remove unevaluated constraints (2019-09/2020-12)
        if (draft !== 'draft-07') {
          delete relaxed.unevaluatedItems;
          delete relaxed.unevaluatedProperties;
        }
        
        // Recursively relax nested schemas
        if (relaxed.properties) {
          relaxed.properties = Object.fromEntries(
            Object.entries(relaxed.properties).map(([k, v]) => [k, relaxSchema(v, draft)])
          );
        }
        
        // Handle items based on draft
        if (Array.isArray(relaxed.items)) {
          relaxed.items = relaxed.items.map((item: any) => relaxSchema(item, draft));
        } else if (relaxed.items) {
          relaxed.items = relaxSchema(relaxed.items, draft);
        }
        
        // Handle prefixItems for newer drafts
        if (draft !== 'draft-07' && relaxed.prefixItems) {
          relaxed.prefixItems = relaxed.prefixItems.map((item: any) => relaxSchema(item, draft));
        }
        
        // Relax combined schemas
        if (relaxed.allOf) relaxed.allOf = relaxed.allOf.map((s: any) => relaxSchema(s, draft));
        if (relaxed.anyOf) relaxed.anyOf = relaxed.anyOf.map((s: any) => relaxSchema(s, draft));
        if (relaxed.oneOf) relaxed.oneOf = relaxed.oneOf.map((s: any) => relaxSchema(s, draft));
        if (relaxed.not) relaxed.not = relaxSchema(relaxed.not, draft);
        
        // Relax conditional schemas
        if (relaxed.if) relaxed.if = relaxSchema(relaxed.if, draft);
        if (relaxed.then) relaxed.then = relaxSchema(relaxed.then, draft);
        if (relaxed.else) relaxed.else = relaxSchema(relaxed.else, draft);
        
        return relaxed;
      }
      
      return s;
    }
  });
  
  /**
   * Relation 2: Prefix Stability
   * When generating with same seed, prefix should be stable
   */
  it('should maintain prefix stability with additive generation', () => {
    const schemaArbitrary = getSchemaArbitrary();
    
    fc.assert(
      fc.property(
        schemaArbitrary,
        fc.integer({ min: 1, max: 50 }),
        fc.integer({ min: 1, max: 50 }),
        fc.integer({ min: 0, max: 1_000_000 }),
        (schema, count1, count2, seed) => {
          const generator = new DataGenerator();
          
          // Generate all at once
          const all = generator.generate({
            schema,
            count: count1 + count2,
            seed,
          });
          
          // Generate in parts
          const part1 = generator.generate({
            schema,
            count: count1,
            seed
          });

          const ajv = getAjv();
          
          // Generate with strict schema
          const strictData = generator.generate({ 
            schema: strictSchema, 
            seed 
          });
          
          // Relax the schema
          const relaxedSchema = relaxSchema(strictSchema, draft);
          
          // Strict data MUST be valid for relaxed schema
          const validate = ajv.compile(relaxedSchema);
          
          for (const item of strictData) {
            const valid = validate(item);
            if (!valid) {
              console.error('Relaxation failed');
              console.error('Strict schema:', JSON.stringify(strictSchema, null, 2));
              console.error('Relaxed schema:', JSON.stringify(relaxedSchema, null, 2));
              console.error('Data:', JSON.stringify(item, null, 2));
              console.error('Errors:', JSON.stringify(validate.errors, null, 2));
              throw new Error('Metamorphic relation violated: relaxation');
            }
          }
        }
      )
    );
    
    function relaxSchema(s: any, draft: JsonSchemaDraft): any {
      if (Array.isArray(s)) {
        return s.map(x => relaxSchema(x, draft));
      }
      
      if (s && typeof s === 'object') {
        const relaxed: any = { ...s };
        
        // Remove numeric constraints
        delete relaxed.minimum;
        delete relaxed.maximum;
        delete relaxed.exclusiveMinimum;
        delete relaxed.exclusiveMaximum;
        delete relaxed.multipleOf;
        
        // Remove string constraints
        delete relaxed.minLength;
        delete relaxed.maxLength;
        delete relaxed.pattern;
        delete relaxed.format;
        
        // Remove array constraints
        delete relaxed.minItems;
        delete relaxed.maxItems;
        delete relaxed.minContains;
        delete relaxed.maxContains;
        delete relaxed.uniqueItems;
        
        // Remove object constraints
        delete relaxed.minProperties;
        delete relaxed.maxProperties;
        
        // Remove unevaluated constraints (2019-09/2020-12)
        if (draft !== 'draft-07') {
          delete relaxed.unevaluatedItems;
          delete relaxed.unevaluatedProperties;
        }
        
        // Recursively relax nested schemas
        if (relaxed.properties) {
          relaxed.properties = Object.fromEntries(
            Object.entries(relaxed.properties).map(([k, v]) => [k, relaxSchema(v, draft)])
          );
        }
        
        // Handle items based on draft
        if (Array.isArray(relaxed.items)) {
          relaxed.items = relaxed.items.map((item: any) => relaxSchema(item, draft));
        } else if (relaxed.items) {
          relaxed.items = relaxSchema(relaxed.items, draft);
        }
        
        // Handle prefixItems for newer drafts
        if (draft !== 'draft-07' && relaxed.prefixItems) {
          relaxed.prefixItems = relaxed.prefixItems.map((item: any) => relaxSchema(item, draft));
        }
        
        // Relax combined schemas
        if (relaxed.allOf) relaxed.allOf = relaxed.allOf.map((s: any) => relaxSchema(s, draft));
        if (relaxed.anyOf) relaxed.anyOf = relaxed.anyOf.map((s: any) => relaxSchema(s, draft));
        if (relaxed.oneOf) relaxed.oneOf = relaxed.oneOf.map((s: any) => relaxSchema(s, draft));
        if (relaxed.not) relaxed.not = relaxSchema(relaxed.not, draft);
        
        // Relax conditional schemas
        if (relaxed.if) relaxed.if = relaxSchema(relaxed.if, draft);
        if (relaxed.then) relaxed.then = relaxSchema(relaxed.then, draft);
        if (relaxed.else) relaxed.else = relaxSchema(relaxed.else, draft);
        
        return relaxed;
      }
      
      return s;
    }
  });
  
  /**
   * Relation 2: Prefix Stability
   * When generating with same seed, prefix should be stable
   */
  it('should maintain prefix stability with additive generation', () => {
    const schemaArbitrary = getSchemaArbitrary();
    
    fc.assert(
      fc.property(
        schemaArbitrary,
        fc.integer({ min: 1, max: 50 }),
        fc.integer({ min: 1, max: 50 }),
        fc.integer({ min: 0, max: 1_000_000 }),
        (schema, count1, count2, seed) => {
          const generator = new DataGenerator();
          
          // Generate all at once
          const all = generator.generate({
            schema,
            count: count1 + count2,
            seed,
          });
          
          // Generate in parts
          const part1 = generator.generate({
            schema,
            count: count1,
            seed,
          });
          
          // The prefix should match
          for (let i = 0; i < count1; i++) {
            const allItem = JSON.stringify(all[i]);
            const part1Item = JSON.stringify(part1[i]);
            
            if (allItem !== part1Item) {
              console.error(`Prefix mismatch at index ${i}`);
              console.error('Seed:', seed);
              throw new Error('Metamorphic relation violated: prefix stability');
            }
          }
        }
      )
    );
  });
});

// ----------------------------------------
// test/patterns/stateful-testing.test.ts  
// ----------------------------------------

describe('Stateful Property Testing', () => {
  type SystemState = {
    cache: Map<string, any>;
    metrics: {
      generated: number;
      validated: number;
      cached: number;
      errors: number;
    };
    scenario: string;
    schemas: Map<string, any>;
  };
  
  type Command = 
    | { type: 'generate'; schema: any; count: number; seed?: number }
    | { type: 'validate'; data: any; schema: any }
    | { type: 'clearCache' }
    | { type: 'setScenario'; scenario: any }
    | { type: 'compileSchema'; schema: any }
    | { type: 'reset' };
  
  const commandArbitrary: fc.Arbitrary<Command> = fc.oneof(
    fc.record({
      type: fc.constant('generate' as const),
      schema: simpleSchemaArbitrary,
      count: fc.integer({ min: 1, max: 100 }),
      seed: fc.option(fc.integer({ min: 0, max: 1_000_000 }), { nil: undefined }),
    }),
    fc.record({
      type: fc.constant('validate' as const),
      data: fc.jsonValue(),
      schema: simpleSchemaArbitrary,
    }),
    fc.record({
      type: fc.constant('clearCache' as const),
    }),
    fc.record({
      type: fc.constant('setScenario' as const),
      scenario: businessScenarioArbitrary,
    }),
    fc.record({
      type: fc.constant('compileSchema' as const),
      schema: simpleSchemaArbitrary,
    }),
    fc.record({
      type: fc.constant('reset' as const),
    }),
  );
  
  it('should maintain state consistency across operations', () => {
    fc.assert(
      fc.property(
        fc.array(commandArbitrary, { minLength: 10, maxLength: 100 }),
        (commands) => {
          const system = new DataGeneratorSystem();
          const state: SystemState = {
            cache: new Map(),
            metrics: {
              generated: 0,
              validated: 0,
              cached: 0,
              errors: 0,
            },
            scenario: 'normal',
            schemas: new Map(),
          };
          
          commands.forEach((cmd, index) => {
            const before = { ...state.metrics };
            
            try {
              switch (cmd.type) {
                case 'generate': {
                  const result = system.generate(cmd.schema, cmd.count, cmd.seed);
                  
                  // Update state
                  state.metrics.generated += cmd.count;
                  const schemaKey = JSON.stringify(cmd.schema);
                  if (!state.cache.has(schemaKey)) {
                    state.cache.set(schemaKey, true);
                    state.metrics.cached++;
                  }
                  
                  // Invariants
                  expect(result.length).toBe(cmd.count);
                  expect(system.getMetrics().generated).toBe(state.metrics.generated);
                  break;
                }
                
                case 'validate': {
                  const isValid = system.validate(cmd.data, cmd.schema);
                  state.metrics.validated++;
                  
                  // Invariants
                  expect(typeof isValid).toBe('boolean');
                  expect(system.getMetrics().validated).toBe(state.metrics.validated);
                  break;
                }
                
                case 'clearCache': {
                  system.clearCache();
                  state.cache.clear();
                  state.metrics.cached = 0;
                  
                  // Invariants
                  expect(system.getCacheSize()).toBe(0);
                  expect(state.cache.size).toBe(0);
                  break;
                }
                
                case 'setScenario': {
                  system.setScenario(cmd.scenario);
                  state.scenario = cmd.scenario.scenario;
                  
                  // Invariants
                  expect(system.getCurrentScenario()).toBe(state.scenario);
                  break;
                }
                
                case 'compileSchema': {
                  system.compileSchema(cmd.schema);
                  const schemaKey = JSON.stringify(cmd.schema);
                  state.schemas.set(schemaKey, cmd.schema);
                  
                  // Invariants
                  expect(system.hasCompiledSchema(cmd.schema)).toBe(true);
                  break;
                }
                
                case 'reset': {
                  system.reset();
                  state.cache.clear();
                  state.schemas.clear();
                  state.metrics = {
                    generated: 0,
                    validated: 0,
                    cached: 0,
                    errors: 0,
                  };
                  state.scenario = 'normal';
                  
                  // Invariants
                  expect(system.getMetrics()).toEqual(state.metrics);
                  expect(system.getCurrentScenario()).toBe('normal');
                  break;
                }
              }
            } catch (error) {
              state.metrics.errors++;
              
              // Errors must be handled properly
              expect(error).toBeInstanceOf(Error);
            }
            
            // Global invariants after each command
            expect(system.getCacheSize()).toBeLessThanOrEqual(100); // Cache limit
            expect(state.metrics.generated).toBeGreaterThanOrEqual(0);
            expect(state.metrics.validated).toBeGreaterThanOrEqual(0);
            expect(state.metrics.errors).toBeGreaterThanOrEqual(0);
          });
        }
      )
    );
  });
});

// ================================================================================
// PART 5: PERFORMANCE TESTS
// ================================================================================

// ----------------------------------------
// test/performance/benchmarks.test.ts
// ----------------------------------------

import { describe, it, expect, beforeEach } from 'vitest';
import { performance } from 'node:perf_hooks';

describe('Performance Benchmarks', () => {
  const benchmarks = {
    simple: {
      schema: { type: 'string' },
      targetMs: 0.5,      // More realistic target
      tolerance: 0.5,     // 50% tolerance
    },
    medium: {
      schema: {
        type: 'object',
        properties: {
          id: { type: 'string', format: 'uuid' },
          name: { type: 'string', minLength: 1, maxLength: 100 },
          age: { type: 'number', minimum: 0, maximum: 120 },
          email: { type: 'string', format: 'email' },
        },
        required: ['id', 'name'],
      },
      targetMs: 2,        // More realistic target
      tolerance: 0.5,
    },
    complex: {
      schema: {
        type: 'object',
        properties: {
          users: {
            type: 'array',
            items: {
              type: 'object',
              properties: {
                id: { type: 'string', format: 'uuid' },
                profile: {
                  type: 'object',
                  properties: {
                    firstName: { type: 'string' },
                    lastName: { type: 'string' },
                    email: { type: 'string', format: 'email' },
                    age: { type: 'number', minimum: 0 },
                    address: {
                      type: 'object',
                      properties: {
                        street: { type: 'string' },
                        city: { type: 'string' },
                        zipCode: { type: 'string', pattern: '^[0-9]{5}$' },
                      },
                    },
                  },
                },
                permissions: {
                  type: 'array',
                  items: { type: 'string' },
                },
              },
            },
            minItems: 10,
            maxItems: 100,
          },
        },
      },
      targetMs: 20,       // More realistic target
      tolerance: 0.5,
    },
  };
  
  Object.entries(benchmarks).forEach(([level, benchmark]) => {
    it(`should meet ${level} performance targets (p95)`, () => {
      fc.assert(
        fc.property(
          fc.integer({ min: 100, max: 1000 }),
          (count) => {
            const generator = new DataGenerator();
            
            // Warmup
            generator.generate({ schema: benchmark.schema, count: 10 });
            
            // Measure multiple times
            const measurements = [];
            for (let i = 0; i < 10; i++) {
              const start = performance.now();
              const data = generator.generate({ 
                schema: benchmark.schema, 
                count 
              });
              const duration = performance.now() - start;
              measurements.push(duration / count);
              
              // Validation
              expect(data.length).toBe(count);
            }
            
            // Calculate percentiles
            measurements.sort((a, b) => a - b);
            const p50 = measurements[Math.floor(measurements.length * 0.5)];
            const p95 = measurements[Math.floor(measurements.length * 0.95)];
            
            // Assert on p95 (more stable than average)
            expect(p95).toBeLessThan(benchmark.targetMs * (1 + benchmark.tolerance));
            
            // Log if requested
            if (process.env.PERF_LOG) {
              console.log(`[PERF] ${level}:`);
              console.log(`  P50: ${p50.toFixed(3)}ms/item`);
              console.log(`  P95: ${p95.toFixed(3)}ms/item`);
              console.log(`  Target: <${benchmark.targetMs}ms/item`);
            }
          }
        ),
        { numRuns: 3 } // Few runs for perf tests
      );
    });
  });
  
  it('should handle memory efficiently', () => {
    const generator = new DataGenerator();
    const schema = benchmarks.complex.schema;
    
    // Initial measurement
    if (global.gc) global.gc();
    const memBefore = process.memoryUsage().heapUsed;
    
    // Generate and release
    const iterations = 10;
    for (let i = 0; i < iterations; i++) {
      const data = generator.generate({ schema, count: 1000 });
      // Force serialization to simulate real usage
      JSON.stringify(data).length;
    }
    
    // Final measurement
    if (global.gc) global.gc();
    const memAfter = process.memoryUsage().heapUsed;
    
    // Memory should not explode (max 100MB difference for safety)
    const memDiff = (memAfter - memBefore) / 1024 / 1024;
    expect(memDiff).toBeLessThan(100);
    
    if (process.env.PERF_LOG) {
      console.log(`[MEMORY] Difference: ${memDiff.toFixed(2)}MB`);
    }
  });
});

// ================================================================================
// PART 6: IMPLEMENTATION STUBS & CLASSES
// ================================================================================

// ----------------------------------------
// Production Classes (to implement)
// ----------------------------------------

/**
 * Main data generator
 */
class DataGenerator {
  private cache = new Map<string, any>();
  private metrics = {
    generated: 0,
    validated: 0,
  };
  private scenario = 'normal';
  
  generate(options: {
    schema: any;
    count?: number;
    seed?: number;
    scenario?: any;
  }): any[] {
    const count = options.count || 1;
    this.metrics.generated += count;
    
    // TODO: Implement actual generation with deterministic RNG
    // MUST use seed for determinism
    return Array(count).fill({});
  }
  
  async generateAsync(options: any): Promise<any[]> {
    return this.generate(options);
  }
  
  compileSchema(schema: any): void {
    const key = JSON.stringify(schema);
    this.cache.set(key, schema);
  }
  
  hasCompiledSchema(schema: any): boolean {
    const key = JSON.stringify(schema);
    return this.cache.has(key);
  }
  
  validate(data: any, schema: any): boolean {
    this.metrics.validated++;
    const ajv = getAjv();
    const validate = ajv.compile(schema);
    return validate(data);
  }
  
  clearCache(): void {
    this.cache.clear();
  }
  
  getCacheSize(): number {
    return this.cache.size;
  }
  
  setScenario(scenario: any): void {
    this.scenario = scenario.scenario;
  }
  
  getCurrentScenario(): string {
    return this.scenario;
  }
  
  getMetrics() {
    return { ...this.metrics };
  }
  
  reset(): void {
    this.cache.clear();
    this.metrics = { generated: 0, validated: 0 };
    this.scenario = 'normal';
  }
}

/**
 * Generation system for stateful tests
 */
class DataGeneratorSystem extends DataGenerator {
  // Extension for stateful tests
  generate(schema: any, count: number, seed?: number): any[] {
    return super.generate({ schema, count, seed });
  }
}

/**
 * Helper for structure validation
 */
function validateStructure(data: any[], schema: any): boolean {
  const ajv = getAjv();
  const validate = ajv.compile(schema);
  return data.every(item => validate(item));
}

// ================================================================================
// FINAL EXPORT
// ================================================================================

export {
  // Configurations
  customMatchers,
  
  // AJV Factory
  createAjv,
  getAjv,
  
  // Arbitraries
  jsonSchemaArbitraryFor,
  simpleSchemaArbitrary,
  businessScenarioArbitrary,
  getSchemaArbitrary,
  
  // Classes
  DataGenerator,
  DataGeneratorSystem,
  
  // Helpers
  validateStructure,
}
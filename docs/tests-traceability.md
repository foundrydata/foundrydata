# Tests Traceability Matrix — Coverage & Advanced JSON Schema Constructs

This document links **coverage-aware features** and **JSON Schema motifs** to the
micro‑schemas and tests that exercise them, plus the invariants each test enforces.

The goal is to:

- avoid ad‑hoc scenarios,
- keep a clear mapping SPEC → motif → micro‑schema → tests → invariants,
- and make it easy to see which motifs are still under‑tested.

---

## Legend

- **Motif**: JSON Schema / coverage-aware feature or combination.
- **Micro‑schema**: where the minimal schema for this motif lives (inline or file).
- **Tests**: test files (and, when useful, test names) that cover the motif.
- **Invariants**: properties the tests assert (pipeline, coverage, diagnostics).

Paths are relative to the repository root.

---

## Core coverage instrumentation (branches, enums, properties, boundaries)

| Motif / Feature                          | SPEC anchors                                        | Micro‑schema location                                            | Tests                                                                                   | Invariants                                                                                      |
|-----------------------------------------|-----------------------------------------------------|-------------------------------------------------------------------|-----------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------|
| `ONEOF_BRANCH` coverage events          | cov://§3#coverage-model                             | Inline `oneOf` schema in `coverage-branches-enum.test.ts:14`     | `packages/core/src/generator/__tests__/coverage-branches-enum.test.ts` (ONEOF_BRANCH)  | Generator emits ONEOF_BRANCH events with `dimension: 'branches'` and correct `canonPath`.       |
| `ANYOF_BRANCH` coverage events          | cov://§3#coverage-model                             | Inline `anyOf` schema in `coverage-branches-enum.test.ts:32`     | `coverage-branches-enum.test.ts` (ANYOF_BRANCH)                                         | Generator emits ANYOF_BRANCH events with `dimension: 'branches'` and correct `canonPath`.       |
| `CONDITIONAL_PATH` (if/then/else)       | cov://§3#coverage-model                             | Inline `if/then/else` schema in `coverage-branches-enum.test.ts` | `coverage-branches-enum.test.ts` (CONDITIONAL_PATH)                                     | Generator emits CONDITIONAL_PATH events with `dimension: 'branches'` and `canonPath === '#'`.   |
| `ENUM_VALUE_HIT`                        | cov://§3#coverage-model                             | Inline enum schema in `coverage-branches-enum.test.ts`           | `coverage-branches-enum.test.ts` (ENUM_VALUE_HIT)                                       | Enum events carry `dimension: 'enum'`, `canonPath` and `{ enumIndex, value }` consistent.       |
| `PROPERTY_PRESENT` on optionals         | cov://§3#coverage-model                             | Inline object schema in `coverage-branches-enum.test.ts`         | `coverage-branches-enum.test.ts` (PROPERTY_PRESENT)                                     | Optional properties produce PROPERTY_PRESENT events with `dimension: 'structure'`.              |
| Boundaries instrumentation              | cov://§3#coverage-model                             | Inline object schema in `coverage-branches-enum.test.ts`         | `coverage-branches-enum.test.ts` (boundaries events)                                    | Generator emits NUMERIC\_, STRING\_, ARRAY\_ boundary events on expected `canonPath`s.          |

---

## Analyzer / CoverageGraph targets (structure, AP:false, branches, enums, boundaries)

| Motif / Feature                                      | SPEC anchors                                                | Micro‑schema location                                                          | Tests                                                                                   | Invariants                                                                                                      |
|-----------------------------------------------------|-------------------------------------------------------------|-------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------|
| SCHEMA_NODE / PROPERTY_PRESENT (simple object)      | cov://§3#coverage-model                                     | Inline object schema in `analyzer.test.ts`                                    | `packages/core/src/coverage/__tests__/analyzer.test.ts` (“builds schema and property…”) | Analyzer builds SCHEMA_NODE / PROPERTY_PRESENT targets with correct `canonPath`s and graph edges.               |
| AP:false + CoverageIndex.enumerate / has            | spec://§8-coverage-index-enumerate, spec://§8-coverage-index-export | Inline schema + CoverageIndex stub in `analyzer.test.ts`                     | `analyzer.test.ts` (“materializes PROPERTY_PRESENT for AP:false…”, related tests)       | PROPERTY_PRESENT for AP:false only for names that CoverageIndex reports as generable; ignored otherwise.        |
| Basic branches (oneOf/anyOf/if/then)                | cov://§3#coverage-model                                     | Inline schema in `analyzer.test.ts` (“classifies oneOf/anyOf…”)              | `analyzer.test.ts` (“classifies oneOf/anyOf and conditional branches as branch nodes”)  | Branch nodes appear in graph; branch targets include ONEOF_BRANCH, ANYOF_BRANCH, CONDITIONAL_PATH kinds.        |
| Boundaries targets (numeric/string/array)           | cov://§3#coverage-model                                     | Inline schema in `analyzer.test.ts` (“materializes boundaries targets…”)     | `analyzer.test.ts` (boundaries tests)                                                   | Analyzer materializes NUMERIC\_, STRING\_, ARRAY\_ boundaries when `dimensionsEnabled` includes `boundaries`.   |
| Enum targets on large enums                         | cov://§3#coverage-model                                     | Inline enum schema in `analyzer.test.ts`                                      | `analyzer.test.ts` (“is deterministic for enum targets on larger enums”)               | Deterministic set of ENUM_VALUE_HIT targets for a fixed enum list.                                              |
| Dimensions gating (`dimensionsEnabled`)             | cov://§3#coverage-model                                     | Inline schema in `analyzer.test.ts`                                           | `analyzer.test.ts` (“respects dimensionsEnabled when materializing targets”)           | Enabling/disabling dimensions changes targets only by dimension, not IDs for enabled ones.                       |

---

## Advanced constructs — structural visibility (analyzer) 

| Motif / Feature                                      | SPEC anchors                                                                | Micro‑schema location                                                                                 | Tests                                                                                                   | Invariants                                                                                                                    |
|-----------------------------------------------------|-----------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------|
| Arrays with `contains`, `prefixItems`, `unevaluatedItems` | spec://§9-arrays-contains, spec://§9-generator                               | Inline object schema in `analyzer.test.ts` (“exposes SCHEMA_NODE targets for advanced array constructs…”) | `analyzer.test.ts` (advanced arrays test)                                                              | SCHEMA_NODE targets exist for `#/properties/items`, `/contains`, `/statusHistory/prefixItems/*`, `/auditTrail/unevaluatedItems`. |
| `patternProperties` + `additionalProperties:false` + `unevaluatedProperties` | spec://§7-object-keywords-pnames-rewrite, spec://§8-apfalse-must-cover      | Inline object schema in `analyzer.test.ts` (“exposes SCHEMA_NODE targets for objects with patternProperties…”) | `analyzer.test.ts` (patternProperties + unevaluatedProperties test)                                    | SCHEMA_NODE targets exist for `customAttributes`, its `patternProperties` entry, `extensions`, and its `unevaluatedProperties`. |
| `dependentRequired` (customer.loyaltyTier → loyaltyPoints) | spec://§7-conditionals-rewrite, spec://§7-dependencies-guard                | Inline object schema in `analyzer.test.ts` (“exposes SCHEMA_NODE targets for dependentRequired…”)        | `analyzer.test.ts` (dependentRequired/dependentSchemas/not test)                                       | SCHEMA_NODE target exists at `#/properties/customer/dependentRequired/loyaltyTier`.                                        |
| `dependentSchemas` (shipping.carrier → pickupPoint)      | spec://§7-conditionals-rewrite, spec://§7-dependencies-guard                | Same inline schema as above                                                                          | `analyzer.test.ts` (dependentRequired/dependentSchemas/not test)                                       | SCHEMA_NODE target exists at `#/properties/shipping/dependentSchemas/carrier`.                                              |
| `not` + `allOf` negative constraint                      | spec://§8-allof-merge, spec://§4-fail-early                               | Same inline schema as above                                                                          | `analyzer.test.ts` (dependentRequired/dependentSchemas/not test)                                       | SCHEMA_NODE target exists at `#/allOf/1/not`.                                                                               |

---

## Operations dimension & OpenAPI coverage

| Motif / Feature                                      | SPEC anchors                                                                | Micro‑schema location                                                          | Tests                                                                                                   | Invariants                                                                                                                      |
|-----------------------------------------------------|-----------------------------------------------------------------------------|-------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------|
| Operation graph nodes & OP_* targets (OpenAPI)      | cov://§3#coverage-model, cov://§3#coverage-by-operation                      | Inline OpenAPI-style docs in `coverage-analyzer-openapi.spec.ts`              | `packages/core/src/coverage/__tests__/coverage-analyzer-openapi.spec.ts`                               | Analyzer crée des `operation` nodes, edges `role=request/response` et des cibles `OP_REQUEST_COVERED` / `OP_RESPONSE_COVERED` avec `operationKey` cohérent. |
| Operations dimension gating                         | cov://§3#coverage-model                                                     | Inline OpenAPI schema in `coverage-analyzer-openapi.spec.ts`                  | `coverage-analyzer-openapi.spec.ts` (“only materializes operations-dimension targets when…”)           | Aucun target `dimension: 'operations'` lorsque la dimension `operations` est désactivée; cibles présentes quand elle est activée. |
| SCHEMA_REUSED_COVERED diagnostic-only targets       | cov://§3#coverage-model, cov://§3#diagnostic-only-targets                   | Inline OpenAPI schema with shared component in `coverage-analyzer-openapi.spec.ts` | `coverage-analyzer-openapi.spec.ts` (“emits SCHEMA_REUSED_COVERED targets as diagnostic-only…”)        | `SCHEMA_REUSED_COVERED` cibles `dimension: 'operations'` restent `status:'deprecated'` et attachent `meta.operationKeys` sans impacter les métriques.       |
| OpenAPI coverage by operation (e2e)                 | cov://§3#coverage-model, cov://§3#coverage-by-operation, cov://§6#execution-modes-ux | Inline `openApiAcceptanceDoc` in `coverage-openapi-acceptance.spec.ts`        | `packages/core/test/e2e/coverage-openapi-acceptance.spec.ts`                                           | `metrics.byOperation` expose des clés stables (`operationId` ou `\"<METHOD> <path>\"`) et des ratios [0,1] cohérents measure/guided; cibles OP_* présentes. |
| OpenAPI coverage determinism                        | cov://§3#coverage-model, cov://§6#execution-modes-ux                        | `openApiAcceptanceDoc` in `coverage-openapi-acceptance.spec.ts`               | `coverage-openapi-acceptance.spec.ts` (“produces reproducible coverage reports for identical OpenAPI runs”) | Répéter deux runs identiques sur un même document OpenAPI produit des coverage-report/v1 normalisés identiques (targets, uncoveredTargets, diagnostics).   |

---

## Unreachable analysis & UNSAT propagation

| Motif / Feature                                      | SPEC anchors                                                | Micro‑schema location                                                          | Tests                                                                                                   | Invariants                                                                                                           |
|-----------------------------------------------------|-------------------------------------------------------------|-------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------|
| Strong UNSAT path set from Compose diagnostics      | spec://§8-apfalse-summary, spec://§8-coverage-index-export  | Inline ComposeDiagnostics in `coverage-analyzer-unreachable.test.ts`          | `packages/core/src/coverage/__tests__/coverage-analyzer-unreachable.test.ts` (`buildUnsatPathSet`)     | Seuls les codes UNSAT/guardrails “forts” contribuent à l’ensemble des canonPath UNSAT; les hints faibles/non-provables sont ignorés. |
| Marking targets as `unreachable` from UNSAT paths   | cov://§3#coverage-model                                    | Inline targets + diagnostics in `coverage-analyzer-unreachable.test.ts`       | `coverage-analyzer-unreachable.test.ts` (`applyUnreachableStatusToTargets`)                           | Les cibles sous un canonPath UNSAT ou imbriquées sont marquées `status:'unreachable'`; les autres restent inchangées.             |
| Preserving diagnostic-only targets under UNSAT      | cov://§3#diagnostic-only-targets                           | Inline SCHEMA_REUSED_COVERED target in `coverage-analyzer-unreachable.test.ts` | `coverage-analyzer-unreachable.test.ts` (SCHEMA_REUSED_COVERED conflict metadata test)                | Les cibles `SCHEMA_REUSED_COVERED` restent `status:'deprecated'` mais enrichissent `meta` avec les informations de conflit.        |

---

## Planner configuration, hints & caps

| Motif / Feature                                      | SPEC anchors                                                | Micro‑schema location                                                                   | Tests                                                                                                     | Invariants                                                                                                                             |
|-----------------------------------------------------|-------------------------------------------------------------|----------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------|
| Planner config resolution (budget, dimensions)      | cov://§4#coverage-planner, cov://§6#budget-profiles         | Inline options in `coverage-planner.test.ts`                                           | `packages/core/src/coverage/__tests__/coverage-planner.test.ts` (`resolveCoveragePlannerConfig`)         | `maxInstances`/softTimeMs` validés; `dimensionsEnabled`/`dimensionPriority` normalisés selon les defaults planner.                    |
| Coverage hint type validation (`isCoverageHint`)    | cov://§5#hints-interaction-with-repair                      | Inline hint objects in `coverage-planner.test.ts`                                      | `coverage-planner.test.ts` (`isCoverageHint`)                                                            | Seules les hints bien formées (kind+canonPath+params) sont acceptées comme CoverageHint; les structures invalides sont rejetées.       |
| Hint priority & conflict resolution                 | cov://§5#priority-conflict-resolution                       | Inline hints in `coverage-planner.test.ts`                                            | `coverage-planner.test.ts` (hint priority/conflict tests)                                               | L’ordre global `coverEnumValue > preferBranch > ensurePropertyPresence` est respecté, avec “premier wins” sur les tuples identiques.   |
| TestUnit planning & hint attachment                 | cov://§4#coverage-planner                                   | Inline targets in `coverage-planner.test.ts`                                           | `coverage-planner.test.ts` (`planTestUnits`, PROPERTY_PRESENT/branches tests)                            | Les TestUnits respectent `maxInstances`, l’ordre de priorité des dimensions, et attachent/omettent les hints en fonction des caps/dimensions. |
| Planner caps & conflicting hints (caps)             | cov://§4#coverage-planner                                   | Inline caps config in `coverage-planner-caps.test.ts`                                  | `packages/core/src/coverage/__tests__/coverage-planner-caps.test.ts`                                     | Les caps planner produisent des `unsatisfiedHints`/`plannerCapsHit` cohérents et ne violent pas les invariants de non‑régression coverage.   |

---

## Coverage runtime helper

| Motif / Feature                                      | SPEC anchors                                                | Micro‑schema location                                                          | Tests                                                                                                   | Invariants                                                                                                           |
|-----------------------------------------------------|-------------------------------------------------------------|-------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------|
| Gating Analyzer/Planner by coverage.mode            | cov://§3#coverage-model, cov://§6#execution-modes-ux        | Inline options in `coverage-runtime.test.ts`                                 | `packages/core/src/coverage/__tests__/coverage-runtime.test.ts` (`shouldRunCoverageAnalyzer`)          | Analyzer/Planner ne s’exécutent que pour `coverage=measure|guided`, jamais pour `off` ou si coverage est absent.                           |
| Resolving coverage dimensions defaults              | cov://§3#coverage-model                                     | Inline dimensions in `coverage-runtime.test.ts`                               | `coverage-runtime.test.ts` (`resolveCoverageDimensions`)                                               | `dimensionsEnabled` explicites sont préservées; en l’absence de flag, les defaults planner sont utilisés.                             |
| Planner determinism via runtime helper              | cov://§3#coverage-model, cov://§4#coverage-planner          | Inline object schema in `coverage-runtime.test.ts`                            | `coverage-runtime.test.ts` (`planCoverageForPipeline` determinism test)                                | Deux appels à `planCoverageForPipeline` avec les mêmes inputs produisent les mêmes TestUnits/seeds et diagnostics.                      |
| Coverage evaluation & report building               | cov://§3#coverage-model, cov://§7#json-coverage-report      | Inline targets in `coverage-runtime.test.ts`                                   | `coverage-runtime.test.ts` (`evaluateCoverageAndBuildReport`)                                          | `evaluateCoverageAndBuildReport` produit un coverage-report/v1 cohérent (version, run, metrics, uncoveredTargets) et respecte minCoverage/excludeUnreachable. |

---

## Coverage diff & thresholds (core)

| Motif / Feature                                      | SPEC anchors                                                                | Micro‑schema location                                                          | Tests                                                                                                   | Invariants                                                                                                                        |
|-----------------------------------------------------|-----------------------------------------------------------------------------|-------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------|
| Target-level diff classification                    | cov://§3#coverage-model, cov://§7#json-coverage-report                      | Inline makeReport/makeTarget helpers in `coverage-diff.spec.ts`               | `packages/core/src/coverage/__tests__/coverage-diff.spec.ts` (diffCoverageTargets tests)              | Les cibles sont classées en `unchanged`/`added`/`removed`/`statusChanged`; `newlyUncovered` reflète correctement les régressions/ajouts uncovered. |
| Report-level coverage diff (overall/byOperation)    | cov://§7#json-coverage-report, cov://§7#thresholds-mincoverage              | Same helpers in `coverage-diff.spec.ts`                                       | `coverage-diff.spec.ts` (diffCoverageReports tests)                                                    | Les deltas de couverture (overall/byOperation) sont calculés sur l’univers commun; les dimensions nouvellement activées restent hors des deltas. |
| Diff compatibility checks                            | cov://§7#json-coverage-report                                               | Same helpers in `coverage-diff.spec.ts`                                       | `coverage-diff.spec.ts` (checkCoverageDiffCompatibility tests)                                        | `checkCoverageDiffCompatibility` signale les incompatibilités de version, engine major, scope d’opérations et les cases compatibles attendues.  |

---

## Coverage-report/v1 JSON structure

| Motif / Feature                                      | SPEC anchors                                                | Micro‑schema location                                                          | Tests                                                                                                   | Invariants                                                                                                           |
|-----------------------------------------------------|-------------------------------------------------------------|-------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------|
| coverage-report/v1 snapshot & schema validation     | cov://§7#json-coverage-report                               | Inline simple schemas in `coverage-report-json.test.ts`; reporter schema fixture | `packages/core/src/coverage/__tests__/coverage-report-json.test.ts`, `packages/reporter/test/coverage-report-schema.test.ts` | coverage-report/v1 conserve une structure stable (version, engine, run, metrics, targetsByStatus) et valide contre la JSON Schema officielle. |
| dimensionsEnabled defaults & reportMode semantics   | cov://§3#coverage-model, cov://§7#json-coverage-report      | Inline schemas in `coverage-report-json.test.ts`                                | `coverage-report-json.test.ts` (dimensionsEnabled default + summary mode tests)                       | En absence de dimensionsEnabled explicite, les defaults planner sont utilisés; `reportMode: 'summary'` supprime `targets` tout en conservant les métriques. |
| excludeUnreachable semantics & thresholds           | cov://§3#coverage-model, cov://§7#thresholds-mincoverage    | Inline object schema in `coverage-report-json.test.ts`                          | `coverage-report-json.test.ts` (excludeUnreachable test)                                               | `excludeUnreachable` n’affecte que les dénominateurs; les IDs/statuts restent stables, et `thresholds.overall` reflète `minCoverage`.        |
| minCoverage / coverageStatus wiring                 | cov://§7#thresholds-mincoverage                             | Inline oneOf schema in `coverage-report-json.test.ts`                           | `coverage-report-json.test.ts` (“reports coverageStatus minCoverageNotMet…”)                          | Lorsque `overall < minCoverage`, `coverageStatus` passe à `minCoverageNotMet` et `thresholds.overall` est renseigné avec la valeur demandée. |

---

## Reporter — bench, diff & snapshots

| Motif / Feature                                      | SPEC anchors                                                                | Micro‑schema location                                                          | Tests                                                                                                   | Invariants                                                                                                           |
|-----------------------------------------------------|-----------------------------------------------------------------------------|-------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------|
| Bench runner executes configs & writes reports       | spec://§1-acceptance, spec://§6-high-level-architecture                     | `bench.config.smoke.json` in `packages/reporter/test/fixtures`                 | `packages/reporter/test/bench.runner.test.ts`                                                         | `runBench` exécute les schémas de la config, produit un `bench-summary.json` et des `*.report.json`, marque les entrées `blocked` avec error. |
| Reporter diff on coverage-report/v1                  | cov://§7#json-coverage-report                                               | Inline makeReport helpers in `packages/reporter/test/coverage-diff.test.ts`    | `packages/reporter/test/coverage-diff.test.ts`                                                        | Le diff reporter classe correctement les cibles (unchanged/added/removed/statusChanged) et calcule `newlyUncovered` comme dans le core.       |
| coverage-report/v1 schema validation (reporter view) | cov://§7#json-coverage-report                                               | `coverage-report-v1.schema.json` + `fixtures/coverage-report.v1.sample.json`   | `packages/reporter/test/coverage-report-schema.test.ts`                                               | La JSON Schema publique de coverage-report/v1 valide un rapport représentatif; Ajv ne remonte aucune erreur.                                |
| Reporter JSON/Markdown/HTML snapshots               | spec://§6-high-level-architecture, cov://§7#json-coverage-report            | `profiles/simple.json` (reporter schema fixture)                               | `packages/reporter/test/reporter.snapshot.test.ts`                                                    | Le `Report` JSON et les rendus Markdown/HTML sont stables (timestamp/path normalisés), ce qui protège la forme de la surface reporter.        |
| Reporter integration on ecommerce-complex            | cov://§3#coverage-model, cov://§7#json-coverage-report                       | `examples/ecommerce-complex-schema.json`                                       | `packages/reporter/test/ecommerce-complex-report.test.ts`                                             | `runEngineOnSchema` fonctionne sur un schéma complexe, produit un Report avec `totalInstances > 0`, un coverageIndexSnapshot et des cibles enum pour `status` et `source.channel`. |

## Coverage-aware pipeline invariants (off / measure / guided)

| Motif / Feature                              | SPEC anchors                                                | Micro‑schema location                                                                     | Tests                                                                                                     | Invariants                                                                                                                        |
|---------------------------------------------|-------------------------------------------------------------|------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------|
| coverage=off vs coverage=measure (simple)   | cov://§3#coverage-model, cov://§6#execution-modes-ux        | Inline simple object schema in `coverage-acceptance.spec.ts`                             | `packages/core/test/e2e/coverage-acceptance.spec.ts` (“keeps final items deterministic… simple object”)   | coverage=measure is a pure observation layer: final items identical à coverage=off.                                              |
| coverage=off vs coverage=measure (AP:false) | spec://§8-apfalse-summary, cov://§3#coverage-model          | Inline AP:false schema in `coverage-acceptance.spec.ts`                                  | `coverage-acceptance.spec.ts` (“keeps final items deterministic… AP:false-heavy schema”)                  | Même invariant de déterminisme sous AP:false; aucune divergence d’items entre off et measure.                                     |
| Guided ≥ Measure (branches/enum, jouet)     | cov://§3#coverage-model, cov://§4#coverage-planner          | `schemaWithOneOfAndEnum` in `coverage-guided-planner.spec.ts`                            | `packages/core/test/e2e/coverage-guided-planner.spec.ts` (premiers 2 tests)                              | Pour ce schéma, guided ne fait jamais moins bien que measure sur `branches` et `enum`.                                            |
| Guided ≥ Measure (oneOf acceptance)         | cov://§3#coverage-model, cov://§4#coverage-planner          | `oneOfAcceptanceSchema` in `coverage-acceptance.spec.ts`                                 | `coverage-acceptance.spec.ts` (“keeps branches coverage in guided >= measure… three-branch oneOf”)       | Guided ≥ measure sur `branches`; `ONEOF_BRANCH` targets présents et correctement marqués hit/uncovered.                           |
| Guided ≥ Measure (AP:false CoverageIndex)   | spec://§8-coverage-index-export, cov://§3#coverage-model    | `dependentAllOfCoverageSchema`, `propertyNamesRewriteEnumSchema` fixtures                | `packages/core/test/e2e/pipeline.integration.spec.ts` (“Coverage guided with AP:false CoverageIndex”)    | Guided respecte l’univers de clés AP:false et ne dégrade pas la couverture structurelle par rapport à measure.                   |

---

## Advanced constructs — guided vs measure & coverage-report

| Motif / Feature                                      | SPEC anchors                                                                | Micro‑schema location                                                                    | Tests                                                                                                      | Invariants (actuels)                                                                                                               |
|-----------------------------------------------------|-----------------------------------------------------------------------------|-------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------|
| Arrays: `contains`, `prefixItems`, `unevaluatedItems` | spec://§9-arrays-contains, cov://§3#coverage-model                           | Inline object schema in `coverage-guided-advanced-constructs.spec.ts` (premier test)     | `packages/core/test/e2e/coverage-guided-advanced-constructs.spec.ts` (arrays test)                        | Guided ne dégrade pas `structure` vs measure; coverageReport contient des cibles pour les nœuds clés (items/contains/prefix/UEI).  |
| `patternProperties` + `unevaluatedProperties`       | spec://§7-object-keywords-pnames-rewrite, spec://§8-apfalse-must-cover      | Inline object schema in `coverage-guided-advanced-constructs.spec.ts` (second test)      | `coverage-guided-advanced-constructs.spec.ts` (patternProps + unevaluatedProperties)                      | Guided ne dégrade pas `structure` vs measure; coverageReport expose les nœuds structuraux attendus.                                 |
| `dependentRequired`, `dependentSchemas`, `not/allOf` | spec://§7-conditionals-rewrite, spec://§7-dependencies-guard, spec://§8-allof-merge | Inline object schema in `coverage-guided-advanced-constructs.spec.ts` (third test)       | `coverage-guided-advanced-constructs.spec.ts` (dependentRequired/dependentSchemas/not)                    | Guided ne dégrade pas `structure` vs measure; coverageReport doit exposer les nœuds structuraux (test actuellement rouge / à faire évoluer). |

---

## Data validity invariants (non-coverage)

| Motif / Feature                              | Micro‑schema location                                                | Tests                                                                                     | Invariants                                                                                                 |
|---------------------------------------------|---------------------------------------------------------------------|-------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------|
| `$defs.uuid` id integrity under `contains`  | Minimal order + items + contains schema in `order-items-contains-validation.spec.ts` | `packages/core/test/e2e/order-items-contains-validation.spec.ts`                         | En cas de `status: 'completed'` pour ce schéma, aucun `items[*].id` ne doit être `null` ni d’un type non string. |

---

## Property-based schema zoo (off / measure / guided invariants)

| Motif / Feature                                     | SPEC anchors                                                | Micro‑schema generator / cases                                                  | Tests                                                                                                    | Invariants                                                                                                                              |
|----------------------------------------------------|-------------------------------------------------------------|----------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------|
| Small schema zoo for coverage invariants           | cov://§3#coverage-model, cov://§4#coverage-planner, cov://§6#execution-modes-ux | `packages/core/test/property-based/coverage-schema-generator.ts` (`generateCoverageSchemas`) | `packages/core/test/property-based/coverage-off-measure-guided.spec.ts`                               | Pour chaque schéma généré: (1) `status(off) == status(measure) == status(guided)`; (2) si `status === 'completed'`, items off == measure; (3) pour chaque dimension activée, `coverage_guided[dim] >= coverage_measure[dim]`. |
| `oneOf` + enum (branches + enum dimension)         | cov://§3#coverage-model                                      | Case `id: "oneOf-enum"` dans `coverage-schema-generator.ts`                      | `coverage-off-measure-guided.spec.ts` (loop over generated cases)                                      | Même invariants que ci‑dessus, avec dimensions `['branches','enum']`.                                                                   |
| `anyOf` objects (branches dimension)               | cov://§3#coverage-model                                      | Case `id: "anyOf-object"` dans `coverage-schema-generator.ts`                    | `coverage-off-measure-guided.spec.ts`                                                                   | Même invariants, avec dimension `['branches','enum']` pour observer la non‑régression sur branches/enum.                                |
| AP:false object + patternProperties                | spec://§8-coverage-index-export, spec://§8-coverage-index-enumerate, cov://§3#coverage-model | Case `id: "apfalse-object"` dans `coverage-schema-generator.ts`                  | `coverage-off-measure-guided.spec.ts`                                                                   | Même invariants, avec dimension `['structure']`; permet de vérifier off/measure/guided sur un cas AP:false minimal.                     |
| Array with `contains` + `minContains`              | spec://§9-arrays-contains, cov://§3#coverage-model           | Case `id: "array-contains"` dans `coverage-schema-generator.ts`                  | `coverage-off-measure-guided.spec.ts`                                                                   | Même invariants, avec dimension `['structure']`; cible la sémantique `contains` sous coverage.                                          |
| Conditional `if/then` object                       | spec://§7-conditionals-rewrite, cov://§3#coverage-model      | Case `id: "conditional-if-then"` dans `coverage-schema-generator.ts`             | `coverage-off-measure-guided.spec.ts`                                                                   | Même invariants, avec dimension `['structure']`; vérifie que les runs coverage ne cassent pas la logique conditionnelle de base.       |

---

## Generator‑valid zone (`G_valid`) and “no‑repair zone” invariants

| Motif / Feature                                        | SPEC anchors                                                | Micro‑schema location                                                                                   | Tests                                                                                                                | Invariants                                                                                                                                          |
|--------------------------------------------------------|-------------------------------------------------------------|----------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------|
| `G_valid` array with simple `items` + `contains`      | spec://§6-generator-repair-contract, spec://§9-generator   | Fixture `gvalid_uuid_contains_order_items` dans `test/fixtures/g-valid-arrays.json`                     | `test/acceptance/arrays/contains-vs-maxitems.spec.ts`, `test/acceptance/gvalid-no-repair.acceptance.spec.ts`        | Pour ce schéma: (1) la localisation array est classée `G_valid v1`; (2) la pipeline termine avec `status: 'completed'`; (3) `artifacts.repairActions` est vide et `metrics.repairUsageByMotif` est absent ou vide en mode nominal (aucun Repair structurel en zone G_valid). |
| `G_valid` simple object avec `required` + `minProperties` | spec://§6-generator-repair-contract, spec://§9-generator | Fixture `gvalid_nested_customer_profile` dans `test/fixtures/g-valid-objects.json`                      | `test/acceptance/objects/g-valid-objects.spec.ts`, `test/acceptance/gvalid-no-repair.acceptance.spec.ts`            | Pour ce schéma: (1) la localisation objet est classée `G_valid`; (2) le générateur fournit tous les champs `required` sans recours au Repair; (3) aucune action Repair n’est émise sous ce `canonPath` et les métriques d’usage du Repair restent vierges pour ce motif.    |
| Regression guard “no‑repair zone”                      | spec://§6-generator-repair-contract, spec://§10-repair-engine | Réutilise les micro‑schémas `G_valid` ci‑dessus                                                          | `test/acceptance/gvalid-no-repair.acceptance.spec.ts`                                                              | Si une évolution introduit un Repair structurel ou des entrées `repairUsageByMotif` non vides sous un `canonPath` marqué `G_valid`, les tests échouent et signalent la régression sur le contrat Generator/Repair et la zone “no‑repair”.                                 |

Ces entrées décrivent les invariants “no‑repair zone” pour `G_valid`:

- les micro‑schémas ciblent explicitement des localisations classées `G_valid` par la SPEC canonique (§6);
- les tests vérifient à la fois le statut de la pipeline (`status: 'completed'`), l’absence d’actions Repair sous les `canonPath` G_valid et l’absence d’entrées pertinentes dans `metrics.repairUsageByMotif`;
- toute dérive (Repair structurel ou apparition d’itemsWithRepair/actions > 0 pour ces motifs) doit être traitée comme une régression et rendue visible par ces tests.

---

## Repair philosophy — tiers, policy codes et métriques

| Motif / Feature                                   | SPEC anchors                                                                                           | Micro‑schema location / context                                                                                         | Tests                                                                                                  | Invariants                                                                                                                                                                                                 |
|---------------------------------------------------|--------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Codes de politique tiers (`REPAIR_TIER_DISABLED`) | spec://§10#repair-philosophy, spec://§19#envelope, spec://§19#payloads                                 | Cas de blocage de tiers (ex. Repair désactivé en `G_valid` ou par profil par défaut) exercés dans les tests Repair unit | `packages/core/src/repair/__tests__/mapping-repair.test.ts` (scénarios où Repair ne peut pas appliquer une action) | Quand une action Repair est refusée pour des raisons de tiers/policy (et non de budget/guard), un diag `REPAIR_TIER_DISABLED` de phase `repair` est émis avec `details.{keyword,requestedTier,allowedMaxTier,reason}` conformes à la SPEC et `canonPath` pointant sur l’action. |
| Score/commit rule (`REPAIR_REVERTED_NO_PROGRESS`) | spec://§10#repair-philosophy, spec://§19#envelope, spec://§19#payloads                                 | Scénarios où une mutation candidate n’améliore pas `Score(x)` et doit être revert                                     | `packages/core/src/repair/__tests__/mapping-repair.test.ts` (cas Score non amélioré / rollback)       | Lorsque Score n’est pas strictement amélioré, Repair revert la mutation et peut émettre `REPAIR_REVERTED_NO_PROGRESS` (phase `repair`) avec `details.{keyword,scoreBefore,scoreAfter}`; les tests vérifient que le commit rule de §10.P5 et la phase restent stables.                         |
| Compteurs par tiers (`repair_tier*_actions`)      | spec://§10#repair-philosophy, spec://§15#metrics, spec://§19#envelope                                  | Collecte de métriques Repair dans le pipeline (usage par motif/tier)                                                   | `packages/core/src/pipeline/__tests__/pipeline-orchestrator.test.ts`, `test/acceptance/gvalid-no-repair.acceptance.spec.ts` | Les métriques `diag.metrics.repair_tier1_actions`, `repair_tier2_actions`, `repair_tier3_actions` reflètent le nombre d’actions Repair commises par tiers; en particulier, les tests G_valid s’attendent à ce que ces compteurs restent nuls pour les `canonPath` marqués `G_valid` en nominal. |
| Compteur de blocage (`repair_tierDisabled`)       | spec://§10#repair-philosophy, spec://§15#metrics, spec://§19#envelope                                  | Même contextes que ci‑dessus, lorsque des actions sont refusées par policy                                             | `packages/core/src/repair/__tests__/mapping-repair.test.ts`, `test/acceptance/gvalid-no-repair.acceptance.spec.ts` | Les métriques `diag.metrics.repair_tierDisabled` agrègent les refus de Repair pour des raisons de tiers/policy; les tests vérifient que ces compteurs s’incrémentent dans les cas prévus (tiers désactivés) et restent stables pour les exécutions où aucune politique ne bloque Repair.        |

## Notes / TODO

- Certains motifs avancés (notamment `dependentRequired`, `dependentSchemas`, `not/allOf`)
  sont couverts côté **analyzer** (SCHEMA_NODE) mais pas encore pleinement exposés dans
  le coverage-report pour les runs réalistes (tests e2e correspondants encore rouges).
- Cette matrice doit évoluer avec:
  - les nouveaux mots‑clés supportés,
  - les extensions coverage-aware (nouvelles dimensions, boundaries, operations),
  - les profils CLI (quick/balanced/thorough) et leurs invariants.

Lorsque de nouvelles fonctionnalités coverage-aware sont ajoutées à la SPEC, le flux attendu est:

1. Ajouter un micro‑schéma dédié (ou réutiliser un existant) dans les tests unitaires.
2. Ajouter des tests analyzer/generator + e2e (measure / guided / CLI) pour ce motif.
3. Enregistrer la ligne correspondante dans cette matrice (motif → micro‑schéma → tests → invariants).
4. S’assurer qu’au moins un test property-based ou génératif couvre ce motif lorsqu’il est combiné avec d’autres. 
